/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.9 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.9',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value !== 'string') {
                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite and existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i += 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
                foundMap, foundI, foundStarMap, starI,
                baseParts = baseName && baseName.split('/'),
                normalizedBaseParts = baseParts,
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    if (getOwn(config.pkgs, baseName)) {
                        //If the baseName is a package name, then just treat it as one
                        //name to concat the name with.
                        normalizedBaseParts = baseParts = [baseName];
                    } else {
                        //Convert baseName to array, and lop off the last part,
                        //so that . matches that 'directory' and not name of the baseName's
                        //module. For instance, baseName of 'one/two/three', maps to
                        //'one/two/three.js', but we want the directory, 'one/two' for
                        //this normalization.
                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    }

                    name = normalizedBaseParts.concat(name.split('/'));
                    trimDots(name);

                    //Some use of packages may use a . path to reference the
                    //'main' module name, so normalize for that.
                    pkgConfig = getOwn(config.pkgs, (pkgName = name[0]));
                    name = name.join('/');
                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
                        name = pkgName;
                    }
                } else if (name.indexOf('./') === 0) {
                    // No baseName, so this is ID is resolved relative
                    // to baseUrl, pull off the leading dot.
                    name = name.substring(2);
                }
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break;
                                }
                            }
                        }
                    }

                    if (foundMap) {
                        break;
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            return name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);
                context.require([id]);
                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = normalize(name, parentName, applyMap);
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue,
                           [defQueue.length - 1, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return mod.exports;
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            var c,
                                pkg = getOwn(config.pkgs, mod.map.id);
                            // For packages, only support config targeted
                            // at the main module.
                            c = pkg ? getOwn(config.config, mod.map.id + '/' + pkg.main) :
                                      getOwn(config.config, mod.map.id);
                            return  c || {};
                        },
                        exports: defined[mod.map.id]
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var map, modId, err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                map = mod.map;
                modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            if (this.map.isDefine) {
                                //If setting exports via 'module' is in play,
                                //favor that over return value and exports. After that,
                                //favor a non-undefined return value over exports use.
                                cjsModule = this.module;
                                if (cjsModule &&
                                        cjsModule.exports !== undefined &&
                                        //Make sure it is not already the exports value
                                        cjsModule.exports !== this.exports) {
                                    exports = cjsModule.exports;
                                } else if (exports === undefined && this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths and packages since they require special processing,
                //they are additive.
                var pkgs = config.pkgs,
                    shim = config.shim,
                    objs = {
                        paths: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (prop === 'map') {
                            if (!config.map) {
                                config.map = {};
                            }
                            mixin(config[prop], value, true, true);
                        } else {
                            mixin(config[prop], value, true);
                        }
                    } else {
                        config[prop] = value;
                    }
                });

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
                        location = pkgObj.location;

                        //Create a brand new object on pkgs, since currentPackages can
                        //be passed in again, and config.pkgs is the internal transformed
                        //state for all package configs.
                        pkgs[pkgObj.name] = {
                            name: pkgObj.name,
                            location: location || pkgObj.name,
                            //Remove leading dot in main, so main paths are normalized,
                            //and remove any trailing .js, since different package
                            //envs have different conventions: some use a module name,
                            //some use a file name.
                            main: (pkgObj.main || 'main')
                                  .replace(currDirRegExp, '')
                                  .replace(jsSuffixRegExp, '')
                        };
                    });

                    //Done with modifications, assing packages back to context config
                    config.pkgs = pkgs;
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overriden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
                    parentPath;

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;
                    pkgs = config.pkgs;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');
                        pkg = getOwn(pkgs, parentModule);
                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        } else if (pkg) {
                            //If module name is just the package name, then looking
                            //for the main module.
                            if (moduleName === pkg.name) {
                                pkgPath = pkg.location + '/' + pkg.main;
                            } else {
                                pkgPath = pkg.location;
                            }
                            syms.splice(0, i, pkgPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation that a build has been done so that
                //only one script needs to be loaded anyway. This may need to be
                //reevaluated if other use cases become common.
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one.
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                 //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

define("require.js", function(){});

/*!
 * jQuery JavaScript Library v2.1.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-23T21:10Z
 */

( function( global, factory ) {

				if ( typeof module === "object" && typeof module.exports === "object" ) {
								// For CommonJS and CommonJS-like environments where a proper window is present,
								// execute the factory and get jQuery
								// For environments that do not inherently posses a window with a document
								// (such as Node.js), expose a jQuery-making factory as module.exports
								// This accentuates the need for the creation of a real window
								// e.g. var jQuery = require("jquery")(window);
								// See ticket #14549 for more info
								module.exports = global.document ?
												factory( global, true ) :
												function( w ) {
																if ( !w.document ) {
																				throw new Error( "jQuery requires a window with a document" );
																}
																return factory( w );
								};
				} else {
								factory( global );
				}

				// Pass this if window is not defined yet
}( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

				// Can't do this because several apps including ASP.NET trace
				// the stack via arguments.caller.callee and Firefox dies if
				// you try to trace through "use strict" call chains. (#13335)
				// Support: Firefox 18+
				//

				var arr = [];

				var slice = arr.slice;

				var concat = arr.concat;

				var push = arr.push;

				var indexOf = arr.indexOf;

				var class2type = {};

				var toString = class2type.toString;

				var hasOwn = class2type.hasOwnProperty;

				var trim = "".trim;

				var support = {};



				var
				// Use the correct document accordingly with window argument (sandbox)
				document = window.document,

								version = "2.1.0",

								// Define a local copy of jQuery
								jQuery = function( selector, context ) {
												// The jQuery object is actually just the init constructor 'enhanced'
												// Need init if jQuery is called (just allow error to be thrown if not included)
												return new jQuery.fn.init( selector, context );
								},

								// Matches dashed string for camelizing
								rmsPrefix = /^-ms-/,
								rdashAlpha = /-([\da-z])/gi,

								// Used by jQuery.camelCase as callback to replace()
								fcamelCase = function( all, letter ) {
												return letter.toUpperCase();
								};

				jQuery.fn = jQuery.prototype = {
								// The current version of jQuery being used
								jquery: version,

								constructor: jQuery,

								// Start with an empty selector
								selector: "",

								// The default length of a jQuery object is 0
								length: 0,

								toArray: function() {
												return slice.call( this );
								},

								// Get the Nth element in the matched element set OR
								// Get the whole matched element set as a clean array
								get: function( num ) {
												return num != null ?

												// Return a 'clean' array
												( num < 0 ? this[ num + this.length ] : this[ num ] ) :

												// Return just the object
												slice.call( this );
								},

								// Take an array of elements and push it onto the stack
								// (returning the new matched element set)
								pushStack: function( elems ) {

												// Build a new jQuery matched element set
												var ret = jQuery.merge( this.constructor(), elems );

												// Add the old object onto the stack (as a reference)
												ret.prevObject = this;
												ret.context = this.context;

												// Return the newly-formed element set
												return ret;
								},

								// Execute a callback for every element in the matched set.
								// (You can seed the arguments with an array of args, but this is
								// only used internally.)
								each: function( callback, args ) {
												return jQuery.each( this, callback, args );
								},

								map: function( callback ) {
												return this.pushStack( jQuery.map( this, function( elem, i ) {
																return callback.call( elem, i, elem );
												} ) );
								},

								slice: function() {
												return this.pushStack( slice.apply( this, arguments ) );
								},

								first: function() {
												return this.eq( 0 );
								},

								last: function() {
												return this.eq( -1 );
								},

								eq: function( i ) {
												var len = this.length,
																j = +i + ( i < 0 ? len : 0 );
												return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
								},

								end: function() {
												return this.prevObject || this.constructor( null );
								},

								// For internal use only.
								// Behaves like an Array's method, not like a jQuery method.
								push: push,
								sort: arr.sort,
								splice: arr.splice
				};

				jQuery.extend = jQuery.fn.extend = function() {
								var options, name, src, copy, copyIsArray, clone,
												target = arguments[ 0 ] || {},
												i = 1,
												length = arguments.length,
												deep = false;

								// Handle a deep copy situation
								if ( typeof target === "boolean" ) {
												deep = target;

												// skip the boolean and the target
												target = arguments[ i ] || {};
												i++;
								}

								// Handle case when target is a string or something (possible in deep copy)
								if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
												target = {};
								}

								// extend jQuery itself if only one argument is passed
								if ( i === length ) {
												target = this;
												i--;
								}

								for ( ; i < length; i++ ) {
												// Only deal with non-null/undefined values
												if ( ( options = arguments[ i ] ) != null ) {
																// Extend the base object
																for ( name in options ) {
																				src = target[ name ];
																				copy = options[ name ];

																				// Prevent never-ending loop
																				if ( target === copy ) {
																								continue;
																				}

																				// Recurse if we're merging plain objects or arrays
																				if ( deep && copy && ( jQuery.isPlainObject( copy ) || ( copyIsArray = jQuery.isArray( copy ) ) ) ) {
																								if ( copyIsArray ) {
																												copyIsArray = false;
																												clone = src && jQuery.isArray( src ) ? src : [];

																								} else {
																												clone = src && jQuery.isPlainObject( src ) ? src : {};
																								}

																								// Never move original objects, clone them
																								target[ name ] = jQuery.extend( deep, clone, copy );

																								// Don't bring in undefined values
																				} else if ( copy !== undefined ) {
																								target[ name ] = copy;
																				}
																}
												}
								}

								// Return the modified object
								return target;
				};

				jQuery.extend( {
								// Unique for each copy of jQuery on the page
								expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

								// Assume jQuery is ready without the ready module
								isReady: true,

								error: function( msg ) {
												throw new Error( msg );
								},

								noop: function() {},

								// See test/unit/core.js for details concerning isFunction.
								// Since version 1.3, DOM methods and functions like alert
								// aren't supported. They return false on IE (#2968).
								isFunction: function( obj ) {
												return jQuery.type( obj ) === "function";
								},

								isArray: Array.isArray,

								isWindow: function( obj ) {
												return obj != null && obj === obj.window;
								},

								isNumeric: function( obj ) {
												// parseFloat NaNs numeric-cast false positives (null|true|false|"")
												// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
												// subtraction forces infinities to NaN
												return obj - parseFloat( obj ) >= 0;
								},

								isPlainObject: function( obj ) {
												// Not plain objects:
												// - Any object or value whose internal [[Class]] property is not "[object Object]"
												// - DOM nodes
												// - window
												if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
																return false;
												}

												// Support: Firefox <20
												// The try/catch suppresses exceptions thrown when attempting to access
												// the "constructor" property of certain host objects, ie. |window.location|
												// https://bugzilla.mozilla.org/show_bug.cgi?id=814622
												try {
																if ( obj.constructor && !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
																				return false;
																}
												} catch ( e ) {
																return false;
												}

												// If the function hasn't returned already, we're confident that
												// |obj| is a plain object, created by {} or constructed with new Object
												return true;
								},

								isEmptyObject: function( obj ) {
												var name;
												for ( name in obj ) {
																return false;
												}
												return true;
								},

								type: function( obj ) {
												if ( obj == null ) {
																return obj + "";
												}
												// Support: Android < 4.0, iOS < 6 (functionish RegExp)
												return typeof obj === "object" || typeof obj === "function" ?
																class2type[ toString.call( obj ) ] || "object" :
																typeof obj;
								},

								// Evaluates a script in a global context
								globalEval: function( code ) {
												var script,
																indirect = eval;

												code = jQuery.trim( code );

												if ( code ) {
																// If the code includes a valid, prologue position
																// strict mode pragma, execute code by injecting a
																// script tag into the document.
																if ( code.indexOf( "use strict" ) === 1 ) {
																				script = document.createElement( "script" );
																				script.text = code;
																				document.head.appendChild( script ).parentNode.removeChild( script );
																} else {
																				// Otherwise, avoid the DOM node creation, insertion
																				// and removal by using an indirect global eval
																				indirect( code );
																}
												}
								},

								// Convert dashed to camelCase; used by the css and data modules
								// Microsoft forgot to hump their vendor prefix (#9572)
								camelCase: function( string ) {
												return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
								},

								nodeName: function( elem, name ) {
												return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
								},

								// args is for internal usage only
								each: function( obj, callback, args ) {
												var value,
																i = 0,
																length = obj.length,
																isArray = isArraylike( obj );

												if ( args ) {
																if ( isArray ) {
																				for ( ; i < length; i++ ) {
																								value = callback.apply( obj[ i ], args );

																								if ( value === false ) {
																												break;
																								}
																				}
																} else {
																				for ( i in obj ) {
																								value = callback.apply( obj[ i ], args );

																								if ( value === false ) {
																												break;
																								}
																				}
																}

																// A special, fast, case for the most common use of each
												} else {
																if ( isArray ) {
																				for ( ; i < length; i++ ) {
																								value = callback.call( obj[ i ], i, obj[ i ] );

																								if ( value === false ) {
																												break;
																								}
																				}
																} else {
																				for ( i in obj ) {
																								value = callback.call( obj[ i ], i, obj[ i ] );

																								if ( value === false ) {
																												break;
																								}
																				}
																}
												}

												return obj;
								},

								trim: function( text ) {
												return text == null ? "" : trim.call( text );
								},

								// results is for internal usage only
								makeArray: function( arr, results ) {
												var ret = results || [];

												if ( arr != null ) {
																if ( isArraylike( Object( arr ) ) ) {
																				jQuery.merge( ret,
																								typeof arr === "string" ?
																								[ arr ] : arr
																				);
																} else {
																				push.call( ret, arr );
																}
												}

												return ret;
								},

								inArray: function( elem, arr, i ) {
												return arr == null ? -1 : indexOf.call( arr, elem, i );
								},

								merge: function( first, second ) {
												var len = +second.length,
																j = 0,
																i = first.length;

												for ( ; j < len; j++ ) {
																first[ i++ ] = second[ j ];
												}

												first.length = i;

												return first;
								},

								grep: function( elems, callback, invert ) {
												var callbackInverse,
																matches = [],
																i = 0,
																length = elems.length,
																callbackExpect = !invert;

												// Go through the array, only saving the items
												// that pass the validator function
												for ( ; i < length; i++ ) {
																callbackInverse = !callback( elems[ i ], i );
																if ( callbackInverse !== callbackExpect ) {
																				matches.push( elems[ i ] );
																}
												}

												return matches;
								},

								// arg is for internal usage only
								map: function( elems, callback, arg ) {
												var value,
																i = 0,
																length = elems.length,
																isArray = isArraylike( elems ),
																ret = [];

												// Go through the array, translating each of the items to their new values
												if ( isArray ) {
																for ( ; i < length; i++ ) {
																				value = callback( elems[ i ], i, arg );

																				if ( value != null ) {
																								ret.push( value );
																				}
																}

																// Go through every key on the object,
												} else {
																for ( i in elems ) {
																				value = callback( elems[ i ], i, arg );

																				if ( value != null ) {
																								ret.push( value );
																				}
																}
												}

												// Flatten any nested arrays
												return concat.apply( [], ret );
								},

								// A global GUID counter for objects
								guid: 1,

								// Bind a function to a context, optionally partially applying any
								// arguments.
								proxy: function( fn, context ) {
												var tmp, args, proxy;

												if ( typeof context === "string" ) {
																tmp = fn[ context ];
																context = fn;
																fn = tmp;
												}

												// Quick check to determine if target is callable, in the spec
												// this throws a TypeError, but we will just return undefined.
												if ( !jQuery.isFunction( fn ) ) {
																return undefined;
												}

												// Simulated bind
												args = slice.call( arguments, 2 );
												proxy = function() {
																return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
												};

												// Set the guid of unique handler to the same of original handler, so it can be removed
												proxy.guid = fn.guid = fn.guid || jQuery.guid++;

												return proxy;
								},

								now: Date.now,

								// jQuery.support is not used in Core but other projects attach their
								// properties to it so it needs to exist.
								support: support
				} );

				// Populate the class2type map
				jQuery.each( "Boolean Number String Function Array Date RegExp Object Error".split( " " ), function( i, name ) {
								class2type[ "[object " + name + "]" ] = name.toLowerCase();
				} );

				function isArraylike( obj ) {
								var length = obj.length,
												type = jQuery.type( obj );

								if ( type === "function" || jQuery.isWindow( obj ) ) {
												return false;
								}

								if ( obj.nodeType === 1 && length ) {
												return true;
								}

								return type === "array" || length === 0 ||
												typeof length === "number" && length > 0 && ( length - 1 ) in obj;
				}
				var Sizzle =
				/*!
				 * Sizzle CSS Selector Engine v1.10.16
				 * http://sizzlejs.com/
				 *
				 * Copyright 2013 jQuery Foundation, Inc. and other contributors
				 * Released under the MIT license
				 * http://jquery.org/license
				 *
				 * Date: 2014-01-13
				 */
				( function( window ) {

								var i,
												support,
												Expr,
												getText,
												isXML,
												compile,
												outermostContext,
												sortInput,
												hasDuplicate,

												// Local document vars
												setDocument,
												document,
												docElem,
												documentIsHTML,
												rbuggyQSA,
												rbuggyMatches,
												matches,
												contains,

												// Instance-specific data
												expando = "sizzle" + -( new Date() ),
												preferredDoc = window.document,
												dirruns = 0,
												done = 0,
												classCache = createCache(),
												tokenCache = createCache(),
												compilerCache = createCache(),
												sortOrder = function( a, b ) {
																if ( a === b ) {
																				hasDuplicate = true;
																}
																return 0;
												},

												// General-purpose constants
												strundefined = typeof undefined,
												MAX_NEGATIVE = 1 << 31,

												// Instance methods
												hasOwn = ( {} ).hasOwnProperty,
												arr = [],
												pop = arr.pop,
												push_native = arr.push,
												push = arr.push,
												slice = arr.slice,
												// Use a stripped-down indexOf if we can't use a native one
												indexOf = arr.indexOf || function( elem ) {
																var i = 0,
																				len = this.length;
																for ( ; i < len; i++ ) {
																				if ( this[ i ] === elem ) {
																								return i;
																				}
																}
																return -1;
												},

												booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

												// Regular expressions

												// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
												whitespace = "[\\x20\\t\\r\\n\\f]",
												// http://www.w3.org/TR/css3-syntax/#characters
												characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

												// Loosely modeled on CSS identifier characters
												// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
												// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
												identifier = characterEncoding.replace( "w", "w#" ),

												// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
												attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
																"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

												// Prefer arguments quoted,
												//   then not containing pseudos/brackets,
												//   then attribute selectors/non-parenthetical expressions,
												//   then anything else
												// These preferences are here to reduce the number of selectors
												//   needing tokenize in the PSEUDO preFilter
												pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

												// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
												rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

												rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
												rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

												rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

												rpseudo = new RegExp( pseudos ),
												ridentifier = new RegExp( "^" + identifier + "$" ),

												matchExpr = {
																"ID": new RegExp( "^#(" + characterEncoding + ")" ),
																"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
																"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
																"ATTR": new RegExp( "^" + attributes ),
																"PSEUDO": new RegExp( "^" + pseudos ),
																"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
																				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
																				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
																"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
																// For use in libraries implementing .is()
																// We use this for POS matching in `select`
																"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
																				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
												},

												rinputs = /^(?:input|select|textarea|button)$/i,
												rheader = /^h\d$/i,

												rnative = /^[^{]+\{\s*\[native \w/,

												// Easily-parseable/retrievable ID or TAG or CLASS selectors
												rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

												rsibling = /[+~]/,
												rescape = /'|\\/g,

												// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
												runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
												funescape = function( _, escaped, escapedWhitespace ) {
																var high = "0x" + escaped - 0x10000;
																// NaN means non-codepoint
																// Support: Firefox
																// Workaround erroneous numeric interpretation of +"0x"
																return high !== high || escapedWhitespace ?
																				escaped :
																				high < 0 ?
																// BMP codepoint
																String.fromCharCode( high + 0x10000 ) :
																// Supplemental Plane codepoint (surrogate pair)
																String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
												};

								// Optimize for push.apply( _, NodeList )
								try {
												push.apply(
																( arr = slice.call( preferredDoc.childNodes ) ),
																preferredDoc.childNodes
												);
												// Support: Android<4.0
												// Detect silently failing push.apply
												arr[ preferredDoc.childNodes.length ].nodeType;
								} catch ( e ) {
												push = {
																apply: arr.length ?

																// Leverage slice if possible
																function( target, els ) {
																				push_native.apply( target, slice.call( els ) );
																} :

																// Support: IE<9
																// Otherwise append directly
																function( target, els ) {
																				var j = target.length,
																								i = 0;
																				// Can't trust NodeList.length
																				while ( ( target[ j++ ] = els[ i++ ] ) ) {}
																				target.length = j - 1;
																}
												};
								}

								function Sizzle( selector, context, results, seed ) {
												var match, elem, m, nodeType,
																// QSA vars
																i, groups, old, nid, newContext, newSelector;

												if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
																setDocument( context );
												}

												context = context || document;
												results = results || [];

												if ( !selector || typeof selector !== "string" ) {
																return results;
												}

												if ( ( nodeType = context.nodeType ) !== 1 && nodeType !== 9 ) {
																return [];
												}

												if ( documentIsHTML && !seed ) {

																// Shortcuts
																if ( ( match = rquickExpr.exec( selector ) ) ) {
																				// Speed-up: Sizzle("#ID")
																				if ( ( m = match[ 1 ] ) ) {
																								if ( nodeType === 9 ) {
																												elem = context.getElementById( m );
																												// Check parentNode to catch when Blackberry 4.6 returns
																												// nodes that are no longer in the document (jQuery #6963)
																												if ( elem && elem.parentNode ) {
																																// Handle the case where IE, Opera, and Webkit return items
																																// by name instead of ID
																																if ( elem.id === m ) {
																																				results.push( elem );
																																				return results;
																																}
																												} else {
																																return results;
																												}
																								} else {
																												// Context is not a document
																												if ( context.ownerDocument && ( elem = context.ownerDocument.getElementById( m ) ) &&
																																contains( context, elem ) && elem.id === m ) {
																																results.push( elem );
																																return results;
																												}
																								}

																								// Speed-up: Sizzle("TAG")
																				} else if ( match[ 2 ] ) {
																								push.apply( results, context.getElementsByTagName( selector ) );
																								return results;

																								// Speed-up: Sizzle(".CLASS")
																				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName && context.getElementsByClassName ) {
																								push.apply( results, context.getElementsByClassName( m ) );
																								return results;
																				}
																}

																// QSA path
																if ( support.qsa && ( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {
																				nid = old = expando;
																				newContext = context;
																				newSelector = nodeType === 9 && selector;

																				// qSA works strangely on Element-rooted queries
																				// We can work around this by specifying an extra ID on the root
																				// and working up from there (Thanks to Andrew Dupont for the technique)
																				// IE 8 doesn't work on object elements
																				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
																								groups = tokenize( selector );

																								if ( ( old = context.getAttribute( "id" ) ) ) {
																												nid = old.replace( rescape, "\\$&" );
																								} else {
																												context.setAttribute( "id", nid );
																								}
																								nid = "[id='" + nid + "'] ";

																								i = groups.length;
																								while ( i-- ) {
																												groups[ i ] = nid + toSelector( groups[ i ] );
																								}
																								newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
																								newSelector = groups.join( "," );
																				}

																				if ( newSelector ) {
																								try {
																												push.apply( results,
																																newContext.querySelectorAll( newSelector )
																												);
																												return results;
																								} catch ( qsaError ) {} finally {
																												if ( !old ) {
																																context.removeAttribute( "id" );
																												}
																								}
																				}
																}
												}

												// All others
												return select( selector.replace( rtrim, "$1" ), context, results, seed );
								}

								/**
								 * Create key-value caches of limited size
								 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
								 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
								 *	deleting the oldest entry
								 */
								function createCache() {
												var keys = [];

												function cache( key, value ) {
																// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
																if ( keys.push( key + " " ) > Expr.cacheLength ) {
																				// Only keep the most recent entries
																				delete cache[ keys.shift() ];
																}
																return ( cache[ key + " " ] = value );
												}
												return cache;
								}

								/**
								 * Mark a function for special use by Sizzle
								 * @param {Function} fn The function to mark
								 */
								function markFunction( fn ) {
												fn[ expando ] = true;
												return fn;
								}

								/**
								 * Support testing using an element
								 * @param {Function} fn Passed the created div and expects a boolean result
								 */
								function assert( fn ) {
												var div = document.createElement( "div" );

												try {
																return !!fn( div );
												} catch ( e ) {
																return false;
												} finally {
																// Remove from its parent by default
																if ( div.parentNode ) {
																				div.parentNode.removeChild( div );
																}
																// release memory in IE
																div = null;
												}
								}

								/**
								 * Adds the same handler for all of the specified attrs
								 * @param {String} attrs Pipe-separated list of attributes
								 * @param {Function} handler The method that will be applied
								 */
								function addHandle( attrs, handler ) {
												var arr = attrs.split( "|" ),
																i = attrs.length;

												while ( i-- ) {
																Expr.attrHandle[ arr[ i ] ] = handler;
												}
								}

								/**
								 * Checks document order of two siblings
								 * @param {Element} a
								 * @param {Element} b
								 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
								 */
								function siblingCheck( a, b ) {
												var cur = b && a,
																diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
																				( ~b.sourceIndex || MAX_NEGATIVE ) -
																				( ~a.sourceIndex || MAX_NEGATIVE );

												// Use IE sourceIndex if available on both nodes
												if ( diff ) {
																return diff;
												}

												// Check if b follows a
												if ( cur ) {
																while ( ( cur = cur.nextSibling ) ) {
																				if ( cur === b ) {
																								return -1;
																				}
																}
												}

												return a ? 1 : -1;
								}

								/**
								 * Returns a function to use in pseudos for input types
								 * @param {String} type
								 */
								function createInputPseudo( type ) {
												return function( elem ) {
																var name = elem.nodeName.toLowerCase();
																return name === "input" && elem.type === type;
												};
								}

								/**
								 * Returns a function to use in pseudos for buttons
								 * @param {String} type
								 */
								function createButtonPseudo( type ) {
												return function( elem ) {
																var name = elem.nodeName.toLowerCase();
																return ( name === "input" || name === "button" ) && elem.type === type;
												};
								}

								/**
								 * Returns a function to use in pseudos for positionals
								 * @param {Function} fn
								 */
								function createPositionalPseudo( fn ) {
												return markFunction( function( argument ) {
																argument = +argument;
																return markFunction( function( seed, matches ) {
																				var j,
																								matchIndexes = fn( [], seed.length, argument ),
																								i = matchIndexes.length;

																				// Match elements found at the specified indexes
																				while ( i-- ) {
																								if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
																												seed[ j ] = !( matches[ j ] = seed[ j ] );
																								}
																				}
																} );
												} );
								}

								/**
								 * Checks a node for validity as a Sizzle context
								 * @param {Element|Object=} context
								 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
								 */
								function testContext( context ) {
												return context && typeof context.getElementsByTagName !== strundefined && context;
								}

								// Expose support vars for convenience
								support = Sizzle.support = {};

								/**
								 * Detects XML nodes
								 * @param {Element|Object} elem An element or a document
								 * @returns {Boolean} True iff elem is a non-HTML XML node
								 */
								isXML = Sizzle.isXML = function( elem ) {
												// documentElement is verified for cases where it doesn't yet exist
												// (such as loading iframes in IE - #4833)
												var documentElement = elem && ( elem.ownerDocument || elem ).documentElement;
												return documentElement ? documentElement.nodeName !== "HTML" : false;
								};

								/**
								 * Sets document-related variables once based on the current document
								 * @param {Element|Object} [doc] An element or document object to use to set the document
								 * @returns {Object} Returns the current document
								 */
								setDocument = Sizzle.setDocument = function( node ) {
												var hasCompare,
																doc = node ? node.ownerDocument || node : preferredDoc,
																parent = doc.defaultView;

												// If no document and documentElement is available, return
												if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
																return document;
												}

												// Set our document
												document = doc;
												docElem = doc.documentElement;

												// Support tests
												documentIsHTML = !isXML( doc );

												// Support: IE>8
												// If iframe document is assigned to "document" variable and if iframe has been reloaded,
												// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
												// IE6-8 do not support the defaultView property so parent will be undefined
												if ( parent && parent !== parent.top ) {
																// IE11 does not have attachEvent, so all must suffer
																if ( parent.addEventListener ) {
																				parent.addEventListener( "unload", function() {
																								setDocument();
																				}, false );
																} else if ( parent.attachEvent ) {
																				parent.attachEvent( "onunload", function() {
																								setDocument();
																				} );
																}
												}

												/* Attributes
	---------------------------------------------------------------------- */

												// Support: IE<8
												// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
												support.attributes = assert( function( div ) {
																div.className = "i";
																return !div.getAttribute( "className" );
												} );

												/* getElement(s)By*
	---------------------------------------------------------------------- */

												// Check if getElementsByTagName("*") returns only elements
												support.getElementsByTagName = assert( function( div ) {
																div.appendChild( doc.createComment( "" ) );
																return !div.getElementsByTagName( "*" ).length;
												} );

												// Check if getElementsByClassName can be trusted
												support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert( function( div ) {
																div.innerHTML = "<div class='a'></div><div class='a i'></div>";

																// Support: Safari<4
																// Catch class over-caching
																div.firstChild.className = "i";
																// Support: Opera<10
																// Catch gEBCN failure to find non-leading classes
																return div.getElementsByClassName( "i" ).length === 2;
												} );

												// Support: IE<10
												// Check if getElementById returns elements by name
												// The broken getElementById methods don't pick up programatically-set names,
												// so use a roundabout getElementsByName test
												support.getById = assert( function( div ) {
																docElem.appendChild( div ).id = expando;
																return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
												} );

												// ID find and filter
												if ( support.getById ) {
																Expr.find[ "ID" ] = function( id, context ) {
																				if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
																								var m = context.getElementById( id );
																								// Check parentNode to catch when Blackberry 4.6 returns
																								// nodes that are no longer in the document #6963
																								return m && m.parentNode ? [ m ] : [];
																				}
																};
																Expr.filter[ "ID" ] = function( id ) {
																				var attrId = id.replace( runescape, funescape );
																				return function( elem ) {
																								return elem.getAttribute( "id" ) === attrId;
																				};
																};
												} else {
																// Support: IE6/7
																// getElementById is not reliable as a find shortcut
																delete Expr.find[ "ID" ];

																Expr.filter[ "ID" ] = function( id ) {
																				var attrId = id.replace( runescape, funescape );
																				return function( elem ) {
																								var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode( "id" );
																								return node && node.value === attrId;
																				};
																};
												}

												// Tag
												Expr.find[ "TAG" ] = support.getElementsByTagName ?
																function( tag, context ) {
																				if ( typeof context.getElementsByTagName !== strundefined ) {
																								return context.getElementsByTagName( tag );
																				}
												} :
																function( tag, context ) {
																				var elem,
																								tmp = [],
																								i = 0,
																								results = context.getElementsByTagName( tag );

																				// Filter out possible comments
																				if ( tag === "*" ) {
																								while ( ( elem = results[ i++ ] ) ) {
																												if ( elem.nodeType === 1 ) {
																																tmp.push( elem );
																												}
																								}

																								return tmp;
																				}
																				return results;
												};

												// Class
												Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
																if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
																				return context.getElementsByClassName( className );
																}
												};

												/* QSA/matchesSelector
	---------------------------------------------------------------------- */

												// QSA and matchesSelector support

												// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
												rbuggyMatches = [];

												// qSa(:focus) reports false when true (Chrome 21)
												// We allow this because of a bug in IE8/9 that throws an error
												// whenever `document.activeElement` is accessed on an iframe
												// So, we allow :focus to pass through QSA all the time to avoid the IE error
												// See http://bugs.jquery.com/ticket/13378
												rbuggyQSA = [];

												if ( ( support.qsa = rnative.test( doc.querySelectorAll ) ) ) {
																// Build QSA regex
																// Regex strategy adopted from Diego Perini
																assert( function( div ) {
																				// Select is set to empty string on purpose
																				// This is to test IE's treatment of not explicitly
																				// setting a boolean content attribute,
																				// since its presence should be enough
																				// http://bugs.jquery.com/ticket/12359
																				div.innerHTML = "<select t=''><option selected=''></option></select>";

																				// Support: IE8, Opera 10-12
																				// Nothing should be selected when empty strings follow ^= or $= or *=
																				if ( div.querySelectorAll( "[t^='']" ).length ) {
																								rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
																				}

																				// Support: IE8
																				// Boolean attributes and "value" are not treated correctly
																				if ( !div.querySelectorAll( "[selected]" ).length ) {
																								rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
																				}

																				// Webkit/Opera - :checked should return selected option elements
																				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
																				// IE8 throws error here and will not see later tests
																				if ( !div.querySelectorAll( ":checked" ).length ) {
																								rbuggyQSA.push( ":checked" );
																				}
																} );

																assert( function( div ) {
																				// Support: Windows 8 Native Apps
																				// The type and name attributes are restricted during .innerHTML assignment
																				var input = doc.createElement( "input" );
																				input.setAttribute( "type", "hidden" );
																				div.appendChild( input ).setAttribute( "name", "D" );

																				// Support: IE8
																				// Enforce case-sensitivity of name attribute
																				if ( div.querySelectorAll( "[name=d]" ).length ) {
																								rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
																				}

																				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
																				// IE8 throws error here and will not see later tests
																				if ( !div.querySelectorAll( ":enabled" ).length ) {
																								rbuggyQSA.push( ":enabled", ":disabled" );
																				}

																				// Opera 10-11 does not throw on post-comma invalid pseudos
																				div.querySelectorAll( "*,:x" );
																				rbuggyQSA.push( ",.*:" );
																} );
												}

												if ( ( support.matchesSelector = rnative.test( ( matches = docElem.webkitMatchesSelector ||
																docElem.mozMatchesSelector ||
																docElem.oMatchesSelector ||
																docElem.msMatchesSelector ) ) ) ) {

																assert( function( div ) {
																				// Check to see if it's possible to do matchesSelector
																				// on a disconnected node (IE 9)
																				support.disconnectedMatch = matches.call( div, "div" );

																				// This should fail with an exception
																				// Gecko does not error, returns false instead
																				matches.call( div, "[s!='']:x" );
																				rbuggyMatches.push( "!=", pseudos );
																} );
												}

												rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
												rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

												/* Contains
	---------------------------------------------------------------------- */
												hasCompare = rnative.test( docElem.compareDocumentPosition );

												// Element contains another
												// Purposefully does not implement inclusive descendent
												// As in, an element does not contain itself
												contains = hasCompare || rnative.test( docElem.contains ) ?
																function( a, b ) {
																				var adown = a.nodeType === 9 ? a.documentElement : a,
																								bup = b && b.parentNode;
																				return a === bup || !! ( bup && bup.nodeType === 1 && (
																								adown.contains ?
																								adown.contains( bup ) :
																								a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
																				) );
												} :
																function( a, b ) {
																				if ( b ) {
																								while ( ( b = b.parentNode ) ) {
																												if ( b === a ) {
																																return true;
																												}
																								}
																				}
																				return false;
												};

												/* Sorting
	---------------------------------------------------------------------- */

												// Document order sorting
												sortOrder = hasCompare ?
																function( a, b ) {

																				// Flag for duplicate removal
																				if ( a === b ) {
																								hasDuplicate = true;
																								return 0;
																				}

																				// Sort on method existence if only one input has compareDocumentPosition
																				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
																				if ( compare ) {
																								return compare;
																				}

																				// Calculate position if both inputs belong to the same document
																				compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
																								a.compareDocumentPosition( b ) :

																				// Otherwise we know they are disconnected
																				1;

																				// Disconnected nodes
																				if ( compare & 1 ||
																								( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

																								// Choose the first element that is related to our preferred document
																								if ( a === doc || a.ownerDocument === preferredDoc && contains( preferredDoc, a ) ) {
																												return -1;
																								}
																								if ( b === doc || b.ownerDocument === preferredDoc && contains( preferredDoc, b ) ) {
																												return 1;
																								}

																								// Maintain original order
																								return sortInput ?
																												( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
																												0;
																				}

																				return compare & 4 ? -1 : 1;
												} :
																function( a, b ) {
																				// Exit early if the nodes are identical
																				if ( a === b ) {
																								hasDuplicate = true;
																								return 0;
																				}

																				var cur,
																								i = 0,
																								aup = a.parentNode,
																								bup = b.parentNode,
																								ap = [ a ],
																								bp = [ b ];

																				// Parentless nodes are either documents or disconnected
																				if ( !aup || !bup ) {
																								return a === doc ? -1 :
																												b === doc ? 1 :
																												aup ? -1 :
																												bup ? 1 :
																												sortInput ?
																												( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
																												0;

																								// If the nodes are siblings, we can do a quick check
																				} else if ( aup === bup ) {
																								return siblingCheck( a, b );
																				}

																				// Otherwise we need full lists of their ancestors for comparison
																				cur = a;
																				while ( ( cur = cur.parentNode ) ) {
																								ap.unshift( cur );
																				}
																				cur = b;
																				while ( ( cur = cur.parentNode ) ) {
																								bp.unshift( cur );
																				}

																				// Walk down the tree looking for a discrepancy
																				while ( ap[ i ] === bp[ i ] ) {
																								i++;
																				}

																				return i ?
																				// Do a sibling check if the nodes have a common ancestor
																				siblingCheck( ap[ i ], bp[ i ] ) :

																				// Otherwise nodes in our document sort first
																				ap[ i ] === preferredDoc ? -1 :
																								bp[ i ] === preferredDoc ? 1 :
																								0;
												};

												return doc;
								};

								Sizzle.matches = function( expr, elements ) {
												return Sizzle( expr, null, null, elements );
								};

								Sizzle.matchesSelector = function( elem, expr ) {
												// Set document vars if needed
												if ( ( elem.ownerDocument || elem ) !== document ) {
																setDocument( elem );
												}

												// Make sure that attribute selectors are quoted
												expr = expr.replace( rattributeQuotes, "='$1']" );

												if ( support.matchesSelector && documentIsHTML &&
																( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
																( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

																try {
																				var ret = matches.call( elem, expr );

																				// IE 9's matchesSelector returns false on disconnected nodes
																				if ( ret || support.disconnectedMatch ||
																								// As well, disconnected nodes are said to be in a document
																								// fragment in IE 9
																								elem.document && elem.document.nodeType !== 11 ) {
																								return ret;
																				}
																} catch ( e ) {}
												}

												return Sizzle( expr, document, null, [ elem ] ).length > 0;
								};

								Sizzle.contains = function( context, elem ) {
												// Set document vars if needed
												if ( ( context.ownerDocument || context ) !== document ) {
																setDocument( context );
												}
												return contains( context, elem );
								};

								Sizzle.attr = function( elem, name ) {
												// Set document vars if needed
												if ( ( elem.ownerDocument || elem ) !== document ) {
																setDocument( elem );
												}

												var fn = Expr.attrHandle[ name.toLowerCase() ],
																// Don't get fooled by Object.prototype properties (jQuery #13807)
																val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
																				fn( elem, name, !documentIsHTML ) :
																				undefined;

												return val !== undefined ?
																val :
																support.attributes || !documentIsHTML ?
																elem.getAttribute( name ) :
																( val = elem.getAttributeNode( name ) ) && val.specified ?
																val.value :
																null;
								};

								Sizzle.error = function( msg ) {
												throw new Error( "Syntax error, unrecognized expression: " + msg );
								};

								/**
								 * Document sorting and removing duplicates
								 * @param {ArrayLike} results
								 */
								Sizzle.uniqueSort = function( results ) {
												var elem,
																duplicates = [],
																j = 0,
																i = 0;

												// Unless we *know* we can detect duplicates, assume their presence
												hasDuplicate = !support.detectDuplicates;
												sortInput = !support.sortStable && results.slice( 0 );
												results.sort( sortOrder );

												if ( hasDuplicate ) {
																while ( ( elem = results[ i++ ] ) ) {
																				if ( elem === results[ i ] ) {
																								j = duplicates.push( i );
																				}
																}
																while ( j-- ) {
																				results.splice( duplicates[ j ], 1 );
																}
												}

												// Clear input after sorting to release objects
												// See https://github.com/jquery/sizzle/pull/225
												sortInput = null;

												return results;
								};

								/**
								 * Utility function for retrieving the text value of an array of DOM nodes
								 * @param {Array|Element} elem
								 */
								getText = Sizzle.getText = function( elem ) {
												var node,
																ret = "",
																i = 0,
																nodeType = elem.nodeType;

												if ( !nodeType ) {
																// If no nodeType, this is expected to be an array
																while ( ( node = elem[ i++ ] ) ) {
																				// Do not traverse comment nodes
																				ret += getText( node );
																}
												} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
																// Use textContent for elements
																// innerText usage removed for consistency of new lines (jQuery #11153)
																if ( typeof elem.textContent === "string" ) {
																				return elem.textContent;
																} else {
																				// Traverse its children
																				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
																								ret += getText( elem );
																				}
																}
												} else if ( nodeType === 3 || nodeType === 4 ) {
																return elem.nodeValue;
												}
												// Do not include comment or processing instruction nodes

												return ret;
								};

								Expr = Sizzle.selectors = {

												// Can be adjusted by the user
												cacheLength: 50,

												createPseudo: markFunction,

												match: matchExpr,

												attrHandle: {},

												find: {},

												relative: {
																">": {
																				dir: "parentNode",
																				first: true
																},
																" ": {
																				dir: "parentNode"
																},
																"+": {
																				dir: "previousSibling",
																				first: true
																},
																"~": {
																				dir: "previousSibling"
																}
												},

												preFilter: {
																"ATTR": function( match ) {
																				match[ 1 ] = match[ 1 ].replace( runescape, funescape );

																				// Move the given value to match[3] whether quoted or unquoted
																				match[ 3 ] = ( match[ 4 ] || match[ 5 ] || "" ).replace( runescape, funescape );

																				if ( match[ 2 ] === "~=" ) {
																								match[ 3 ] = " " + match[ 3 ] + " ";
																				}

																				return match.slice( 0, 4 );
																},

																"CHILD": function( match ) {
																				/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
																				match[ 1 ] = match[ 1 ].toLowerCase();

																				if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {
																								// nth-* requires argument
																								if ( !match[ 3 ] ) {
																												Sizzle.error( match[ 0 ] );
																								}

																								// numeric x and y parameters for Expr.filter.CHILD
																								// remember that false/true cast respectively to 0/1
																								match[ 4 ] = +( match[ 4 ] ? match[ 5 ] + ( match[ 6 ] || 1 ) : 2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
																								match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

																								// other types prohibit arguments
																				} else if ( match[ 3 ] ) {
																								Sizzle.error( match[ 0 ] );
																				}

																				return match;
																},

																"PSEUDO": function( match ) {
																				var excess,
																								unquoted = !match[ 5 ] && match[ 2 ];

																				if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
																								return null;
																				}

																				// Accept quoted arguments as-is
																				if ( match[ 3 ] && match[ 4 ] !== undefined ) {
																								match[ 2 ] = match[ 4 ];

																								// Strip excess characters from unquoted arguments
																				} else if ( unquoted && rpseudo.test( unquoted ) &&
																								// Get excess from tokenize (recursively)
																								( excess = tokenize( unquoted, true ) ) &&
																								// advance to the next closing parenthesis
																								( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

																								// excess is a negative index
																								match[ 0 ] = match[ 0 ].slice( 0, excess );
																								match[ 2 ] = unquoted.slice( 0, excess );
																				}

																				// Return only captures needed by the pseudo filter method (type and argument)
																				return match.slice( 0, 3 );
																}
												},

												filter: {

																"TAG": function( nodeNameSelector ) {
																				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
																				return nodeNameSelector === "*" ?
																								function() {
																												return true;
																				} :
																								function( elem ) {
																												return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
																				};
																},

																"CLASS": function( className ) {
																				var pattern = classCache[ className + " " ];

																				return pattern ||
																								( pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" ) ) &&
																								classCache( className, function( elem ) {
																												return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute( "class" ) || "" );
																								} );
																},

																"ATTR": function( name, operator, check ) {
																				return function( elem ) {
																								var result = Sizzle.attr( elem, name );

																								if ( result == null ) {
																												return operator === "!=";
																								}
																								if ( !operator ) {
																												return true;
																								}

																								result += "";

																								return operator === "=" ? result === check :
																												operator === "!=" ? result !== check :
																												operator === "^=" ? check && result.indexOf( check ) === 0 :
																												operator === "*=" ? check && result.indexOf( check ) > -1 :
																												operator === "$=" ? check && result.slice( -check.length ) === check :
																												operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
																												operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
																												false;
																				};
																},

																"CHILD": function( type, what, argument, first, last ) {
																				var simple = type.slice( 0, 3 ) !== "nth",
																								forward = type.slice( -4 ) !== "last",
																								ofType = what === "of-type";

																				return first === 1 && last === 0 ?

																				// Shortcut for :nth-*(n)
																				function( elem ) {
																								return !!elem.parentNode;
																				} :

																				function( elem, context, xml ) {
																								var cache, outerCache, node, diff, nodeIndex, start,
																												dir = simple !== forward ? "nextSibling" : "previousSibling",
																												parent = elem.parentNode,
																												name = ofType && elem.nodeName.toLowerCase(),
																												useCache = !xml && !ofType;

																								if ( parent ) {

																												// :(first|last|only)-(child|of-type)
																												if ( simple ) {
																																while ( dir ) {
																																				node = elem;
																																				while ( ( node = node[ dir ] ) ) {
																																								if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
																																												return false;
																																								}
																																				}
																																				// Reverse direction for :only-* (if we haven't yet done so)
																																				start = dir = type === "only" && !start && "nextSibling";
																																}
																																return true;
																												}

																												start = [ forward ? parent.firstChild : parent.lastChild ];

																												// non-xml :nth-child(...) stores cache data on `parent`
																												if ( forward && useCache ) {
																																// Seek `elem` from a previously-cached index
																																outerCache = parent[ expando ] || ( parent[ expando ] = {} );
																																cache = outerCache[ type ] || [];
																																nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
																																diff = cache[ 0 ] === dirruns && cache[ 2 ];
																																node = nodeIndex && parent.childNodes[ nodeIndex ];

																																while ( ( node = ++nodeIndex && node && node[ dir ] ||

																																				// Fallback to seeking `elem` from the start
																																				( diff = nodeIndex = 0 ) || start.pop() ) ) {

																																				// When found, cache indexes on `parent` and break
																																				if ( node.nodeType === 1 && ++diff && node === elem ) {
																																								outerCache[ type ] = [ dirruns, nodeIndex, diff ];
																																								break;
																																				}
																																}

																																// Use previously-cached element index if available
																												} else if ( useCache && ( cache = ( elem[ expando ] || ( elem[ expando ] = {} ) )[ type ] ) && cache[ 0 ] === dirruns ) {
																																diff = cache[ 1 ];

																																// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
																												} else {
																																// Use the same loop as above to seek `elem` from the start
																																while ( ( node = ++nodeIndex && node && node[ dir ] ||
																																				( diff = nodeIndex = 0 ) || start.pop() ) ) {

																																				if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
																																								// Cache the index of each encountered element
																																								if ( useCache ) {
																																												( node[ expando ] || ( node[ expando ] = {} ) )[ type ] = [ dirruns, diff ];
																																								}

																																								if ( node === elem ) {
																																												break;
																																								}
																																				}
																																}
																												}

																												// Incorporate the offset, then check against cycle size
																												diff -= last;
																												return diff === first || ( diff % first === 0 && diff / first >= 0 );
																								}
																				};
																},

																"PSEUDO": function( pseudo, argument ) {
																				// pseudo-class names are case-insensitive
																				// http://www.w3.org/TR/selectors/#pseudo-classes
																				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
																				// Remember that setFilters inherits from pseudos
																				var args,
																								fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
																												Sizzle.error( "unsupported pseudo: " + pseudo );

																				// The user may use createPseudo to indicate that
																				// arguments are needed to create the filter function
																				// just as Sizzle does
																				if ( fn[ expando ] ) {
																								return fn( argument );
																				}

																				// But maintain support for old signatures
																				if ( fn.length > 1 ) {
																								args = [ pseudo, pseudo, "", argument ];
																								return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
																												markFunction( function( seed, matches ) {
																																var idx,
																																				matched = fn( seed, argument ),
																																				i = matched.length;
																																while ( i-- ) {
																																				idx = indexOf.call( seed, matched[ i ] );
																																				seed[ idx ] = !( matches[ idx ] = matched[ i ] );
																																}
																												} ) :
																												function( elem ) {
																																return fn( elem, 0, args );
																								};
																				}

																				return fn;
																}
												},

												pseudos: {
																// Potentially complex pseudos
																"not": markFunction( function( selector ) {
																				// Trim the selector passed to compile
																				// to avoid treating leading and trailing
																				// spaces as combinators
																				var input = [],
																								results = [],
																								matcher = compile( selector.replace( rtrim, "$1" ) );

																				return matcher[ expando ] ?
																								markFunction( function( seed, matches, context, xml ) {
																												var elem,
																																unmatched = matcher( seed, null, xml, [] ),
																																i = seed.length;

																												// Match elements unmatched by `matcher`
																												while ( i-- ) {
																																if ( ( elem = unmatched[ i ] ) ) {
																																				seed[ i ] = !( matches[ i ] = elem );
																																}
																												}
																								} ) :
																								function( elem, context, xml ) {
																												input[ 0 ] = elem;
																												matcher( input, null, xml, results );
																												return !results.pop();
																				};
																} ),

																"has": markFunction( function( selector ) {
																				return function( elem ) {
																								return Sizzle( selector, elem ).length > 0;
																				};
																} ),

																"contains": markFunction( function( text ) {
																				return function( elem ) {
																								return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
																				};
																} ),

																// "Whether an element is represented by a :lang() selector
																// is based solely on the element's language value
																// being equal to the identifier C,
																// or beginning with the identifier C immediately followed by "-".
																// The matching of C against the element's language value is performed case-insensitively.
																// The identifier C does not have to be a valid language name."
																// http://www.w3.org/TR/selectors/#lang-pseudo
																"lang": markFunction( function( lang ) {
																				// lang value must be a valid identifier
																				if ( !ridentifier.test( lang || "" ) ) {
																								Sizzle.error( "unsupported lang: " + lang );
																				}
																				lang = lang.replace( runescape, funescape ).toLowerCase();
																				return function( elem ) {
																								var elemLang;
																								do {
																												if ( ( elemLang = documentIsHTML ?
																																elem.lang :
																																elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

																																elemLang = elemLang.toLowerCase();
																																return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
																												}
																								} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
																								return false;
																				};
																} ),

																// Miscellaneous
																"target": function( elem ) {
																				var hash = window.location && window.location.hash;
																				return hash && hash.slice( 1 ) === elem.id;
																},

																"root": function( elem ) {
																				return elem === docElem;
																},

																"focus": function( elem ) {
																				return elem === document.activeElement && ( !document.hasFocus || document.hasFocus() ) && !! ( elem.type || elem.href || ~elem.tabIndex );
																},

																// Boolean properties
																"enabled": function( elem ) {
																				return elem.disabled === false;
																},

																"disabled": function( elem ) {
																				return elem.disabled === true;
																},

																"checked": function( elem ) {
																				// In CSS3, :checked should return both checked and selected elements
																				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
																				var nodeName = elem.nodeName.toLowerCase();
																				return ( nodeName === "input" && !! elem.checked ) || ( nodeName === "option" && !! elem.selected );
																},

																"selected": function( elem ) {
																				// Accessing this property makes selected-by-default
																				// options in Safari work properly
																				if ( elem.parentNode ) {
																								elem.parentNode.selectedIndex;
																				}

																				return elem.selected === true;
																},

																// Contents
																"empty": function( elem ) {
																				// http://www.w3.org/TR/selectors/#empty-pseudo
																				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
																				//   but not by others (comment: 8; processing instruction: 7; etc.)
																				// nodeType < 6 works because attributes (2) do not appear as children
																				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
																								if ( elem.nodeType < 6 ) {
																												return false;
																								}
																				}
																				return true;
																},

																"parent": function( elem ) {
																				return !Expr.pseudos[ "empty" ]( elem );
																},

																// Element/input types
																"header": function( elem ) {
																				return rheader.test( elem.nodeName );
																},

																"input": function( elem ) {
																				return rinputs.test( elem.nodeName );
																},

																"button": function( elem ) {
																				var name = elem.nodeName.toLowerCase();
																				return name === "input" && elem.type === "button" || name === "button";
																},

																"text": function( elem ) {
																				var attr;
																				return elem.nodeName.toLowerCase() === "input" &&
																								elem.type === "text" &&

																				// Support: IE<8
																				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
																				( ( attr = elem.getAttribute( "type" ) ) == null || attr.toLowerCase() === "text" );
																},

																// Position-in-collection
																"first": createPositionalPseudo( function() {
																				return [ 0 ];
																} ),

																"last": createPositionalPseudo( function( matchIndexes, length ) {
																				return [ length - 1 ];
																} ),

																"eq": createPositionalPseudo( function( matchIndexes, length, argument ) {
																				return [ argument < 0 ? argument + length : argument ];
																} ),

																"even": createPositionalPseudo( function( matchIndexes, length ) {
																				var i = 0;
																				for ( ; i < length; i += 2 ) {
																								matchIndexes.push( i );
																				}
																				return matchIndexes;
																} ),

																"odd": createPositionalPseudo( function( matchIndexes, length ) {
																				var i = 1;
																				for ( ; i < length; i += 2 ) {
																								matchIndexes.push( i );
																				}
																				return matchIndexes;
																} ),

																"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
																				var i = argument < 0 ? argument + length : argument;
																				for ( ; --i >= 0; ) {
																								matchIndexes.push( i );
																				}
																				return matchIndexes;
																} ),

																"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
																				var i = argument < 0 ? argument + length : argument;
																				for ( ; ++i < length; ) {
																								matchIndexes.push( i );
																				}
																				return matchIndexes;
																} )
												}
								};

								Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

								// Add button/input type pseudos
								for ( i in {
												radio: true,
												checkbox: true,
												file: true,
												password: true,
												image: true
								} ) {
												Expr.pseudos[ i ] = createInputPseudo( i );
								}
								for ( i in {
												submit: true,
												reset: true
								} ) {
												Expr.pseudos[ i ] = createButtonPseudo( i );
								}

								// Easy API for creating new setFilters
								function setFilters() {}
								setFilters.prototype = Expr.filters = Expr.pseudos;
								Expr.setFilters = new setFilters();

								function tokenize( selector, parseOnly ) {
												var matched, match, tokens, type,
																soFar, groups, preFilters,
																cached = tokenCache[ selector + " " ];

												if ( cached ) {
																return parseOnly ? 0 : cached.slice( 0 );
												}

												soFar = selector;
												groups = [];
												preFilters = Expr.preFilter;

												while ( soFar ) {

																// Comma and first run
																if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
																				if ( match ) {
																								// Don't consume trailing commas as valid
																								soFar = soFar.slice( match[ 0 ].length ) || soFar;
																				}
																				groups.push( ( tokens = [] ) );
																}

																matched = false;

																// Combinators
																if ( ( match = rcombinators.exec( soFar ) ) ) {
																				matched = match.shift();
																				tokens.push( {
																								value: matched,
																								// Cast descendant combinators to space
																								type: match[ 0 ].replace( rtrim, " " )
																				} );
																				soFar = soFar.slice( matched.length );
																}

																// Filters
																for ( type in Expr.filter ) {
																				if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
																								( match = preFilters[ type ]( match ) ) ) ) {
																								matched = match.shift();
																								tokens.push( {
																												value: matched,
																												type: type,
																												matches: match
																								} );
																								soFar = soFar.slice( matched.length );
																				}
																}

																if ( !matched ) {
																				break;
																}
												}

												// Return the length of the invalid excess
												// if we're just parsing
												// Otherwise, throw an error or return tokens
												return parseOnly ?
																soFar.length :
																soFar ?
																Sizzle.error( selector ) :
												// Cache the tokens
												tokenCache( selector, groups ).slice( 0 );
								}

								function toSelector( tokens ) {
												var i = 0,
																len = tokens.length,
																selector = "";
												for ( ; i < len; i++ ) {
																selector += tokens[ i ].value;
												}
												return selector;
								}

								function addCombinator( matcher, combinator, base ) {
												var dir = combinator.dir,
																checkNonElements = base && dir === "parentNode",
																doneName = done++;

												return combinator.first ?
												// Check against closest ancestor/preceding element
												function( elem, context, xml ) {
																while ( ( elem = elem[ dir ] ) ) {
																				if ( elem.nodeType === 1 || checkNonElements ) {
																								return matcher( elem, context, xml );
																				}
																}
												} :

												// Check against all ancestor/preceding elements
												function( elem, context, xml ) {
																var oldCache, outerCache,
																				newCache = [ dirruns, doneName ];

																// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
																if ( xml ) {
																				while ( ( elem = elem[ dir ] ) ) {
																								if ( elem.nodeType === 1 || checkNonElements ) {
																												if ( matcher( elem, context, xml ) ) {
																																return true;
																												}
																								}
																				}
																} else {
																				while ( ( elem = elem[ dir ] ) ) {
																								if ( elem.nodeType === 1 || checkNonElements ) {
																												outerCache = elem[ expando ] || ( elem[ expando ] = {} );
																												if ( ( oldCache = outerCache[ dir ] ) &&
																																oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

																																// Assign to newCache so results back-propagate to previous elements
																																return ( newCache[ 2 ] = oldCache[ 2 ] );
																												} else {
																																// Reuse newcache so results back-propagate to previous elements
																																outerCache[ dir ] = newCache;

																																// A match means we're done; a fail means we have to keep checking
																																if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
																																				return true;
																																}
																												}
																								}
																				}
																}
												};
								}

								function elementMatcher( matchers ) {
												return matchers.length > 1 ?
																function( elem, context, xml ) {
																				var i = matchers.length;
																				while ( i-- ) {
																								if ( !matchers[ i ]( elem, context, xml ) ) {
																												return false;
																								}
																				}
																				return true;
												} :
																matchers[ 0 ];
								}

								function condense( unmatched, map, filter, context, xml ) {
												var elem,
																newUnmatched = [],
																i = 0,
																len = unmatched.length,
																mapped = map != null;

												for ( ; i < len; i++ ) {
																if ( ( elem = unmatched[ i ] ) ) {
																				if ( !filter || filter( elem, context, xml ) ) {
																								newUnmatched.push( elem );
																								if ( mapped ) {
																												map.push( i );
																								}
																				}
																}
												}

												return newUnmatched;
								}

								function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
												if ( postFilter && !postFilter[ expando ] ) {
																postFilter = setMatcher( postFilter );
												}
												if ( postFinder && !postFinder[ expando ] ) {
																postFinder = setMatcher( postFinder, postSelector );
												}
												return markFunction( function( seed, results, context, xml ) {
																var temp, i, elem,
																				preMap = [],
																				postMap = [],
																				preexisting = results.length,

																				// Get initial elements from seed or context
																				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

																				// Prefilter to get matcher input, preserving a map for seed-results synchronization
																				matcherIn = preFilter && ( seed || !selector ) ?
																								condense( elems, preMap, preFilter, context, xml ) :
																								elems,

																				matcherOut = matcher ?
																				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
																				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

																				// ...intermediate processing is necessary
																				[] :

																				// ...otherwise use results directly
																				results :
																								matcherIn;

																// Find primary matches
																if ( matcher ) {
																				matcher( matcherIn, matcherOut, context, xml );
																}

																// Apply postFilter
																if ( postFilter ) {
																				temp = condense( matcherOut, postMap );
																				postFilter( temp, [], context, xml );

																				// Un-match failing elements by moving them back to matcherIn
																				i = temp.length;
																				while ( i-- ) {
																								if ( ( elem = temp[ i ] ) ) {
																												matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
																								}
																				}
																}

																if ( seed ) {
																				if ( postFinder || preFilter ) {
																								if ( postFinder ) {
																												// Get the final matcherOut by condensing this intermediate into postFinder contexts
																												temp = [];
																												i = matcherOut.length;
																												while ( i-- ) {
																																if ( ( elem = matcherOut[ i ] ) ) {
																																				// Restore matcherIn since elem is not yet a final match
																																				temp.push( ( matcherIn[ i ] = elem ) );
																																}
																												}
																												postFinder( null, ( matcherOut = [] ), temp, xml );
																								}

																								// Move matched elements from seed to results to keep them synchronized
																								i = matcherOut.length;
																								while ( i-- ) {
																												if ( ( elem = matcherOut[ i ] ) &&
																																( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

																																seed[ temp ] = !( results[ temp ] = elem );
																												}
																								}
																				}

																				// Add elements to results, through postFinder if defined
																} else {
																				matcherOut = condense(
																								matcherOut === results ?
																								matcherOut.splice( preexisting, matcherOut.length ) :
																								matcherOut
																				);
																				if ( postFinder ) {
																								postFinder( null, results, matcherOut, xml );
																				} else {
																								push.apply( results, matcherOut );
																				}
																}
												} );
								}

								function matcherFromTokens( tokens ) {
												var checkContext, matcher, j,
																len = tokens.length,
																leadingRelative = Expr.relative[ tokens[ 0 ].type ],
																implicitRelative = leadingRelative || Expr.relative[ " " ],
																i = leadingRelative ? 1 : 0,

																// The foundational matcher ensures that elements are reachable from top-level context(s)
																matchContext = addCombinator( function( elem ) {
																				return elem === checkContext;
																}, implicitRelative, true ),
																matchAnyContext = addCombinator( function( elem ) {
																				return indexOf.call( checkContext, elem ) > -1;
																}, implicitRelative, true ),
																matchers = [
																				function( elem, context, xml ) {
																								return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
																												( checkContext = context ).nodeType ?
																												matchContext( elem, context, xml ) :
																												matchAnyContext( elem, context, xml ) );
																				}
																];

												for ( ; i < len; i++ ) {
																if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
																				matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
																} else {
																				matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

																				// Return special upon seeing a positional matcher
																				if ( matcher[ expando ] ) {
																								// Find the next relative operator (if any) for proper handling
																								j = ++i;
																								for ( ; j < len; j++ ) {
																												if ( Expr.relative[ tokens[ j ].type ] ) {
																																break;
																												}
																								}
																								return setMatcher(
																												i > 1 && elementMatcher( matchers ),
																												i > 1 && toSelector(
																																// If the preceding token was a descendant combinator, insert an implicit any-element `*`
																																tokens.slice( 0, i - 1 ).concat( {
																																				value: tokens[ i - 2 ].type === " " ? "*" : ""
																																} )
																												).replace( rtrim, "$1" ),
																												matcher,
																												i < j && matcherFromTokens( tokens.slice( i, j ) ),
																												j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
																												j < len && toSelector( tokens )
																								);
																				}
																				matchers.push( matcher );
																}
												}

												return elementMatcher( matchers );
								}

								function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
												var bySet = setMatchers.length > 0,
																byElement = elementMatchers.length > 0,
																superMatcher = function( seed, context, xml, results, outermost ) {
																				var elem, j, matcher,
																								matchedCount = 0,
																								i = "0",
																								unmatched = seed && [],
																								setMatched = [],
																								contextBackup = outermostContext,
																								// We must always have either seed elements or outermost context
																								elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),
																								// Use integer dirruns iff this is the outermost matcher
																								dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
																								len = elems.length;

																				if ( outermost ) {
																								outermostContext = context !== document && context;
																				}

																				// Add elements passing elementMatchers directly to results
																				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
																				// Support: IE<9, Safari
																				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
																				for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
																								if ( byElement && elem ) {
																												j = 0;
																												while ( ( matcher = elementMatchers[ j++ ] ) ) {
																																if ( matcher( elem, context, xml ) ) {
																																				results.push( elem );
																																				break;
																																}
																												}
																												if ( outermost ) {
																																dirruns = dirrunsUnique;
																												}
																								}

																								// Track unmatched elements for set filters
																								if ( bySet ) {
																												// They will have gone through all possible matchers
																												if ( ( elem = !matcher && elem ) ) {
																																matchedCount--;
																												}

																												// Lengthen the array for every element, matched or not
																												if ( seed ) {
																																unmatched.push( elem );
																												}
																								}
																				}

																				// Apply set filters to unmatched elements
																				matchedCount += i;
																				if ( bySet && i !== matchedCount ) {
																								j = 0;
																								while ( ( matcher = setMatchers[ j++ ] ) ) {
																												matcher( unmatched, setMatched, context, xml );
																								}

																								if ( seed ) {
																												// Reintegrate element matches to eliminate the need for sorting
																												if ( matchedCount > 0 ) {
																																while ( i-- ) {
																																				if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
																																								setMatched[ i ] = pop.call( results );
																																				}
																																}
																												}

																												// Discard index placeholder values to get only actual matches
																												setMatched = condense( setMatched );
																								}

																								// Add matches to results
																								push.apply( results, setMatched );

																								// Seedless set matches succeeding multiple successful matchers stipulate sorting
																								if ( outermost && !seed && setMatched.length > 0 &&
																												( matchedCount + setMatchers.length ) > 1 ) {

																												Sizzle.uniqueSort( results );
																								}
																				}

																				// Override manipulation of globals by nested matchers
																				if ( outermost ) {
																								dirruns = dirrunsUnique;
																								outermostContext = contextBackup;
																				}

																				return unmatched;
																};

												return bySet ?
																markFunction( superMatcher ) :
																superMatcher;
								}

								compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
												var i,
																setMatchers = [],
																elementMatchers = [],
																cached = compilerCache[ selector + " " ];

												if ( !cached ) {
																// Generate a function of recursive functions that can be used to check each element
																if ( !group ) {
																				group = tokenize( selector );
																}
																i = group.length;
																while ( i-- ) {
																				cached = matcherFromTokens( group[ i ] );
																				if ( cached[ expando ] ) {
																								setMatchers.push( cached );
																				} else {
																								elementMatchers.push( cached );
																				}
																}

																// Cache the compiled function
																cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
												}
												return cached;
								};

								function multipleContexts( selector, contexts, results ) {
												var i = 0,
																len = contexts.length;
												for ( ; i < len; i++ ) {
																Sizzle( selector, contexts[ i ], results );
												}
												return results;
								}

								function select( selector, context, results, seed ) {
												var i, tokens, token, type, find,
																match = tokenize( selector );

												if ( !seed ) {
																// Try to minimize operations if there is only one group
																if ( match.length === 1 ) {

																				// Take a shortcut and set the context if the root selector is an ID
																				tokens = match[ 0 ] = match[ 0 ].slice( 0 );
																				if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
																								support.getById && context.nodeType === 9 && documentIsHTML &&
																								Expr.relative[ tokens[ 1 ].type ] ) {

																								context = ( Expr.find[ "ID" ]( token.matches[ 0 ].replace( runescape, funescape ), context ) || [] )[ 0 ];
																								if ( !context ) {
																												return results;
																								}
																								selector = selector.slice( tokens.shift().value.length );
																				}

																				// Fetch a seed set for right-to-left matching
																				i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
																				while ( i-- ) {
																								token = tokens[ i ];

																								// Abort if we hit a combinator
																								if ( Expr.relative[ ( type = token.type ) ] ) {
																												break;
																								}
																								if ( ( find = Expr.find[ type ] ) ) {
																												// Search, expanding context for leading sibling combinators
																												if ( ( seed = find(
																																token.matches[ 0 ].replace( runescape, funescape ),
																																rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) || context
																												) ) ) {

																																// If seed is empty or no tokens remain, we can return early
																																tokens.splice( i, 1 );
																																selector = seed.length && toSelector( tokens );
																																if ( !selector ) {
																																				push.apply( results, seed );
																																				return results;
																																}

																																break;
																												}
																								}
																				}
																}
												}

												// Compile and execute a filtering function
												// Provide `match` to avoid retokenization if we modified the selector above
												compile( selector, match )(
																seed,
																context, !documentIsHTML,
																results,
																rsibling.test( selector ) && testContext( context.parentNode ) || context
												);
												return results;
								}

								// One-time assignments

								// Sort stability
								support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

								// Support: Chrome<14
								// Always assume duplicates if they aren't passed to the comparison function
								support.detectDuplicates = !! hasDuplicate;

								// Initialize against the default document
								setDocument();

								// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
								// Detached nodes confoundingly follow *each other*
								support.sortDetached = assert( function( div1 ) {
												// Should return 1, but returns 4 (following)
												return div1.compareDocumentPosition( document.createElement( "div" ) ) & 1;
								} );

								// Support: IE<8
								// Prevent attribute/property "interpolation"
								// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
								if ( !assert( function( div ) {
												div.innerHTML = "<a href='#'></a>";
												return div.firstChild.getAttribute( "href" ) === "#";
								} ) ) {
												addHandle( "type|href|height|width", function( elem, name, isXML ) {
																if ( !isXML ) {
																				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
																}
												} );
								}

								// Support: IE<9
								// Use defaultValue in place of getAttribute("value")
								if ( !support.attributes || !assert( function( div ) {
												div.innerHTML = "<input/>";
												div.firstChild.setAttribute( "value", "" );
												return div.firstChild.getAttribute( "value" ) === "";
								} ) ) {
												addHandle( "value", function( elem, name, isXML ) {
																if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
																				return elem.defaultValue;
																}
												} );
								}

								// Support: IE<9
								// Use getAttributeNode to fetch booleans when getAttribute lies
								if ( !assert( function( div ) {
												return div.getAttribute( "disabled" ) == null;
								} ) ) {
												addHandle( booleans, function( elem, name, isXML ) {
																var val;
																if ( !isXML ) {
																				return elem[ name ] === true ? name.toLowerCase() :
																								( val = elem.getAttributeNode( name ) ) && val.specified ?
																								val.value :
																								null;
																}
												} );
								}

								return Sizzle;

				} )( window );



				jQuery.find = Sizzle;
				jQuery.expr = Sizzle.selectors;
				jQuery.expr[ ":" ] = jQuery.expr.pseudos;
				jQuery.unique = Sizzle.uniqueSort;
				jQuery.text = Sizzle.getText;
				jQuery.isXMLDoc = Sizzle.isXML;
				jQuery.contains = Sizzle.contains;



				var rneedsContext = jQuery.expr.match.needsContext;

				var rsingleTag = ( /^<(\w+)\s*\/?>(?:<\/\1>|)$/ );



				var risSimple = /^.[^:#\[\.,]*$/;

				// Implement the identical functionality for filter and not
				function winnow( elements, qualifier, not ) {
								if ( jQuery.isFunction( qualifier ) ) {
												return jQuery.grep( elements, function( elem, i ) {
																/* jshint -W018 */
																return !!qualifier.call( elem, i, elem ) !== not;
												} );

								}

								if ( qualifier.nodeType ) {
												return jQuery.grep( elements, function( elem ) {
																return ( elem === qualifier ) !== not;
												} );

								}

								if ( typeof qualifier === "string" ) {
												if ( risSimple.test( qualifier ) ) {
																return jQuery.filter( qualifier, elements, not );
												}

												qualifier = jQuery.filter( qualifier, elements );
								}

								return jQuery.grep( elements, function( elem ) {
												return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
								} );
				}

				jQuery.filter = function( expr, elems, not ) {
								var elem = elems[ 0 ];

								if ( not ) {
												expr = ":not(" + expr + ")";
								}

								return elems.length === 1 && elem.nodeType === 1 ?
												jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
												jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
																return elem.nodeType === 1;
												} ) );
				};

				jQuery.fn.extend( {
								find: function( selector ) {
												var i,
																len = this.length,
																ret = [],
																self = this;

												if ( typeof selector !== "string" ) {
																return this.pushStack( jQuery( selector ).filter( function() {
																				for ( i = 0; i < len; i++ ) {
																								if ( jQuery.contains( self[ i ], this ) ) {
																												return true;
																								}
																				}
																} ) );
												}

												for ( i = 0; i < len; i++ ) {
																jQuery.find( selector, self[ i ], ret );
												}

												// Needed because $( selector, context ) becomes $( context ).find( selector )
												ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
												ret.selector = this.selector ? this.selector + " " + selector : selector;
												return ret;
								},
								filter: function( selector ) {
												return this.pushStack( winnow( this, selector || [], false ) );
								},
								not: function( selector ) {
												return this.pushStack( winnow( this, selector || [], true ) );
								},
								is: function( selector ) {
												return !!winnow(
																this,

																// If this is a positional/relative selector, check membership in the returned set
																// so $("p:first").is("p:last") won't return true for a doc with two "p".
																typeof selector === "string" && rneedsContext.test( selector ) ?
																jQuery( selector ) :
																selector || [],
																false
												).length;
								}
				} );


				// Initialize a jQuery object


				// A central reference to the root jQuery(document)
				var rootjQuery,

								// A simple way to check for HTML strings
								// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
								// Strict HTML recognition (#11290: must start with <)
								rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

								init = jQuery.fn.init = function( selector, context ) {
												var match, elem;

												// HANDLE: $(""), $(null), $(undefined), $(false)
												if ( !selector ) {
																return this;
												}

												// Handle HTML strings
												if ( typeof selector === "string" ) {
																if ( selector[ 0 ] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
																				// Assume that strings that start and end with <> are HTML and skip the regex check
																				match = [ null, selector, null ];

																} else {
																				match = rquickExpr.exec( selector );
																}

																// Match html or make sure no context is specified for #id
																if ( match && ( match[ 1 ] || !context ) ) {

																				// HANDLE: $(html) -> $(array)
																				if ( match[ 1 ] ) {
																								context = context instanceof jQuery ? context[ 0 ] : context;

																								// scripts is true for back-compat
																								// Intentionally let the error be thrown if parseHTML is not present
																								jQuery.merge( this, jQuery.parseHTML(
																												match[ 1 ],
																												context && context.nodeType ? context.ownerDocument || context : document,
																												true
																								) );

																								// HANDLE: $(html, props)
																								if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
																												for ( match in context ) {
																																// Properties of context are called as methods if possible
																																if ( jQuery.isFunction( this[ match ] ) ) {
																																				this[ match ]( context[ match ] );

																																				// ...and otherwise set as attributes
																																} else {
																																				this.attr( match, context[ match ] );
																																}
																												}
																								}

																								return this;

																								// HANDLE: $(#id)
																				} else {
																								elem = document.getElementById( match[ 2 ] );

																								// Check parentNode to catch when Blackberry 4.6 returns
																								// nodes that are no longer in the document #6963
																								if ( elem && elem.parentNode ) {
																												// Inject the element directly into the jQuery object
																												this.length = 1;
																												this[ 0 ] = elem;
																								}

																								this.context = document;
																								this.selector = selector;
																								return this;
																				}

																				// HANDLE: $(expr, $(...))
																} else if ( !context || context.jquery ) {
																				return ( context || rootjQuery ).find( selector );

																				// HANDLE: $(expr, context)
																				// (which is just equivalent to: $(context).find(expr)
																} else {
																				return this.constructor( context ).find( selector );
																}

																// HANDLE: $(DOMElement)
												} else if ( selector.nodeType ) {
																this.context = this[ 0 ] = selector;
																this.length = 1;
																return this;

																// HANDLE: $(function)
																// Shortcut for document ready
												} else if ( jQuery.isFunction( selector ) ) {
																return typeof rootjQuery.ready !== "undefined" ?
																				rootjQuery.ready( selector ) :
																// Execute immediately if ready is not present
																selector( jQuery );
												}

												if ( selector.selector !== undefined ) {
																this.selector = selector.selector;
																this.context = selector.context;
												}

												return jQuery.makeArray( selector, this );
								};

				// Give the init function the jQuery prototype for later instantiation
				init.prototype = jQuery.fn;

				// Initialize central reference
				rootjQuery = jQuery( document );


				var rparentsprev = /^(?:parents|prev(?:Until|All))/,
								// methods guaranteed to produce a unique set when starting from a unique set
								guaranteedUnique = {
												children: true,
												contents: true,
												next: true,
												prev: true
								};

				jQuery.extend( {
								dir: function( elem, dir, until ) {
												var matched = [],
																truncate = until !== undefined;

												while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
																if ( elem.nodeType === 1 ) {
																				if ( truncate && jQuery( elem ).is( until ) ) {
																								break;
																				}
																				matched.push( elem );
																}
												}
												return matched;
								},

								sibling: function( n, elem ) {
												var matched = [];

												for ( ; n; n = n.nextSibling ) {
																if ( n.nodeType === 1 && n !== elem ) {
																				matched.push( n );
																}
												}

												return matched;
								}
				} );

				jQuery.fn.extend( {
								has: function( target ) {
												var targets = jQuery( target, this ),
																l = targets.length;

												return this.filter( function() {
																var i = 0;
																for ( ; i < l; i++ ) {
																				if ( jQuery.contains( this, targets[ i ] ) ) {
																								return true;
																				}
																}
												} );
								},

								closest: function( selectors, context ) {
												var cur,
																i = 0,
																l = this.length,
																matched = [],
																pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
																				jQuery( selectors, context || this.context ) :
																				0;

												for ( ; i < l; i++ ) {
																for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
																				// Always skip document fragments
																				if ( cur.nodeType < 11 && ( pos ?
																								pos.index( cur ) > -1 :

																								// Don't pass non-elements to Sizzle
																								cur.nodeType === 1 &&
																								jQuery.find.matchesSelector( cur, selectors ) ) ) {

																								matched.push( cur );
																								break;
																				}
																}
												}

												return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
								},

								// Determine the position of an element within
								// the matched set of elements
								index: function( elem ) {

												// No argument, return index in parent
												if ( !elem ) {
																return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
												}

												// index in selector
												if ( typeof elem === "string" ) {
																return indexOf.call( jQuery( elem ), this[ 0 ] );
												}

												// Locate the position of the desired element
												return indexOf.call( this,

																// If it receives a jQuery object, the first element is used
																elem.jquery ? elem[ 0 ] : elem
												);
								},

								add: function( selector, context ) {
												return this.pushStack(
																jQuery.unique(
																				jQuery.merge( this.get(), jQuery( selector, context ) )
																)
												);
								},

								addBack: function( selector ) {
												return this.add( selector == null ?
																this.prevObject : this.prevObject.filter( selector )
												);
								}
				} );

				function sibling( cur, dir ) {
								while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
								return cur;
				}

				jQuery.each( {
								parent: function( elem ) {
												var parent = elem.parentNode;
												return parent && parent.nodeType !== 11 ? parent : null;
								},
								parents: function( elem ) {
												return jQuery.dir( elem, "parentNode" );
								},
								parentsUntil: function( elem, i, until ) {
												return jQuery.dir( elem, "parentNode", until );
								},
								next: function( elem ) {
												return sibling( elem, "nextSibling" );
								},
								prev: function( elem ) {
												return sibling( elem, "previousSibling" );
								},
								nextAll: function( elem ) {
												return jQuery.dir( elem, "nextSibling" );
								},
								prevAll: function( elem ) {
												return jQuery.dir( elem, "previousSibling" );
								},
								nextUntil: function( elem, i, until ) {
												return jQuery.dir( elem, "nextSibling", until );
								},
								prevUntil: function( elem, i, until ) {
												return jQuery.dir( elem, "previousSibling", until );
								},
								siblings: function( elem ) {
												return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
								},
								children: function( elem ) {
												return jQuery.sibling( elem.firstChild );
								},
								contents: function( elem ) {
												return elem.contentDocument || jQuery.merge( [], elem.childNodes );
								}
				}, function( name, fn ) {
								jQuery.fn[ name ] = function( until, selector ) {
												var matched = jQuery.map( this, fn, until );

												if ( name.slice( -5 ) !== "Until" ) {
																selector = until;
												}

												if ( selector && typeof selector === "string" ) {
																matched = jQuery.filter( selector, matched );
												}

												if ( this.length > 1 ) {
																// Remove duplicates
																if ( !guaranteedUnique[ name ] ) {
																				jQuery.unique( matched );
																}

																// Reverse order for parents* and prev-derivatives
																if ( rparentsprev.test( name ) ) {
																				matched.reverse();
																}
												}

												return this.pushStack( matched );
								};
				} );
				var rnotwhite = ( /\S+/g );



				// String to Object options format cache
				var optionsCache = {};

				// Convert String-formatted options into Object-formatted ones and store in cache
				function createOptions( options ) {
								var object = optionsCache[ options ] = {};
								jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
												object[ flag ] = true;
								} );
								return object;
				}

				/*
				 * Create a callback list using the following parameters:
				 *
				 *	options: an optional list of space-separated options that will change how
				 *			the callback list behaves or a more traditional option object
				 *
				 * By default a callback list will act like an event callback list and can be
				 * "fired" multiple times.
				 *
				 * Possible options:
				 *
				 *	once:			will ensure the callback list can only be fired once (like a Deferred)
				 *
				 *	memory:			will keep track of previous values and will call any callback added
				 *					after the list has been fired right away with the latest "memorized"
				 *					values (like a Deferred)
				 *
				 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
				 *
				 *	stopOnFalse:	interrupt callings when a callback returns false
				 *
				 */
				jQuery.Callbacks = function( options ) {

								// Convert options from String-formatted to Object-formatted if needed
								// (we check in cache first)
								options = typeof options === "string" ?
												( optionsCache[ options ] || createOptions( options ) ) :
												jQuery.extend( {}, options );

								var // Last fire value (for non-forgettable lists)
								memory,
												// Flag to know if list was already fired
												fired,
												// Flag to know if list is currently firing
												firing,
												// First callback to fire (used internally by add and fireWith)
												firingStart,
												// End of the loop when firing
												firingLength,
												// Index of currently firing callback (modified by remove if needed)
												firingIndex,
												// Actual callback list
												list = [],
												// Stack of fire calls for repeatable lists
												stack = !options.once && [],
												// Fire callbacks
												fire = function( data ) {
																memory = options.memory && data;
																fired = true;
																firingIndex = firingStart || 0;
																firingStart = 0;
																firingLength = list.length;
																firing = true;
																for ( ; list && firingIndex < firingLength; firingIndex++ ) {
																				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
																								memory = false; // To prevent further calls using add
																								break;
																				}
																}
																firing = false;
																if ( list ) {
																				if ( stack ) {
																								if ( stack.length ) {
																												fire( stack.shift() );
																								}
																				} else if ( memory ) {
																								list = [];
																				} else {
																								self.disable();
																				}
																}
												},
												// Actual Callbacks object
												self = {
																// Add a callback or a collection of callbacks to the list
																add: function() {
																				if ( list ) {
																								// First, we save the current length
																								var start = list.length;
																								( function add( args ) {
																												jQuery.each( args, function( _, arg ) {
																																var type = jQuery.type( arg );
																																if ( type === "function" ) {
																																				if ( !options.unique || !self.has( arg ) ) {
																																								list.push( arg );
																																				}
																																} else if ( arg && arg.length && type !== "string" ) {
																																				// Inspect recursively
																																				add( arg );
																																}
																												} );
																								} )( arguments );
																								// Do we need to add the callbacks to the
																								// current firing batch?
																								if ( firing ) {
																												firingLength = list.length;
																												// With memory, if we're not firing then
																												// we should call right away
																								} else if ( memory ) {
																												firingStart = start;
																												fire( memory );
																								}
																				}
																				return this;
																},
																// Remove a callback from the list
																remove: function() {
																				if ( list ) {
																								jQuery.each( arguments, function( _, arg ) {
																												var index;
																												while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
																																list.splice( index, 1 );
																																// Handle firing indexes
																																if ( firing ) {
																																				if ( index <= firingLength ) {
																																								firingLength--;
																																				}
																																				if ( index <= firingIndex ) {
																																								firingIndex--;
																																				}
																																}
																												}
																								} );
																				}
																				return this;
																},
																// Check if a given callback is in the list.
																// If no argument is given, return whether or not list has callbacks attached.
																has: function( fn ) {
																				return fn ? jQuery.inArray( fn, list ) > -1 : !! ( list && list.length );
																},
																// Remove all callbacks from the list
																empty: function() {
																				list = [];
																				firingLength = 0;
																				return this;
																},
																// Have the list do nothing anymore
																disable: function() {
																				list = stack = memory = undefined;
																				return this;
																},
																// Is it disabled?
																disabled: function() {
																				return !list;
																},
																// Lock the list in its current state
																lock: function() {
																				stack = undefined;
																				if ( !memory ) {
																								self.disable();
																				}
																				return this;
																},
																// Is it locked?
																locked: function() {
																				return !stack;
																},
																// Call all callbacks with the given context and arguments
																fireWith: function( context, args ) {
																				if ( list && ( !fired || stack ) ) {
																								args = args || [];
																								args = [ context, args.slice ? args.slice() : args ];
																								if ( firing ) {
																												stack.push( args );
																								} else {
																												fire( args );
																								}
																				}
																				return this;
																},
																// Call all the callbacks with the given arguments
																fire: function() {
																				self.fireWith( this, arguments );
																				return this;
																},
																// To know if the callbacks have already been called at least once
																fired: function() {
																				return !!fired;
																}
												};

								return self;
				};


				jQuery.extend( {

								Deferred: function( func ) {
												var tuples = [
																// action, add listener, listener list, final state
																[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
																[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
																[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
												],
																state = "pending",
																promise = {
																				state: function() {
																								return state;
																				},
																				always: function() {
																								deferred.done( arguments ).fail( arguments );
																								return this;
																				},
																				then: function( /* fnDone, fnFail, fnProgress */) {
																								var fns = arguments;
																								return jQuery.Deferred( function( newDefer ) {
																												jQuery.each( tuples, function( i, tuple ) {
																																var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
																																// deferred[ done | fail | progress ] for forwarding actions to newDefer
																																deferred[ tuple[ 1 ] ]( function() {
																																				var returned = fn && fn.apply( this, arguments );
																																				if ( returned && jQuery.isFunction( returned.promise ) ) {
																																								returned.promise()
																																												.done( newDefer.resolve )
																																												.fail( newDefer.reject )
																																												.progress( newDefer.notify );
																																				} else {
																																								newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
																																				}
																																} );
																												} );
																												fns = null;
																								} ).promise();
																				},
																				// Get a promise for this deferred
																				// If obj is provided, the promise aspect is added to the object
																				promise: function( obj ) {
																								return obj != null ? jQuery.extend( obj, promise ) : promise;
																				}
																},
																deferred = {};

												// Keep pipe for back-compat
												promise.pipe = promise.then;

												// Add list-specific methods
												jQuery.each( tuples, function( i, tuple ) {
																var list = tuple[ 2 ],
																				stateString = tuple[ 3 ];

																// promise[ done | fail | progress ] = list.add
																promise[ tuple[ 1 ] ] = list.add;

																// Handle state
																if ( stateString ) {
																				list.add( function() {
																								// state = [ resolved | rejected ]
																								state = stateString;

																								// [ reject_list | resolve_list ].disable; progress_list.lock
																				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
																}

																// deferred[ resolve | reject | notify ]
																deferred[ tuple[ 0 ] ] = function() {
																				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
																				return this;
																};
																deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
												} );

												// Make the deferred a promise
												promise.promise( deferred );

												// Call given func if any
												if ( func ) {
																func.call( deferred, deferred );
												}

												// All done!
												return deferred;
								},

								// Deferred helper
								when: function( subordinate /* , ..., subordinateN */ ) {
												var i = 0,
																resolveValues = slice.call( arguments ),
																length = resolveValues.length,

																// the count of uncompleted subordinates
																remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

																// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
																deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

																// Update function for both resolve and progress values
																updateFunc = function( i, contexts, values ) {
																				return function( value ) {
																								contexts[ i ] = this;
																								values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
																								if ( values === progressValues ) {
																												deferred.notifyWith( contexts, values );
																								} else if ( !( --remaining ) ) {
																												deferred.resolveWith( contexts, values );
																								}
																				};
																},

																progressValues, progressContexts, resolveContexts;

												// add listeners to Deferred subordinates; treat others as resolved
												if ( length > 1 ) {
																progressValues = new Array( length );
																progressContexts = new Array( length );
																resolveContexts = new Array( length );
																for ( ; i < length; i++ ) {
																				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
																								resolveValues[ i ].promise()
																												.done( updateFunc( i, resolveContexts, resolveValues ) )
																												.fail( deferred.reject )
																												.progress( updateFunc( i, progressContexts, progressValues ) );
																				} else {
																								--remaining;
																				}
																}
												}

												// if we're not waiting on anything, resolve the master
												if ( !remaining ) {
																deferred.resolveWith( resolveContexts, resolveValues );
												}

												return deferred.promise();
								}
				} );


				// The deferred used on DOM ready
				var readyList;

				jQuery.fn.ready = function( fn ) {
								// Add the callback
								jQuery.ready.promise().done( fn );

								return this;
				};

				jQuery.extend( {
								// Is the DOM ready to be used? Set to true once it occurs.
								isReady: false,

								// A counter to track how many items to wait for before
								// the ready event fires. See #6781
								readyWait: 1,

								// Hold (or release) the ready event
								holdReady: function( hold ) {
												if ( hold ) {
																jQuery.readyWait++;
												} else {
																jQuery.ready( true );
												}
								},

								// Handle when the DOM is ready
								ready: function( wait ) {

												// Abort if there are pending holds or we're already ready
												if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
																return;
												}

												// Remember that the DOM is ready
												jQuery.isReady = true;

												// If a normal DOM Ready event fired, decrement, and wait if need be
												if ( wait !== true && --jQuery.readyWait > 0 ) {
																return;
												}

												// If there are functions bound, to execute
												readyList.resolveWith( document, [ jQuery ] );

												// Trigger any bound ready events
												if ( jQuery.fn.trigger ) {
																jQuery( document ).trigger( "ready" ).off( "ready" );
												}
								}
				} );

				/**
				 * The ready event handler and self cleanup method
				 */
				function completed() {
								document.removeEventListener( "DOMContentLoaded", completed, false );
								window.removeEventListener( "load", completed, false );
								jQuery.ready();
				}

				jQuery.ready.promise = function( obj ) {
								if ( !readyList ) {

												readyList = jQuery.Deferred();

												// Catch cases where $(document).ready() is called after the browser event has already occurred.
												// we once tried to use readyState "interactive" here, but it caused issues like the one
												// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
												if ( document.readyState === "complete" ) {
																// Handle it asynchronously to allow scripts the opportunity to delay ready
																setTimeout( jQuery.ready );

												} else {

																// Use the handy event callback
																document.addEventListener( "DOMContentLoaded", completed, false );

																// A fallback to window.onload, that will always work
																window.addEventListener( "load", completed, false );
												}
								}
								return readyList.promise( obj );
				};

				// Kick off the DOM ready check even if the user does not
				jQuery.ready.promise();



				// Multifunctional method to get and set values of a collection
				// The value/s can optionally be executed if it's a function
				var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
								var i = 0,
												len = elems.length,
												bulk = key == null;

								// Sets many values
								if ( jQuery.type( key ) === "object" ) {
												chainable = true;
												for ( i in key ) {
																jQuery.access( elems, fn, i, key[ i ], true, emptyGet, raw );
												}

												// Sets one value
								} else if ( value !== undefined ) {
												chainable = true;

												if ( !jQuery.isFunction( value ) ) {
																raw = true;
												}

												if ( bulk ) {
																// Bulk operations run against the entire set
																if ( raw ) {
																				fn.call( elems, value );
																				fn = null;

																				// ...except when executing function values
																} else {
																				bulk = fn;
																				fn = function( elem, key, value ) {
																								return bulk.call( jQuery( elem ), value );
																				};
																}
												}

												if ( fn ) {
																for ( ; i < len; i++ ) {
																				fn( elems[ i ], key, raw ? value : value.call( elems[ i ], i, fn( elems[ i ], key ) ) );
																}
												}
								}

								return chainable ?
												elems :

								// Gets
								bulk ?
												fn.call( elems ) :
												len ? fn( elems[ 0 ], key ) : emptyGet;
				};


				/**
				 * Determines whether an object can have data
				 */
				jQuery.acceptData = function( owner ) {
								// Accepts only:
								//  - Node
								//    - Node.ELEMENT_NODE
								//    - Node.DOCUMENT_NODE
								//  - Object
								//    - Any
								/* jshint -W018 */
								return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
				};


				function Data() {
								// Support: Android < 4,
								// Old WebKit does not have Object.preventExtensions/freeze method,
								// return new empty object instead with no [[set]] accessor
								Object.defineProperty( this.cache = {}, 0, {
												get: function() {
																return {};
												}
								} );

								this.expando = jQuery.expando + Math.random();
				}

				Data.uid = 1;
				Data.accepts = jQuery.acceptData;

				Data.prototype = {
								key: function( owner ) {
												// We can accept data for non-element nodes in modern browsers,
												// but we should not, see #8335.
												// Always return the key for a frozen object.
												if ( !Data.accepts( owner ) ) {
																return 0;
												}

												var descriptor = {},
																// Check if the owner object already has a cache key
																unlock = owner[ this.expando ];

												// If not, create one
												if ( !unlock ) {
																unlock = Data.uid++;

																// Secure it in a non-enumerable, non-writable property
																try {
																				descriptor[ this.expando ] = {
																								value: unlock
																				};
																				Object.defineProperties( owner, descriptor );

																				// Support: Android < 4
																				// Fallback to a less secure definition
																} catch ( e ) {
																				descriptor[ this.expando ] = unlock;
																				jQuery.extend( owner, descriptor );
																}
												}

												// Ensure the cache object
												if ( !this.cache[ unlock ] ) {
																this.cache[ unlock ] = {};
												}

												return unlock;
								},
								set: function( owner, data, value ) {
												var prop,
																// There may be an unlock assigned to this node,
																// if there is no entry for this "owner", create one inline
																// and set the unlock as though an owner entry had always existed
																unlock = this.key( owner ),
																cache = this.cache[ unlock ];

												// Handle: [ owner, key, value ] args
												if ( typeof data === "string" ) {
																cache[ data ] = value;

																// Handle: [ owner, { properties } ] args
												} else {
																// Fresh assignments by object are shallow copied
																if ( jQuery.isEmptyObject( cache ) ) {
																				jQuery.extend( this.cache[ unlock ], data );
																				// Otherwise, copy the properties one-by-one to the cache object
																} else {
																				for ( prop in data ) {
																								cache[ prop ] = data[ prop ];
																				}
																}
												}
												return cache;
								},
								get: function( owner, key ) {
												// Either a valid cache is found, or will be created.
												// New caches will be created and the unlock returned,
												// allowing direct access to the newly created
												// empty data object. A valid owner object must be provided.
												var cache = this.cache[ this.key( owner ) ];

												return key === undefined ?
																cache : cache[ key ];
								},
								access: function( owner, key, value ) {
												var stored;
												// In cases where either:
												//
												//   1. No key was specified
												//   2. A string key was specified, but no value provided
												//
												// Take the "read" path and allow the get method to determine
												// which value to return, respectively either:
												//
												//   1. The entire cache object
												//   2. The data stored at the key
												//
												if ( key === undefined ||
																( ( key && typeof key === "string" ) && value === undefined ) ) {

																stored = this.get( owner, key );

																return stored !== undefined ?
																				stored : this.get( owner, jQuery.camelCase( key ) );
												}

												// [*]When the key is not a string, or both a key and value
												// are specified, set or extend (existing objects) with either:
												//
												//   1. An object of properties
												//   2. A key and value
												//
												this.set( owner, key, value );

												// Since the "set" path can have two possible entry points
												// return the expected data based on which path was taken[*]
												return value !== undefined ? value : key;
								},
								remove: function( owner, key ) {
												var i, name, camel,
																unlock = this.key( owner ),
																cache = this.cache[ unlock ];

												if ( key === undefined ) {
																this.cache[ unlock ] = {};

												} else {
																// Support array or space separated string of keys
																if ( jQuery.isArray( key ) ) {
																				// If "name" is an array of keys...
																				// When data is initially created, via ("key", "val") signature,
																				// keys will be converted to camelCase.
																				// Since there is no way to tell _how_ a key was added, remove
																				// both plain key and camelCase key. #12786
																				// This will only penalize the array argument path.
																				name = key.concat( key.map( jQuery.camelCase ) );
																} else {
																				camel = jQuery.camelCase( key );
																				// Try the string as a key before any manipulation
																				if ( key in cache ) {
																								name = [ key, camel ];
																				} else {
																								// If a key with the spaces exists, use it.
																								// Otherwise, create an array by matching non-whitespace
																								name = camel;
																								name = name in cache ?
																												[ name ] : ( name.match( rnotwhite ) || [] );
																				}
																}

																i = name.length;
																while ( i-- ) {
																				delete cache[ name[ i ] ];
																}
												}
								},
								hasData: function( owner ) {
												return !jQuery.isEmptyObject(
																this.cache[ owner[ this.expando ] ] || {}
												);
								},
								discard: function( owner ) {
												if ( owner[ this.expando ] ) {
																delete this.cache[ owner[ this.expando ] ];
												}
								}
				};
				var data_priv = new Data();

				var data_user = new Data();



				/*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
				var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
								rmultiDash = /([A-Z])/g;

				function dataAttr( elem, key, data ) {
								var name;

								// If nothing was found internally, try to fetch any
								// data from the HTML5 data-* attribute
								if ( data === undefined && elem.nodeType === 1 ) {
												name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
												data = elem.getAttribute( name );

												if ( typeof data === "string" ) {
																try {
																				data = data === "true" ? true :
																								data === "false" ? false :
																								data === "null" ? null :
																				// Only convert to a number if it doesn't change the string
																				+data + "" === data ? +data :
																								rbrace.test( data ) ? jQuery.parseJSON( data ) :
																								data;
																} catch ( e ) {}

																// Make sure we set the data so it isn't changed later
																data_user.set( elem, key, data );
												} else {
																data = undefined;
												}
								}
								return data;
				}

				jQuery.extend( {
								hasData: function( elem ) {
												return data_user.hasData( elem ) || data_priv.hasData( elem );
								},

								data: function( elem, name, data ) {
												return data_user.access( elem, name, data );
								},

								removeData: function( elem, name ) {
												data_user.remove( elem, name );
								},

								// TODO: Now that all calls to _data and _removeData have been replaced
								// with direct calls to data_priv methods, these can be deprecated.
								_data: function( elem, name, data ) {
												return data_priv.access( elem, name, data );
								},

								_removeData: function( elem, name ) {
												data_priv.remove( elem, name );
								}
				} );

				jQuery.fn.extend( {
								data: function( key, value ) {
												var i, name, data,
																elem = this[ 0 ],
																attrs = elem && elem.attributes;

												// Gets all values
												if ( key === undefined ) {
																if ( this.length ) {
																				data = data_user.get( elem );

																				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
																								i = attrs.length;
																								while ( i-- ) {
																												name = attrs[ i ].name;

																												if ( name.indexOf( "data-" ) === 0 ) {
																																name = jQuery.camelCase( name.slice( 5 ) );
																																dataAttr( elem, name, data[ name ] );
																												}
																								}
																								data_priv.set( elem, "hasDataAttrs", true );
																				}
																}

																return data;
												}

												// Sets multiple values
												if ( typeof key === "object" ) {
																return this.each( function() {
																				data_user.set( this, key );
																} );
												}

												return access( this, function( value ) {
																var data,
																				camelKey = jQuery.camelCase( key );

																// The calling jQuery object (element matches) is not empty
																// (and therefore has an element appears at this[ 0 ]) and the
																// `value` parameter was not undefined. An empty jQuery object
																// will result in `undefined` for elem = this[ 0 ] which will
																// throw an exception if an attempt to read a data cache is made.
																if ( elem && value === undefined ) {
																				// Attempt to get data from the cache
																				// with the key as-is
																				data = data_user.get( elem, key );
																				if ( data !== undefined ) {
																								return data;
																				}

																				// Attempt to get data from the cache
																				// with the key camelized
																				data = data_user.get( elem, camelKey );
																				if ( data !== undefined ) {
																								return data;
																				}

																				// Attempt to "discover" the data in
																				// HTML5 custom data-* attrs
																				data = dataAttr( elem, camelKey, undefined );
																				if ( data !== undefined ) {
																								return data;
																				}

																				// We tried really hard, but the data doesn't exist.
																				return;
																}

																// Set the data...
																this.each( function() {
																				// First, attempt to store a copy or reference of any
																				// data that might've been store with a camelCased key.
																				var data = data_user.get( this, camelKey );

																				// For HTML5 data-* attribute interop, we have to
																				// store property names with dashes in a camelCase form.
																				// This might not apply to all properties...*
																				data_user.set( this, camelKey, value );

																				// *... In the case of properties that might _actually_
																				// have dashes, we need to also store a copy of that
																				// unchanged property.
																				if ( key.indexOf( "-" ) !== -1 && data !== undefined ) {
																								data_user.set( this, key, value );
																				}
																} );
												}, null, value, arguments.length > 1, null, true );
								},

								removeData: function( key ) {
												return this.each( function() {
																data_user.remove( this, key );
												} );
								}
				} );


				jQuery.extend( {
								queue: function( elem, type, data ) {
												var queue;

												if ( elem ) {
																type = ( type || "fx" ) + "queue";
																queue = data_priv.get( elem, type );

																// Speed up dequeue by getting out quickly if this is just a lookup
																if ( data ) {
																				if ( !queue || jQuery.isArray( data ) ) {
																								queue = data_priv.access( elem, type, jQuery.makeArray( data ) );
																				} else {
																								queue.push( data );
																				}
																}
																return queue || [];
												}
								},

								dequeue: function( elem, type ) {
												type = type || "fx";

												var queue = jQuery.queue( elem, type ),
																startLength = queue.length,
																fn = queue.shift(),
																hooks = jQuery._queueHooks( elem, type ),
																next = function() {
																				jQuery.dequeue( elem, type );
																};

												// If the fx queue is dequeued, always remove the progress sentinel
												if ( fn === "inprogress" ) {
																fn = queue.shift();
																startLength--;
												}

												if ( fn ) {

																// Add a progress sentinel to prevent the fx queue from being
																// automatically dequeued
																if ( type === "fx" ) {
																				queue.unshift( "inprogress" );
																}

																// clear up the last queue stop function
																delete hooks.stop;
																fn.call( elem, next, hooks );
												}

												if ( !startLength && hooks ) {
																hooks.empty.fire();
												}
								},

								// not intended for public consumption - generates a queueHooks object, or returns the current one
								_queueHooks: function( elem, type ) {
												var key = type + "queueHooks";
												return data_priv.get( elem, key ) || data_priv.access( elem, key, {
																empty: jQuery.Callbacks( "once memory" ).add( function() {
																				data_priv.remove( elem, [ type + "queue", key ] );
																} )
												} );
								}
				} );

				jQuery.fn.extend( {
								queue: function( type, data ) {
												var setter = 2;

												if ( typeof type !== "string" ) {
																data = type;
																type = "fx";
																setter--;
												}

												if ( arguments.length < setter ) {
																return jQuery.queue( this[ 0 ], type );
												}

												return data === undefined ?
																this :
																this.each( function() {
																				var queue = jQuery.queue( this, type, data );

																				// ensure a hooks for this queue
																				jQuery._queueHooks( this, type );

																				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
																								jQuery.dequeue( this, type );
																				}
																} );
								},
								dequeue: function( type ) {
												return this.each( function() {
																jQuery.dequeue( this, type );
												} );
								},
								clearQueue: function( type ) {
												return this.queue( type || "fx", [] );
								},
								// Get a promise resolved when queues of a certain type
								// are emptied (fx is the type by default)
								promise: function( type, obj ) {
												var tmp,
																count = 1,
																defer = jQuery.Deferred(),
																elements = this,
																i = this.length,
																resolve = function() {
																				if ( !( --count ) ) {
																								defer.resolveWith( elements, [ elements ] );
																				}
																};

												if ( typeof type !== "string" ) {
																obj = type;
																type = undefined;
												}
												type = type || "fx";

												while ( i-- ) {
																tmp = data_priv.get( elements[ i ], type + "queueHooks" );
																if ( tmp && tmp.empty ) {
																				count++;
																				tmp.empty.add( resolve );
																}
												}
												resolve();
												return defer.promise( obj );
								}
				} );
				var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

				var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

				var isHidden = function( elem, el ) {
								// isHidden might be called from jQuery#filter function;
								// in that case, element will be second argument
								elem = el || elem;
								return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
				};

				var rcheckableType = ( /^(?:checkbox|radio)$/i );



				( function() {
								var fragment = document.createDocumentFragment(),
												div = fragment.appendChild( document.createElement( "div" ) );

								// #11217 - WebKit loses check when the name is after the checked attribute
								div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

								// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
								// old WebKit doesn't clone checked state correctly in fragments
								support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

								// Make sure textarea (and checkbox) defaultValue is properly cloned
								// Support: IE9-IE11+
								div.innerHTML = "<textarea>x</textarea>";
								support.noCloneChecked = !! div.cloneNode( true ).lastChild.defaultValue;
				} )();
				var strundefined = typeof undefined;



				support.focusinBubbles = "onfocusin" in window;


				var
				rkeyEvent = /^key/,
								rmouseEvent = /^(?:mouse|contextmenu)|click/,
								rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
								rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

				function returnTrue() {
								return true;
				}

				function returnFalse() {
								return false;
				}

				function safeActiveElement() {
								try {
												return document.activeElement;
								} catch ( err ) {}
				}

				/*
				 * Helper functions for managing events -- not part of the public interface.
				 * Props to Dean Edwards' addEvent library for many of the ideas.
				 */
				jQuery.event = {

								global: {},

								add: function( elem, types, handler, data, selector ) {

												var handleObjIn, eventHandle, tmp,
																events, t, handleObj,
																special, handlers, type, namespaces, origType,
																elemData = data_priv.get( elem );

												// Don't attach events to noData or text/comment nodes (but allow plain objects)
												if ( !elemData ) {
																return;
												}

												// Caller can pass in an object of custom data in lieu of the handler
												if ( handler.handler ) {
																handleObjIn = handler;
																handler = handleObjIn.handler;
																selector = handleObjIn.selector;
												}

												// Make sure that the handler has a unique ID, used to find/remove it later
												if ( !handler.guid ) {
																handler.guid = jQuery.guid++;
												}

												// Init the element's event structure and main handler, if this is the first
												if ( !( events = elemData.events ) ) {
																events = elemData.events = {};
												}
												if ( !( eventHandle = elemData.handle ) ) {
																eventHandle = elemData.handle = function( e ) {
																				// Discard the second event of a jQuery.event.trigger() and
																				// when an event is called after a page has unloaded
																				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
																								jQuery.event.dispatch.apply( elem, arguments ) : undefined;
																};
												}

												// Handle multiple events separated by a space
												types = ( types || "" ).match( rnotwhite ) || [ "" ];
												t = types.length;
												while ( t-- ) {
																tmp = rtypenamespace.exec( types[ t ] ) || [];
																type = origType = tmp[ 1 ];
																namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

																// There *must* be a type, no attaching namespace-only handlers
																if ( !type ) {
																				continue;
																}

																// If event changes its type, use the special event handlers for the changed type
																special = jQuery.event.special[ type ] || {};

																// If selector defined, determine special event api type, otherwise given type
																type = ( selector ? special.delegateType : special.bindType ) || type;

																// Update special based on newly reset type
																special = jQuery.event.special[ type ] || {};

																// handleObj is passed to all event handlers
																handleObj = jQuery.extend( {
																				type: type,
																				origType: origType,
																				data: data,
																				handler: handler,
																				guid: handler.guid,
																				selector: selector,
																				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
																				namespace: namespaces.join( "." )
																}, handleObjIn );

																// Init the event handler queue if we're the first
																if ( !( handlers = events[ type ] ) ) {
																				handlers = events[ type ] = [];
																				handlers.delegateCount = 0;

																				// Only use addEventListener if the special events handler returns false
																				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
																								if ( elem.addEventListener ) {
																												elem.addEventListener( type, eventHandle, false );
																								}
																				}
																}

																if ( special.add ) {
																				special.add.call( elem, handleObj );

																				if ( !handleObj.handler.guid ) {
																								handleObj.handler.guid = handler.guid;
																				}
																}

																// Add to the element's handler list, delegates in front
																if ( selector ) {
																				handlers.splice( handlers.delegateCount++, 0, handleObj );
																} else {
																				handlers.push( handleObj );
																}

																// Keep track of which events have ever been used, for event optimization
																jQuery.event.global[ type ] = true;
												}

								},

								// Detach an event or set of events from an element
								remove: function( elem, types, handler, selector, mappedTypes ) {

												var j, origCount, tmp,
																events, t, handleObj,
																special, handlers, type, namespaces, origType,
																elemData = data_priv.hasData( elem ) && data_priv.get( elem );

												if ( !elemData || !( events = elemData.events ) ) {
																return;
												}

												// Once for each type.namespace in types; type may be omitted
												types = ( types || "" ).match( rnotwhite ) || [ "" ];
												t = types.length;
												while ( t-- ) {
																tmp = rtypenamespace.exec( types[ t ] ) || [];
																type = origType = tmp[ 1 ];
																namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

																// Unbind all events (on this namespace, if provided) for the element
																if ( !type ) {
																				for ( type in events ) {
																								jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
																				}
																				continue;
																}

																special = jQuery.event.special[ type ] || {};
																type = ( selector ? special.delegateType : special.bindType ) || type;
																handlers = events[ type ] || [];
																tmp = tmp[ 2 ] && new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

																// Remove matching events
																origCount = j = handlers.length;
																while ( j-- ) {
																				handleObj = handlers[ j ];

																				if ( ( mappedTypes || origType === handleObj.origType ) &&
																								( !handler || handler.guid === handleObj.guid ) &&
																								( !tmp || tmp.test( handleObj.namespace ) ) &&
																								( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
																								handlers.splice( j, 1 );

																								if ( handleObj.selector ) {
																												handlers.delegateCount--;
																								}
																								if ( special.remove ) {
																												special.remove.call( elem, handleObj );
																								}
																				}
																}

																// Remove generic event handler if we removed something and no more handlers exist
																// (avoids potential for endless recursion during removal of special event handlers)
																if ( origCount && !handlers.length ) {
																				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
																								jQuery.removeEvent( elem, type, elemData.handle );
																				}

																				delete events[ type ];
																}
												}

												// Remove the expando if it's no longer used
												if ( jQuery.isEmptyObject( events ) ) {
																delete elemData.handle;
																data_priv.remove( elem, "events" );
												}
								},

								trigger: function( event, data, elem, onlyHandlers ) {

												var i, cur, tmp, bubbleType, ontype, handle, special,
																eventPath = [ elem || document ],
																type = hasOwn.call( event, "type" ) ? event.type : event,
																namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

												cur = tmp = elem = elem || document;

												// Don't do events on text and comment nodes
												if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
																return;
												}

												// focus/blur morphs to focusin/out; ensure we're not firing them right now
												if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
																return;
												}

												if ( type.indexOf( "." ) >= 0 ) {
																// Namespaced trigger; create a regexp to match event type in handle()
																namespaces = type.split( "." );
																type = namespaces.shift();
																namespaces.sort();
												}
												ontype = type.indexOf( ":" ) < 0 && "on" + type;

												// Caller can pass in a jQuery.Event object, Object, or just an event type string
												event = event[ jQuery.expando ] ?
																event :
																new jQuery.Event( type, typeof event === "object" && event );

												// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
												event.isTrigger = onlyHandlers ? 2 : 3;
												event.namespace = namespaces.join( "." );
												event.namespace_re = event.namespace ?
																new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
																null;

												// Clean up the event in case it is being reused
												event.result = undefined;
												if ( !event.target ) {
																event.target = elem;
												}

												// Clone any incoming data and prepend the event, creating the handler arg list
												data = data == null ?
																[ event ] :
																jQuery.makeArray( data, [ event ] );

												// Allow special events to draw outside the lines
												special = jQuery.event.special[ type ] || {};
												if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
																return;
												}

												// Determine event propagation path in advance, per W3C events spec (#9951)
												// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
												if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

																bubbleType = special.delegateType || type;
																if ( !rfocusMorph.test( bubbleType + type ) ) {
																				cur = cur.parentNode;
																}
																for ( ; cur; cur = cur.parentNode ) {
																				eventPath.push( cur );
																				tmp = cur;
																}

																// Only add window if we got to document (e.g., not plain obj or detached DOM)
																if ( tmp === ( elem.ownerDocument || document ) ) {
																				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
																}
												}

												// Fire handlers on the event path
												i = 0;
												while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

																event.type = i > 1 ?
																				bubbleType :
																				special.bindType || type;

																// jQuery handler
																handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
																if ( handle ) {
																				handle.apply( cur, data );
																}

																// Native handler
																handle = ontype && cur[ ontype ];
																if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
																				event.result = handle.apply( cur, data );
																				if ( event.result === false ) {
																								event.preventDefault();
																				}
																}
												}
												event.type = type;

												// If nobody prevented the default action, do it now
												if ( !onlyHandlers && !event.isDefaultPrevented() ) {

																if ( ( !special._default || special._default.apply( eventPath.pop(), data ) === false ) &&
																				jQuery.acceptData( elem ) ) {

																				// Call a native DOM method on the target with the same name name as the event.
																				// Don't do default actions on window, that's where global variables be (#6170)
																				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

																								// Don't re-trigger an onFOO event when we call its FOO() method
																								tmp = elem[ ontype ];

																								if ( tmp ) {
																												elem[ ontype ] = null;
																								}

																								// Prevent re-triggering of the same event, since we already bubbled it above
																								jQuery.event.triggered = type;
																								elem[ type ]();
																								jQuery.event.triggered = undefined;

																								if ( tmp ) {
																												elem[ ontype ] = tmp;
																								}
																				}
																}
												}

												return event.result;
								},

								dispatch: function( event ) {

												// Make a writable jQuery.Event from the native event object
												event = jQuery.event.fix( event );

												var i, j, ret, matched, handleObj,
																handlerQueue = [],
																args = slice.call( arguments ),
																handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
																special = jQuery.event.special[ event.type ] || {};

												// Use the fix-ed jQuery.Event rather than the (read-only) native event
												args[ 0 ] = event;
												event.delegateTarget = this;

												// Call the preDispatch hook for the mapped type, and let it bail if desired
												if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
																return;
												}

												// Determine handlers
												handlerQueue = jQuery.event.handlers.call( this, event, handlers );

												// Run delegates first; they may want to stop propagation beneath us
												i = 0;
												while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
																event.currentTarget = matched.elem;

																j = 0;
																while ( ( handleObj = matched.handlers[ j++ ] ) && !event.isImmediatePropagationStopped() ) {

																				// Triggered event must either 1) have no namespace, or
																				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
																				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

																								event.handleObj = handleObj;
																								event.data = handleObj.data;

																								ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle || handleObj.handler )
																												.apply( matched.elem, args );

																								if ( ret !== undefined ) {
																												if ( ( event.result = ret ) === false ) {
																																event.preventDefault();
																																event.stopPropagation();
																												}
																								}
																				}
																}
												}

												// Call the postDispatch hook for the mapped type
												if ( special.postDispatch ) {
																special.postDispatch.call( this, event );
												}

												return event.result;
								},

								handlers: function( event, handlers ) {
												var i, matches, sel, handleObj,
																handlerQueue = [],
																delegateCount = handlers.delegateCount,
																cur = event.target;

												// Find delegate handlers
												// Black-hole SVG <use> instance trees (#13180)
												// Avoid non-left-click bubbling in Firefox (#3861)
												if ( delegateCount && cur.nodeType && ( !event.button || event.type !== "click" ) ) {

																for ( ; cur !== this; cur = cur.parentNode || this ) {

																				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
																				if ( cur.disabled !== true || event.type !== "click" ) {
																								matches = [];
																								for ( i = 0; i < delegateCount; i++ ) {
																												handleObj = handlers[ i ];

																												// Don't conflict with Object.prototype properties (#13203)
																												sel = handleObj.selector + " ";

																												if ( matches[ sel ] === undefined ) {
																																matches[ sel ] = handleObj.needsContext ?
																																				jQuery( sel, this ).index( cur ) >= 0 :
																																				jQuery.find( sel, this, null, [ cur ] ).length;
																												}
																												if ( matches[ sel ] ) {
																																matches.push( handleObj );
																												}
																								}
																								if ( matches.length ) {
																												handlerQueue.push( {
																																elem: cur,
																																handlers: matches
																												} );
																								}
																				}
																}
												}

												// Add the remaining (directly-bound) handlers
												if ( delegateCount < handlers.length ) {
																handlerQueue.push( {
																				elem: this,
																				handlers: handlers.slice( delegateCount )
																} );
												}

												return handlerQueue;
								},

								// Includes some event props shared by KeyEvent and MouseEvent
								props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split( " " ),

								fixHooks: {},

								keyHooks: {
												props: "char charCode key keyCode".split( " " ),
												filter: function( event, original ) {

																// Add which for key events
																if ( event.which == null ) {
																				event.which = original.charCode != null ? original.charCode : original.keyCode;
																}

																return event;
												}
								},

								mouseHooks: {
												props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split( " " ),
												filter: function( event, original ) {
																var eventDoc, doc, body,
																				button = original.button;

																// Calculate pageX/Y if missing and clientX/Y available
																if ( event.pageX == null && original.clientX != null ) {
																				eventDoc = event.target.ownerDocument || document;
																				doc = eventDoc.documentElement;
																				body = eventDoc.body;

																				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
																				event.pageY = original.clientY + ( doc && doc.scrollTop || body && body.scrollTop || 0 ) - ( doc && doc.clientTop || body && body.clientTop || 0 );
																}

																// Add which for click: 1 === left; 2 === middle; 3 === right
																// Note: button is not normalized, so don't use it
																if ( !event.which && button !== undefined ) {
																				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
																}

																return event;
												}
								},

								fix: function( event ) {
												if ( event[ jQuery.expando ] ) {
																return event;
												}

												// Create a writable copy of the event object and normalize some properties
												var i, prop, copy,
																type = event.type,
																originalEvent = event,
																fixHook = this.fixHooks[ type ];

												if ( !fixHook ) {
																this.fixHooks[ type ] = fixHook =
																				rmouseEvent.test( type ) ? this.mouseHooks :
																				rkeyEvent.test( type ) ? this.keyHooks : {};
												}
												copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

												event = new jQuery.Event( originalEvent );

												i = copy.length;
												while ( i-- ) {
																prop = copy[ i ];
																event[ prop ] = originalEvent[ prop ];
												}

												// Support: Cordova 2.5 (WebKit) (#13255)
												// All events should have a target; Cordova deviceready doesn't
												if ( !event.target ) {
																event.target = document;
												}

												// Support: Safari 6.0+, Chrome < 28
												// Target should not be a text node (#504, #13143)
												if ( event.target.nodeType === 3 ) {
																event.target = event.target.parentNode;
												}

												return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
								},

								special: {
												load: {
																// Prevent triggered image.load events from bubbling to window.load
																noBubble: true
												},
												focus: {
																// Fire native event if possible so blur/focus sequence is correct
																trigger: function() {
																				if ( this !== safeActiveElement() && this.focus ) {
																								this.focus();
																								return false;
																				}
																},
																delegateType: "focusin"
												},
												blur: {
																trigger: function() {
																				if ( this === safeActiveElement() && this.blur ) {
																								this.blur();
																								return false;
																				}
																},
																delegateType: "focusout"
												},
												click: {
																// For checkbox, fire native event so checked state will be right
																trigger: function() {
																				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
																								this.click();
																								return false;
																				}
																},

																// For cross-browser consistency, don't fire native .click() on links
																_default: function( event ) {
																				return jQuery.nodeName( event.target, "a" );
																}
												},

												beforeunload: {
																postDispatch: function( event ) {

																				// Support: Firefox 20+
																				// Firefox doesn't alert if the returnValue field is not set.
																				if ( event.result !== undefined ) {
																								event.originalEvent.returnValue = event.result;
																				}
																}
												}
								},

								simulate: function( type, elem, event, bubble ) {
												// Piggyback on a donor event to simulate a different one.
												// Fake originalEvent to avoid donor's stopPropagation, but if the
												// simulated event prevents default then we do the same on the donor.
												var e = jQuery.extend(
																new jQuery.Event(),
																event, {
																				type: type,
																				isSimulated: true,
																				originalEvent: {}
																}
												);
												if ( bubble ) {
																jQuery.event.trigger( e, null, elem );
												} else {
																jQuery.event.dispatch.call( elem, e );
												}
												if ( e.isDefaultPrevented() ) {
																event.preventDefault();
												}
								}
				};

				jQuery.removeEvent = function( elem, type, handle ) {
								if ( elem.removeEventListener ) {
												elem.removeEventListener( type, handle, false );
								}
				};

				jQuery.Event = function( src, props ) {
								// Allow instantiation without the 'new' keyword
								if ( !( this instanceof jQuery.Event ) ) {
												return new jQuery.Event( src, props );
								}

								// Event object
								if ( src && src.type ) {
												this.originalEvent = src;
												this.type = src.type;

												// Events bubbling up the document may have been marked as prevented
												// by a handler lower down the tree; reflect the correct value.
												this.isDefaultPrevented = src.defaultPrevented ||
												// Support: Android < 4.0
												src.defaultPrevented === undefined &&
																src.getPreventDefault && src.getPreventDefault() ?
																returnTrue :
																returnFalse;

												// Event type
								} else {
												this.type = src;
								}

								// Put explicitly provided properties onto the event object
								if ( props ) {
												jQuery.extend( this, props );
								}

								// Create a timestamp if incoming event doesn't have one
								this.timeStamp = src && src.timeStamp || jQuery.now();

								// Mark it as fixed
								this[ jQuery.expando ] = true;
				};

				// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
				// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
				jQuery.Event.prototype = {
								isDefaultPrevented: returnFalse,
								isPropagationStopped: returnFalse,
								isImmediatePropagationStopped: returnFalse,

								preventDefault: function() {
												var e = this.originalEvent;

												this.isDefaultPrevented = returnTrue;

												if ( e && e.preventDefault ) {
																e.preventDefault();
												}
								},
								stopPropagation: function() {
												var e = this.originalEvent;

												this.isPropagationStopped = returnTrue;

												if ( e && e.stopPropagation ) {
																e.stopPropagation();
												}
								},
								stopImmediatePropagation: function() {
												this.isImmediatePropagationStopped = returnTrue;
												this.stopPropagation();
								}
				};

				// Create mouseenter/leave events using mouseover/out and event-time checks
				// Support: Chrome 15+
				jQuery.each( {
								mouseenter: "mouseover",
								mouseleave: "mouseout"
				}, function( orig, fix ) {
								jQuery.event.special[ orig ] = {
												delegateType: fix,
												bindType: fix,

												handle: function( event ) {
																var ret,
																				target = this,
																				related = event.relatedTarget,
																				handleObj = event.handleObj;

																// For mousenter/leave call the handler if related is outside the target.
																// NB: No relatedTarget if the mouse left/entered the browser window
																if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
																				event.type = handleObj.origType;
																				ret = handleObj.handler.apply( this, arguments );
																				event.type = fix;
																}
																return ret;
												}
								};
				} );

				// Create "bubbling" focus and blur events
				// Support: Firefox, Chrome, Safari
				if ( !support.focusinBubbles ) {
								jQuery.each( {
												focus: "focusin",
												blur: "focusout"
								}, function( orig, fix ) {

												// Attach a single capturing handler on the document while someone wants focusin/focusout
												var handler = function( event ) {
																jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
												};

												jQuery.event.special[ fix ] = {
																setup: function() {
																				var doc = this.ownerDocument || this,
																								attaches = data_priv.access( doc, fix );

																				if ( !attaches ) {
																								doc.addEventListener( orig, handler, true );
																				}
																				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
																},
																teardown: function() {
																				var doc = this.ownerDocument || this,
																								attaches = data_priv.access( doc, fix ) - 1;

																				if ( !attaches ) {
																								doc.removeEventListener( orig, handler, true );
																								data_priv.remove( doc, fix );

																				} else {
																								data_priv.access( doc, fix, attaches );
																				}
																}
												};
								} );
				}

				jQuery.fn.extend( {

								on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
												var origFn, type;

												// Types can be a map of types/handlers
												if ( typeof types === "object" ) {
																// ( types-Object, selector, data )
																if ( typeof selector !== "string" ) {
																				// ( types-Object, data )
																				data = data || selector;
																				selector = undefined;
																}
																for ( type in types ) {
																				this.on( type, selector, data, types[ type ], one );
																}
																return this;
												}

												if ( data == null && fn == null ) {
																// ( types, fn )
																fn = selector;
																data = selector = undefined;
												} else if ( fn == null ) {
																if ( typeof selector === "string" ) {
																				// ( types, selector, fn )
																				fn = data;
																				data = undefined;
																} else {
																				// ( types, data, fn )
																				fn = data;
																				data = selector;
																				selector = undefined;
																}
												}
												if ( fn === false ) {
																fn = returnFalse;
												} else if ( !fn ) {
																return this;
												}

												if ( one === 1 ) {
																origFn = fn;
																fn = function( event ) {
																				// Can use an empty set, since event contains the info
																				jQuery().off( event );
																				return origFn.apply( this, arguments );
																};
																// Use same guid so caller can remove using origFn
																fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
												}
												return this.each( function() {
																jQuery.event.add( this, types, fn, data, selector );
												} );
								},
								one: function( types, selector, data, fn ) {
												return this.on( types, selector, data, fn, 1 );
								},
								off: function( types, selector, fn ) {
												var handleObj, type;
												if ( types && types.preventDefault && types.handleObj ) {
																// ( event )  dispatched jQuery.Event
																handleObj = types.handleObj;
																jQuery( types.delegateTarget ).off(
																				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
																				handleObj.selector,
																				handleObj.handler
																);
																return this;
												}
												if ( typeof types === "object" ) {
																// ( types-object [, selector] )
																for ( type in types ) {
																				this.off( type, selector, types[ type ] );
																}
																return this;
												}
												if ( selector === false || typeof selector === "function" ) {
																// ( types [, fn] )
																fn = selector;
																selector = undefined;
												}
												if ( fn === false ) {
																fn = returnFalse;
												}
												return this.each( function() {
																jQuery.event.remove( this, types, fn, selector );
												} );
								},

								trigger: function( type, data ) {
												return this.each( function() {
																jQuery.event.trigger( type, data, this );
												} );
								},
								triggerHandler: function( type, data ) {
												var elem = this[ 0 ];
												if ( elem ) {
																return jQuery.event.trigger( type, data, elem, true );
												}
								}
				} );


				var
				rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
								rtagName = /<([\w:]+)/,
								rhtml = /<|&#?\w+;/,
								rnoInnerhtml = /<(?:script|style|link)/i,
								// checked="checked" or checked
								rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
								rscriptType = /^$|\/(?:java|ecma)script/i,
								rscriptTypeMasked = /^true\/(.*)/,
								rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

								// We have to close these tags to support XHTML (#13200)
								wrapMap = {

												// Support: IE 9
												option: [ 1, "<select multiple='multiple'>", "</select>" ],

												thead: [ 1, "<table>", "</table>" ],
												col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
												tr: [ 2, "<table><tbody>", "</tbody></table>" ],
												td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

												_default: [ 0, "", "" ]
								};

				// Support: IE 9
				wrapMap.optgroup = wrapMap.option;

				wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
				wrapMap.th = wrapMap.td;

				// Support: 1.x compatibility
				// Manipulating tables requires a tbody
				function manipulationTarget( elem, content ) {
								return jQuery.nodeName( elem, "table" ) &&
												jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

								elem.getElementsByTagName( "tbody" )[ 0 ] ||
												elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
												elem;
				}

				// Replace/restore the type attribute of script elements for safe DOM manipulation
				function disableScript( elem ) {
								elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
								return elem;
				}

				function restoreScript( elem ) {
								var match = rscriptTypeMasked.exec( elem.type );

								if ( match ) {
												elem.type = match[ 1 ];
								} else {
												elem.removeAttribute( "type" );
								}

								return elem;
				}

				// Mark scripts as having already been evaluated
				function setGlobalEval( elems, refElements ) {
								var i = 0,
												l = elems.length;

								for ( ; i < l; i++ ) {
												data_priv.set(
																elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
												);
								}
				}

				function cloneCopyEvent( src, dest ) {
								var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

								if ( dest.nodeType !== 1 ) {
												return;
								}

								// 1. Copy private data: events, handlers, etc.
								if ( data_priv.hasData( src ) ) {
												pdataOld = data_priv.access( src );
												pdataCur = data_priv.set( dest, pdataOld );
												events = pdataOld.events;

												if ( events ) {
																delete pdataCur.handle;
																pdataCur.events = {};

																for ( type in events ) {
																				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
																								jQuery.event.add( dest, type, events[ type ][ i ] );
																				}
																}
												}
								}

								// 2. Copy user data
								if ( data_user.hasData( src ) ) {
												udataOld = data_user.access( src );
												udataCur = jQuery.extend( {}, udataOld );

												data_user.set( dest, udataCur );
								}
				}

				function getAll( context, tag ) {
								var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
												context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
												[];

								return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
												jQuery.merge( [ context ], ret ) :
												ret;
				}

				// Support: IE >= 9
				function fixInput( src, dest ) {
								var nodeName = dest.nodeName.toLowerCase();

								// Fails to persist the checked state of a cloned checkbox or radio button.
								if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
												dest.checked = src.checked;

												// Fails to return the selected option to the default selected state when cloning options
								} else if ( nodeName === "input" || nodeName === "textarea" ) {
												dest.defaultValue = src.defaultValue;
								}
				}

				jQuery.extend( {
								clone: function( elem, dataAndEvents, deepDataAndEvents ) {
												var i, l, srcElements, destElements,
																clone = elem.cloneNode( true ),
																inPage = jQuery.contains( elem.ownerDocument, elem );

												// Support: IE >= 9
												// Fix Cloning issues
												if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {

																// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
																destElements = getAll( clone );
																srcElements = getAll( elem );

																for ( i = 0, l = srcElements.length; i < l; i++ ) {
																				fixInput( srcElements[ i ], destElements[ i ] );
																}
												}

												// Copy the events from the original to the clone
												if ( dataAndEvents ) {
																if ( deepDataAndEvents ) {
																				srcElements = srcElements || getAll( elem );
																				destElements = destElements || getAll( clone );

																				for ( i = 0, l = srcElements.length; i < l; i++ ) {
																								cloneCopyEvent( srcElements[ i ], destElements[ i ] );
																				}
																} else {
																				cloneCopyEvent( elem, clone );
																}
												}

												// Preserve script evaluation history
												destElements = getAll( clone, "script" );
												if ( destElements.length > 0 ) {
																setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
												}

												// Return the cloned set
												return clone;
								},

								buildFragment: function( elems, context, scripts, selection ) {
												var elem, tmp, tag, wrap, contains, j,
																fragment = context.createDocumentFragment(),
																nodes = [],
																i = 0,
																l = elems.length;

												for ( ; i < l; i++ ) {
																elem = elems[ i ];

																if ( elem || elem === 0 ) {

																				// Add nodes directly
																				if ( jQuery.type( elem ) === "object" ) {
																								// Support: QtWebKit
																								// jQuery.merge because push.apply(_, arraylike) throws
																								jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

																								// Convert non-html into a text node
																				} else if ( !rhtml.test( elem ) ) {
																								nodes.push( context.createTextNode( elem ) );

																								// Convert html into DOM nodes
																				} else {
																								tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

																								// Deserialize a standard representation
																								tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
																								wrap = wrapMap[ tag ] || wrapMap._default;
																								tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

																								// Descend through wrappers to the right content
																								j = wrap[ 0 ];
																								while ( j-- ) {
																												tmp = tmp.lastChild;
																								}

																								// Support: QtWebKit
																								// jQuery.merge because push.apply(_, arraylike) throws
																								jQuery.merge( nodes, tmp.childNodes );

																								// Remember the top-level container
																								tmp = fragment.firstChild;

																								// Fixes #12346
																								// Support: Webkit, IE
																								tmp.textContent = "";
																				}
																}
												}

												// Remove wrapper from fragment
												fragment.textContent = "";

												i = 0;
												while ( ( elem = nodes[ i++ ] ) ) {

																// #4087 - If origin and destination elements are the same, and this is
																// that element, do not do anything
																if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
																				continue;
																}

																contains = jQuery.contains( elem.ownerDocument, elem );

																// Append to fragment
																tmp = getAll( fragment.appendChild( elem ), "script" );

																// Preserve script evaluation history
																if ( contains ) {
																				setGlobalEval( tmp );
																}

																// Capture executables
																if ( scripts ) {
																				j = 0;
																				while ( ( elem = tmp[ j++ ] ) ) {
																								if ( rscriptType.test( elem.type || "" ) ) {
																												scripts.push( elem );
																								}
																				}
																}
												}

												return fragment;
								},

								cleanData: function( elems ) {
												var data, elem, events, type, key, j,
																special = jQuery.event.special,
																i = 0;

												for ( ;
																( elem = elems[ i ] ) !== undefined; i++ ) {
																if ( jQuery.acceptData( elem ) ) {
																				key = elem[ data_priv.expando ];

																				if ( key && ( data = data_priv.cache[ key ] ) ) {
																								events = Object.keys( data.events || {} );
																								if ( events.length ) {
																												for ( j = 0;
																																( type = events[ j ] ) !== undefined; j++ ) {
																																if ( special[ type ] ) {
																																				jQuery.event.remove( elem, type );

																																				// This is a shortcut to avoid jQuery.event.remove's overhead
																																} else {
																																				jQuery.removeEvent( elem, type, data.handle );
																																}
																												}
																								}
																								if ( data_priv.cache[ key ] ) {
																												// Discard any remaining `private` data
																												delete data_priv.cache[ key ];
																								}
																				}
																}
																// Discard any remaining `user` data
																delete data_user.cache[ elem[ data_user.expando ] ];
												}
								}
				} );

				jQuery.fn.extend( {
								text: function( value ) {
												return access( this, function( value ) {
																return value === undefined ?
																				jQuery.text( this ) :
																				this.empty().each( function() {
																								if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
																												this.textContent = value;
																								}
																				} );
												}, null, value, arguments.length );
								},

								append: function() {
												return this.domManip( arguments, function( elem ) {
																if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
																				var target = manipulationTarget( this, elem );
																				target.appendChild( elem );
																}
												} );
								},

								prepend: function() {
												return this.domManip( arguments, function( elem ) {
																if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
																				var target = manipulationTarget( this, elem );
																				target.insertBefore( elem, target.firstChild );
																}
												} );
								},

								before: function() {
												return this.domManip( arguments, function( elem ) {
																if ( this.parentNode ) {
																				this.parentNode.insertBefore( elem, this );
																}
												} );
								},

								after: function() {
												return this.domManip( arguments, function( elem ) {
																if ( this.parentNode ) {
																				this.parentNode.insertBefore( elem, this.nextSibling );
																}
												} );
								},

								remove: function( selector, keepData /* Internal Use Only */ ) {
												var elem,
																elems = selector ? jQuery.filter( selector, this ) : this,
																i = 0;

												for ( ;
																( elem = elems[ i ] ) != null; i++ ) {
																if ( !keepData && elem.nodeType === 1 ) {
																				jQuery.cleanData( getAll( elem ) );
																}

																if ( elem.parentNode ) {
																				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
																								setGlobalEval( getAll( elem, "script" ) );
																				}
																				elem.parentNode.removeChild( elem );
																}
												}

												return this;
								},

								empty: function() {
												var elem,
																i = 0;

												for ( ;
																( elem = this[ i ] ) != null; i++ ) {
																if ( elem.nodeType === 1 ) {

																				// Prevent memory leaks
																				jQuery.cleanData( getAll( elem, false ) );

																				// Remove any remaining nodes
																				elem.textContent = "";
																}
												}

												return this;
								},

								clone: function( dataAndEvents, deepDataAndEvents ) {
												dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
												deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

												return this.map( function() {
																return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
												} );
								},

								html: function( value ) {
												return access( this, function( value ) {
																var elem = this[ 0 ] || {},
																				i = 0,
																				l = this.length;

																if ( value === undefined && elem.nodeType === 1 ) {
																				return elem.innerHTML;
																}

																// See if we can take a shortcut and just use innerHTML
																if ( typeof value === "string" && !rnoInnerhtml.test( value ) && !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

																				value = value.replace( rxhtmlTag, "<$1></$2>" );

																				try {
																								for ( ; i < l; i++ ) {
																												elem = this[ i ] || {};

																												// Remove element nodes and prevent memory leaks
																												if ( elem.nodeType === 1 ) {
																																jQuery.cleanData( getAll( elem, false ) );
																																elem.innerHTML = value;
																												}
																								}

																								elem = 0;

																								// If using innerHTML throws an exception, use the fallback method
																				} catch ( e ) {}
																}

																if ( elem ) {
																				this.empty().append( value );
																}
												}, null, value, arguments.length );
								},

								replaceWith: function() {
												var arg = arguments[ 0 ];

												// Make the changes, replacing each context element with the new content
												this.domManip( arguments, function( elem ) {
																arg = this.parentNode;

																jQuery.cleanData( getAll( this ) );

																if ( arg ) {
																				arg.replaceChild( elem, this );
																}
												} );

												// Force removal if there was no new content (e.g., from empty arguments)
												return arg && ( arg.length || arg.nodeType ) ? this : this.remove();
								},

								detach: function( selector ) {
												return this.remove( selector, true );
								},

								domManip: function( args, callback ) {

												// Flatten any nested arrays
												args = concat.apply( [], args );

												var fragment, first, scripts, hasScripts, node, doc,
																i = 0,
																l = this.length,
																set = this,
																iNoClone = l - 1,
																value = args[ 0 ],
																isFunction = jQuery.isFunction( value );

												// We can't cloneNode fragments that contain checked, in WebKit
												if ( isFunction ||
																( l > 1 && typeof value === "string" && !support.checkClone && rchecked.test( value ) ) ) {
																return this.each( function( index ) {
																				var self = set.eq( index );
																				if ( isFunction ) {
																								args[ 0 ] = value.call( this, index, self.html() );
																				}
																				self.domManip( args, callback );
																} );
												}

												if ( l ) {
																fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
																first = fragment.firstChild;

																if ( fragment.childNodes.length === 1 ) {
																				fragment = first;
																}

																if ( first ) {
																				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
																				hasScripts = scripts.length;

																				// Use the original fragment for the last item instead of the first because it can end up
																				// being emptied incorrectly in certain situations (#8070).
																				for ( ; i < l; i++ ) {
																								node = fragment;

																								if ( i !== iNoClone ) {
																												node = jQuery.clone( node, true, true );

																												// Keep references to cloned scripts for later restoration
																												if ( hasScripts ) {
																																// Support: QtWebKit
																																// jQuery.merge because push.apply(_, arraylike) throws
																																jQuery.merge( scripts, getAll( node, "script" ) );
																												}
																								}

																								callback.call( this[ i ], node, i );
																				}

																				if ( hasScripts ) {
																								doc = scripts[ scripts.length - 1 ].ownerDocument;

																								// Reenable scripts
																								jQuery.map( scripts, restoreScript );

																								// Evaluate executable scripts on first document insertion
																								for ( i = 0; i < hasScripts; i++ ) {
																												node = scripts[ i ];
																												if ( rscriptType.test( node.type || "" ) && !data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

																																if ( node.src ) {
																																				// Optional AJAX dependency, but won't run scripts if not present
																																				if ( jQuery._evalUrl ) {
																																								jQuery._evalUrl( node.src );
																																				}
																																} else {
																																				jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
																																}
																												}
																								}
																				}
																}
												}

												return this;
								}
				} );

				jQuery.each( {
								appendTo: "append",
								prependTo: "prepend",
								insertBefore: "before",
								insertAfter: "after",
								replaceAll: "replaceWith"
				}, function( name, original ) {
								jQuery.fn[ name ] = function( selector ) {
												var elems,
																ret = [],
																insert = jQuery( selector ),
																last = insert.length - 1,
																i = 0;

												for ( ; i <= last; i++ ) {
																elems = i === last ? this : this.clone( true );
																jQuery( insert[ i ] )[ original ]( elems );

																// Support: QtWebKit
																// .get() because push.apply(_, arraylike) throws
																push.apply( ret, elems.get() );
												}

												return this.pushStack( ret );
								};
				} );


				var iframe,
								elemdisplay = {};

				/**
				 * Retrieve the actual display of a element
				 * @param {String} name nodeName of the element
				 * @param {Object} doc Document object
				 */
				// Called only from within defaultDisplay
				function actualDisplay( name, doc ) {
								var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

												// getDefaultComputedStyle might be reliably used only on attached element
												display = window.getDefaultComputedStyle ?

												// Use of this method is a temporary fix (more like optmization) until something better comes along,
												// since it was removed from specification and supported only in FF
												window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

								// We don't have any data stored on the element,
								// so use "detach" method as fast way to get rid of the element
								elem.detach();

								return display;
				}

				/**
				 * Try to determine the default display value of an element
				 * @param {String} nodeName
				 */
				function defaultDisplay( nodeName ) {
								var doc = document,
												display = elemdisplay[ nodeName ];

								if ( !display ) {
												display = actualDisplay( nodeName, doc );

												// If the simple way fails, read from inside an iframe
												if ( display === "none" || !display ) {

																// Use the already-created iframe if possible
																iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) ).appendTo( doc.documentElement );

																// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
																doc = iframe[ 0 ].contentDocument;

																// Support: IE
																doc.write();
																doc.close();

																display = actualDisplay( nodeName, doc );
																iframe.detach();
												}

												// Store the correct default display
												elemdisplay[ nodeName ] = display;
								}

								return display;
				}
				var rmargin = ( /^margin/ );

				var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

				var getStyles = function( elem ) {
								return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
				};



				function curCSS( elem, name, computed ) {
								var width, minWidth, maxWidth, ret,
												style = elem.style;

								computed = computed || getStyles( elem );

								// Support: IE9
								// getPropertyValue is only needed for .css('filter') in IE9, see #12537
								if ( computed ) {
												ret = computed.getPropertyValue( name ) || computed[ name ];
								}

								if ( computed ) {

												if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
																ret = jQuery.style( elem, name );
												}

												// Support: iOS < 6
												// A tribute to the "awesome hack by Dean Edwards"
												// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
												// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
												if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

																// Remember the original values
																width = style.width;
																minWidth = style.minWidth;
																maxWidth = style.maxWidth;

																// Put in the new values to get a computed value out
																style.minWidth = style.maxWidth = style.width = ret;
																ret = computed.width;

																// Revert the changed values
																style.width = width;
																style.minWidth = minWidth;
																style.maxWidth = maxWidth;
												}
								}

								return ret !== undefined ?
								// Support: IE
								// IE returns zIndex value as an integer.
								ret + "" :
												ret;
				}


				function addGetHookIf( conditionFn, hookFn ) {
								// Define the hook, we'll check on the first run if it's really needed.
								return {
												get: function() {
																if ( conditionFn() ) {
																				// Hook not needed (or it's not possible to use it due to missing dependency),
																				// remove it.
																				// Since there are no other hooks for marginRight, remove the whole object.
																				delete this.get;
																				return;
																}

																// Hook needed; redefine it so that the support test is not executed again.

																return ( this.get = hookFn ).apply( this, arguments );
												}
								};
				}


				( function() {
								var pixelPositionVal, boxSizingReliableVal,
												// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
												divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;" +
																"-moz-box-sizing:content-box;box-sizing:content-box",
												docElem = document.documentElement,
												container = document.createElement( "div" ),
												div = document.createElement( "div" );

								div.style.backgroundClip = "content-box";
								div.cloneNode( true ).style.backgroundClip = "";
								support.clearCloneStyle = div.style.backgroundClip === "content-box";

								container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;" +
												"margin-top:1px";
								container.appendChild( div );

								// Executing both pixelPosition & boxSizingReliable tests require only one layout
								// so they're executed at the same time to save the second computation.
								function computePixelPositionAndBoxSizingReliable() {
												// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
												div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
																"box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;" +
																"position:absolute;top:1%";
												docElem.appendChild( container );

												var divStyle = window.getComputedStyle( div, null );
												pixelPositionVal = divStyle.top !== "1%";
												boxSizingReliableVal = divStyle.width === "4px";

												docElem.removeChild( container );
								}

								// Use window.getComputedStyle because jsdom on node.js will break without it.
								if ( window.getComputedStyle ) {
												jQuery.extend( support, {
																pixelPosition: function() {
																				// This test is executed only once but we still do memoizing
																				// since we can use the boxSizingReliable pre-computing.
																				// No need to check if the test was already performed, though.
																				computePixelPositionAndBoxSizingReliable();
																				return pixelPositionVal;
																},
																boxSizingReliable: function() {
																				if ( boxSizingReliableVal == null ) {
																								computePixelPositionAndBoxSizingReliable();
																				}
																				return boxSizingReliableVal;
																},
																reliableMarginRight: function() {
																				// Support: Android 2.3
																				// Check if div with explicit width and no margin-right incorrectly
																				// gets computed margin-right based on width of container. (#3333)
																				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
																				// This support function is only executed once so no memoizing is needed.
																				var ret,
																								marginDiv = div.appendChild( document.createElement( "div" ) );
																				marginDiv.style.cssText = div.style.cssText = divReset;
																				marginDiv.style.marginRight = marginDiv.style.width = "0";
																				div.style.width = "1px";
																				docElem.appendChild( container );

																				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

																				docElem.removeChild( container );

																				// Clean up the div for other support tests.
																				div.innerHTML = "";

																				return ret;
																}
												} );
								}
				} )();


				// A method for quickly swapping in/out CSS properties to get correct calculations.
				jQuery.swap = function( elem, options, callback, args ) {
								var ret, name,
												old = {};

								// Remember the old values, and insert the new ones
								for ( name in options ) {
												old[ name ] = elem.style[ name ];
												elem.style[ name ] = options[ name ];
								}

								ret = callback.apply( elem, args || [] );

								// Revert the old values
								for ( name in options ) {
												elem.style[ name ] = old[ name ];
								}

								return ret;
				};


				var
				// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
				// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
				rdisplayswap = /^(none|table(?!-c[ea]).+)/,
								rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
								rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

								cssShow = {
												position: "absolute",
												visibility: "hidden",
												display: "block"
								},
								cssNormalTransform = {
												letterSpacing: 0,
												fontWeight: 400
								},

								cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

				// return a css property mapped to a potentially vendor prefixed property
				function vendorPropName( style, name ) {

								// shortcut for names that are not vendor prefixed
								if ( name in style ) {
												return name;
								}

								// check for vendor prefixed names
								var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
												origName = name,
												i = cssPrefixes.length;

								while ( i-- ) {
												name = cssPrefixes[ i ] + capName;
												if ( name in style ) {
																return name;
												}
								}

								return origName;
				}

				function setPositiveNumber( elem, value, subtract ) {
								var matches = rnumsplit.exec( value );
								return matches ?
								// Guard against undefined "subtract", e.g., when used as in cssHooks
								Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
												value;
				}

				function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
								var i = extra === ( isBorderBox ? "border" : "content" ) ?
								// If we already have the right measurement, avoid augmentation
								4 :
								// Otherwise initialize for horizontal or vertical properties
								name === "width" ? 1 : 0,

												val = 0;

								for ( ; i < 4; i += 2 ) {
												// both box models exclude margin, so add it if we want it
												if ( extra === "margin" ) {
																val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
												}

												if ( isBorderBox ) {
																// border-box includes padding, so remove it if we want content
																if ( extra === "content" ) {
																				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
																}

																// at this point, extra isn't border nor margin, so remove border
																if ( extra !== "margin" ) {
																				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
																}
												} else {
																// at this point, extra isn't content, so add padding
																val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

																// at this point, extra isn't content nor padding, so add border
																if ( extra !== "padding" ) {
																				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
																}
												}
								}

								return val;
				}

				function getWidthOrHeight( elem, name, extra ) {

								// Start with offset property, which is equivalent to the border-box value
								var valueIsBorderBox = true,
												val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
												styles = getStyles( elem ),
												isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

								// some non-html elements return undefined for offsetWidth, so check for null/undefined
								// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
								// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
								if ( val <= 0 || val == null ) {
												// Fall back to computed then uncomputed css if necessary
												val = curCSS( elem, name, styles );
												if ( val < 0 || val == null ) {
																val = elem.style[ name ];
												}

												// Computed unit is not pixels. Stop here and return.
												if ( rnumnonpx.test( val ) ) {
																return val;
												}

												// we need the check for style in case a browser which returns unreliable values
												// for getComputedStyle silently falls back to the reliable elem.style
												valueIsBorderBox = isBorderBox &&
																( support.boxSizingReliable() || val === elem.style[ name ] );

												// Normalize "", auto, and prepare for extra
												val = parseFloat( val ) || 0;
								}

								// use the active box-sizing model to add/subtract irrelevant styles
								return ( val +
												augmentWidthOrHeight(
																elem,
																name,
																extra || ( isBorderBox ? "border" : "content" ),
																valueIsBorderBox,
																styles
												)
								) + "px";
				}

				function showHide( elements, show ) {
								var display, elem, hidden,
												values = [],
												index = 0,
												length = elements.length;

								for ( ; index < length; index++ ) {
												elem = elements[ index ];
												if ( !elem.style ) {
																continue;
												}

												values[ index ] = data_priv.get( elem, "olddisplay" );
												display = elem.style.display;
												if ( show ) {
																// Reset the inline display of this element to learn if it is
																// being hidden by cascaded rules or not
																if ( !values[ index ] && display === "none" ) {
																				elem.style.display = "";
																}

																// Set elements which have been overridden with display: none
																// in a stylesheet to whatever the default browser style is
																// for such an element
																if ( elem.style.display === "" && isHidden( elem ) ) {
																				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay( elem.nodeName ) );
																}
												} else {

																if ( !values[ index ] ) {
																				hidden = isHidden( elem );

																				if ( display && display !== "none" || !hidden ) {
																								data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
																				}
																}
												}
								}

								// Set the display of most of the elements in a second loop
								// to avoid the constant reflow
								for ( index = 0; index < length; index++ ) {
												elem = elements[ index ];
												if ( !elem.style ) {
																continue;
												}
												if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
																elem.style.display = show ? values[ index ] || "" : "none";
												}
								}

								return elements;
				}

				jQuery.extend( {
								// Add in style property hooks for overriding the default
								// behavior of getting and setting a style property
								cssHooks: {
												opacity: {
																get: function( elem, computed ) {
																				if ( computed ) {
																								// We should always get a number back from opacity
																								var ret = curCSS( elem, "opacity" );
																								return ret === "" ? "1" : ret;
																				}
																}
												}
								},

								// Don't automatically add "px" to these possibly-unitless properties
								cssNumber: {
												"columnCount": true,
												"fillOpacity": true,
												"fontWeight": true,
												"lineHeight": true,
												"opacity": true,
												"order": true,
												"orphans": true,
												"widows": true,
												"zIndex": true,
												"zoom": true
								},

								// Add in properties whose names you wish to fix before
								// setting or getting the value
								cssProps: {
												// normalize float css property
												"float": "cssFloat"
								},

								// Get and set the style property on a DOM Node
								style: function( elem, name, value, extra ) {
												// Don't set styles on text and comment nodes
												if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
																return;
												}

												// Make sure that we're working with the right name
												var ret, type, hooks,
																origName = jQuery.camelCase( name ),
																style = elem.style;

												name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

												// gets hook for the prefixed version
												// followed by the unprefixed version
												hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

												// Check if we're setting a value
												if ( value !== undefined ) {
																type = typeof value;

																// convert relative number strings (+= or -=) to relative numbers. #7345
																if ( type === "string" && ( ret = rrelNum.exec( value ) ) ) {
																				value = ( ret[ 1 ] + 1 ) * ret[ 2 ] + parseFloat( jQuery.css( elem, name ) );
																				// Fixes bug #9237
																				type = "number";
																}

																// Make sure that null and NaN values aren't set. See: #7116
																if ( value == null || value !== value ) {
																				return;
																}

																// If a number was passed in, add 'px' to the (except for certain CSS properties)
																if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
																				value += "px";
																}

																// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
																// but it would mean to define eight (for every problematic property) identical functions
																if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
																				style[ name ] = "inherit";
																}

																// If a hook was provided, use that value, otherwise just set the specified value
																if ( !hooks || !( "set" in hooks ) || ( value = hooks.set( elem, value, extra ) ) !== undefined ) {
																				// Support: Chrome, Safari
																				// Setting style to blank string required to delete "style: x !important;"
																				style[ name ] = "";
																				style[ name ] = value;
																}

												} else {
																// If a hook was provided get the non-computed value from there
																if ( hooks && "get" in hooks && ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
																				return ret;
																}

																// Otherwise just get the value from the style object
																return style[ name ];
												}
								},

								css: function( elem, name, extra, styles ) {
												var val, num, hooks,
																origName = jQuery.camelCase( name );

												// Make sure that we're working with the right name
												name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

												// gets hook for the prefixed version
												// followed by the unprefixed version
												hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

												// If a hook was provided get the computed value from there
												if ( hooks && "get" in hooks ) {
																val = hooks.get( elem, true, extra );
												}

												// Otherwise, if a way to get the computed value exists, use that
												if ( val === undefined ) {
																val = curCSS( elem, name, styles );
												}

												//convert "normal" to computed value
												if ( val === "normal" && name in cssNormalTransform ) {
																val = cssNormalTransform[ name ];
												}

												// Return, converting to number if forced or a qualifier was provided and val looks numeric
												if ( extra === "" || extra ) {
																num = parseFloat( val );
																return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
												}
												return val;
								}
				} );

				jQuery.each( [ "height", "width" ], function( i, name ) {
								jQuery.cssHooks[ name ] = {
												get: function( elem, computed, extra ) {
																if ( computed ) {
																				// certain elements can have dimension info if we invisibly show them
																				// however, it must have a current display style that would benefit from this
																				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
																								jQuery.swap( elem, cssShow, function() {
																												return getWidthOrHeight( elem, name, extra );
																								} ) :
																								getWidthOrHeight( elem, name, extra );
																}
												},

												set: function( elem, value, extra ) {
																var styles = extra && getStyles( elem );
																return setPositiveNumber( elem, value, extra ?
																				augmentWidthOrHeight(
																								elem,
																								name,
																								extra,
																								jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
																								styles
																				) : 0
																);
												}
								};
				} );

				// Support: Android 2.3
				jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
								function( elem, computed ) {
												if ( computed ) {
																// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
																// Work around by temporarily setting element display to inline-block
																return jQuery.swap( elem, {
																								"display": "inline-block"
																				},
																				curCSS, [ elem, "marginRight" ] );
												}
								}
				);

				// These hooks are used by animate to expand properties
				jQuery.each( {
								margin: "",
								padding: "",
								border: "Width"
				}, function( prefix, suffix ) {
								jQuery.cssHooks[ prefix + suffix ] = {
												expand: function( value ) {
																var i = 0,
																				expanded = {},

																				// assumes a single number if not a string
																				parts = typeof value === "string" ? value.split( " " ) : [ value ];

																for ( ; i < 4; i++ ) {
																				expanded[ prefix + cssExpand[ i ] + suffix ] =
																								parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
																}

																return expanded;
												}
								};

								if ( !rmargin.test( prefix ) ) {
												jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
								}
				} );

				jQuery.fn.extend( {
								css: function( name, value ) {
												return access( this, function( elem, name, value ) {
																var styles, len,
																				map = {},
																				i = 0;

																if ( jQuery.isArray( name ) ) {
																				styles = getStyles( elem );
																				len = name.length;

																				for ( ; i < len; i++ ) {
																								map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
																				}

																				return map;
																}

																return value !== undefined ?
																				jQuery.style( elem, name, value ) :
																				jQuery.css( elem, name );
												}, name, value, arguments.length > 1 );
								},
								show: function() {
												return showHide( this, true );
								},
								hide: function() {
												return showHide( this );
								},
								toggle: function( state ) {
												if ( typeof state === "boolean" ) {
																return state ? this.show() : this.hide();
												}

												return this.each( function() {
																if ( isHidden( this ) ) {
																				jQuery( this ).show();
																} else {
																				jQuery( this ).hide();
																}
												} );
								}
				} );


				function Tween( elem, options, prop, end, easing ) {
								return new Tween.prototype.init( elem, options, prop, end, easing );
				}
				jQuery.Tween = Tween;

				Tween.prototype = {
								constructor: Tween,
								init: function( elem, options, prop, end, easing, unit ) {
												this.elem = elem;
												this.prop = prop;
												this.easing = easing || "swing";
												this.options = options;
												this.start = this.now = this.cur();
												this.end = end;
												this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
								},
								cur: function() {
												var hooks = Tween.propHooks[ this.prop ];

												return hooks && hooks.get ?
																hooks.get( this ) :
																Tween.propHooks._default.get( this );
								},
								run: function( percent ) {
												var eased,
																hooks = Tween.propHooks[ this.prop ];

												if ( this.options.duration ) {
																this.pos = eased = jQuery.easing[ this.easing ](
																				percent, this.options.duration * percent, 0, 1, this.options.duration
																);
												} else {
																this.pos = eased = percent;
												}
												this.now = ( this.end - this.start ) * eased + this.start;

												if ( this.options.step ) {
																this.options.step.call( this.elem, this.now, this );
												}

												if ( hooks && hooks.set ) {
																hooks.set( this );
												} else {
																Tween.propHooks._default.set( this );
												}
												return this;
								}
				};

				Tween.prototype.init.prototype = Tween.prototype;

				Tween.propHooks = {
								_default: {
												get: function( tween ) {
																var result;

																if ( tween.elem[ tween.prop ] != null &&
																				( !tween.elem.style || tween.elem.style[ tween.prop ] == null ) ) {
																				return tween.elem[ tween.prop ];
																}

																// passing an empty string as a 3rd parameter to .css will automatically
																// attempt a parseFloat and fallback to a string if the parse fails
																// so, simple values such as "10px" are parsed to Float.
																// complex values such as "rotate(1rad)" are returned as is.
																result = jQuery.css( tween.elem, tween.prop, "" );
																// Empty strings, null, undefined and "auto" are converted to 0.
																return !result || result === "auto" ? 0 : result;
												},
												set: function( tween ) {
																// use step hook for back compat - use cssHook if its there - use .style if its
																// available and use plain properties where available
																if ( jQuery.fx.step[ tween.prop ] ) {
																				jQuery.fx.step[ tween.prop ]( tween );
																} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
																				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
																} else {
																				tween.elem[ tween.prop ] = tween.now;
																}
												}
								}
				};

				// Support: IE9
				// Panic based approach to setting things on disconnected nodes

				Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
								set: function( tween ) {
												if ( tween.elem.nodeType && tween.elem.parentNode ) {
																tween.elem[ tween.prop ] = tween.now;
												}
								}
				};

				jQuery.easing = {
								linear: function( p ) {
												return p;
								},
								swing: function( p ) {
												return 0.5 - Math.cos( p * Math.PI ) / 2;
								}
				};

				jQuery.fx = Tween.prototype.init;

				// Back Compat <1.8 extension point
				jQuery.fx.step = {};



				var
				fxNow, timerId,
								rfxtypes = /^(?:toggle|show|hide)$/,
								rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
								rrun = /queueHooks$/,
								animationPrefilters = [ defaultPrefilter ],
								tweeners = {
												"*": [
																function( prop, value ) {
																				var tween = this.createTween( prop, value ),
																								target = tween.cur(),
																								parts = rfxnum.exec( value ),
																								unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

																								// Starting value computation is required for potential unit mismatches
																								start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
																												rfxnum.exec( jQuery.css( tween.elem, prop ) ),
																								scale = 1,
																								maxIterations = 20;

																				if ( start && start[ 3 ] !== unit ) {
																								// Trust units reported by jQuery.css
																								unit = unit || start[ 3 ];

																								// Make sure we update the tween properties later on
																								parts = parts || [];

																								// Iteratively approximate from a nonzero starting point
																								start = +target || 1;

																								do {
																												// If previous iteration zeroed out, double until we get *something*
																												// Use a string for doubling factor so we don't accidentally see scale as unchanged below
																												scale = scale || ".5";

																												// Adjust and apply
																												start = start / scale;
																												jQuery.style( tween.elem, prop, start + unit );

																												// Update scale, tolerating zero or NaN from tween.cur()
																												// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
																								} while ( scale !== ( scale = tween.cur() / target ) && scale !== 1 && --maxIterations );
																				}

																				// Update tween properties
																				if ( parts ) {
																								start = tween.start = +start || +target || 0;
																								tween.unit = unit;
																								// If a +=/-= token was provided, we're doing a relative animation
																								tween.end = parts[ 1 ] ?
																												start + ( parts[ 1 ] + 1 ) * parts[ 2 ] : +parts[ 2 ];
																				}

																				return tween;
																}
												]
								};

				// Animations created synchronously will run synchronously
				function createFxNow() {
								setTimeout( function() {
												fxNow = undefined;
								} );
								return ( fxNow = jQuery.now() );
				}

				// Generate parameters to create a standard animation
				function genFx( type, includeWidth ) {
								var which,
												i = 0,
												attrs = {
																height: type
												};

								// if we include width, step value is 1 to do all cssExpand values,
								// if we don't include width, step value is 2 to skip over Left and Right
								includeWidth = includeWidth ? 1 : 0;
								for ( ; i < 4; i += 2 - includeWidth ) {
												which = cssExpand[ i ];
												attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
								}

								if ( includeWidth ) {
												attrs.opacity = attrs.width = type;
								}

								return attrs;
				}

				function createTween( value, prop, animation ) {
								var tween,
												collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
												index = 0,
												length = collection.length;
								for ( ; index < length; index++ ) {
												if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

																// we're done with this property
																return tween;
												}
								}
				}

				function defaultPrefilter( elem, props, opts ) {
								/* jshint validthis: true */
								var prop, value, toggle, tween, hooks, oldfire, display,
												anim = this,
												orig = {},
												style = elem.style,
												hidden = elem.nodeType && isHidden( elem ),
												dataShow = data_priv.get( elem, "fxshow" );

								// handle queue: false promises
								if ( !opts.queue ) {
												hooks = jQuery._queueHooks( elem, "fx" );
												if ( hooks.unqueued == null ) {
																hooks.unqueued = 0;
																oldfire = hooks.empty.fire;
																hooks.empty.fire = function() {
																				if ( !hooks.unqueued ) {
																								oldfire();
																				}
																};
												}
												hooks.unqueued++;

												anim.always( function() {
																// doing this makes sure that the complete handler will be called
																// before this completes
																anim.always( function() {
																				hooks.unqueued--;
																				if ( !jQuery.queue( elem, "fx" ).length ) {
																								hooks.empty.fire();
																				}
																} );
												} );
								}

								// height/width overflow pass
								if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
												// Make sure that nothing sneaks out
												// Record all 3 overflow attributes because IE9-10 do not
												// change the overflow attribute when overflowX and
												// overflowY are set to the same value
												opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

												// Set display property to inline-block for height/width
												// animations on inline elements that are having width/height animated
												display = jQuery.css( elem, "display" );
												// Get default display if display is currently "none"
												if ( display === "none" ) {
																display = defaultDisplay( elem.nodeName );
												}
												if ( display === "inline" &&
																jQuery.css( elem, "float" ) === "none" ) {

																style.display = "inline-block";
												}
								}

								if ( opts.overflow ) {
												style.overflow = "hidden";
												anim.always( function() {
																style.overflow = opts.overflow[ 0 ];
																style.overflowX = opts.overflow[ 1 ];
																style.overflowY = opts.overflow[ 2 ];
												} );
								}

								// show/hide pass
								for ( prop in props ) {
												value = props[ prop ];
												if ( rfxtypes.exec( value ) ) {
																delete props[ prop ];
																toggle = toggle || value === "toggle";
																if ( value === ( hidden ? "hide" : "show" ) ) {

																				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
																				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
																								hidden = true;
																				} else {
																								continue;
																				}
																}
																orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
												}
								}

								if ( !jQuery.isEmptyObject( orig ) ) {
												if ( dataShow ) {
																if ( "hidden" in dataShow ) {
																				hidden = dataShow.hidden;
																}
												} else {
																dataShow = data_priv.access( elem, "fxshow", {} );
												}

												// store state if its toggle - enables .stop().toggle() to "reverse"
												if ( toggle ) {
																dataShow.hidden = !hidden;
												}
												if ( hidden ) {
																jQuery( elem ).show();
												} else {
																anim.done( function() {
																				jQuery( elem ).hide();
																} );
												}
												anim.done( function() {
																var prop;

																data_priv.remove( elem, "fxshow" );
																for ( prop in orig ) {
																				jQuery.style( elem, prop, orig[ prop ] );
																}
												} );
												for ( prop in orig ) {
																tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

																if ( !( prop in dataShow ) ) {
																				dataShow[ prop ] = tween.start;
																				if ( hidden ) {
																								tween.end = tween.start;
																								tween.start = prop === "width" || prop === "height" ? 1 : 0;
																				}
																}
												}
								}
				}

				function propFilter( props, specialEasing ) {
								var index, name, easing, value, hooks;

								// camelCase, specialEasing and expand cssHook pass
								for ( index in props ) {
												name = jQuery.camelCase( index );
												easing = specialEasing[ name ];
												value = props[ index ];
												if ( jQuery.isArray( value ) ) {
																easing = value[ 1 ];
																value = props[ index ] = value[ 0 ];
												}

												if ( index !== name ) {
																props[ name ] = value;
																delete props[ index ];
												}

												hooks = jQuery.cssHooks[ name ];
												if ( hooks && "expand" in hooks ) {
																value = hooks.expand( value );
																delete props[ name ];

																// not quite $.extend, this wont overwrite keys already present.
																// also - reusing 'index' from above because we have the correct "name"
																for ( index in value ) {
																				if ( !( index in props ) ) {
																								props[ index ] = value[ index ];
																								specialEasing[ index ] = easing;
																				}
																}
												} else {
																specialEasing[ name ] = easing;
												}
								}
				}

				function Animation( elem, properties, options ) {
								var result,
												stopped,
												index = 0,
												length = animationPrefilters.length,
												deferred = jQuery.Deferred().always( function() {
																// don't match elem in the :animated selector
																delete tick.elem;
												} ),
												tick = function() {
																if ( stopped ) {
																				return false;
																}
																var currentTime = fxNow || createFxNow(),
																				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
																				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
																				temp = remaining / animation.duration || 0,
																				percent = 1 - temp,
																				index = 0,
																				length = animation.tweens.length;

																for ( ; index < length; index++ ) {
																				animation.tweens[ index ].run( percent );
																}

																deferred.notifyWith( elem, [ animation, percent, remaining ] );

																if ( percent < 1 && length ) {
																				return remaining;
																} else {
																				deferred.resolveWith( elem, [ animation ] );
																				return false;
																}
												},
												animation = deferred.promise( {
																elem: elem,
																props: jQuery.extend( {}, properties ),
																opts: jQuery.extend( true, {
																				specialEasing: {}
																}, options ),
																originalProperties: properties,
																originalOptions: options,
																startTime: fxNow || createFxNow(),
																duration: options.duration,
																tweens: [],
																createTween: function( prop, end ) {
																				var tween = jQuery.Tween( elem, animation.opts, prop, end,
																								animation.opts.specialEasing[ prop ] || animation.opts.easing );
																				animation.tweens.push( tween );
																				return tween;
																},
																stop: function( gotoEnd ) {
																				var index = 0,
																								// if we are going to the end, we want to run all the tweens
																								// otherwise we skip this part
																								length = gotoEnd ? animation.tweens.length : 0;
																				if ( stopped ) {
																								return this;
																				}
																				stopped = true;
																				for ( ; index < length; index++ ) {
																								animation.tweens[ index ].run( 1 );
																				}

																				// resolve when we played the last frame
																				// otherwise, reject
																				if ( gotoEnd ) {
																								deferred.resolveWith( elem, [ animation, gotoEnd ] );
																				} else {
																								deferred.rejectWith( elem, [ animation, gotoEnd ] );
																				}
																				return this;
																}
												} ),
												props = animation.props;

								propFilter( props, animation.opts.specialEasing );

								for ( ; index < length; index++ ) {
												result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
												if ( result ) {
																return result;
												}
								}

								jQuery.map( props, createTween, animation );

								if ( jQuery.isFunction( animation.opts.start ) ) {
												animation.opts.start.call( elem, animation );
								}

								jQuery.fx.timer(
												jQuery.extend( tick, {
																elem: elem,
																anim: animation,
																queue: animation.opts.queue
												} )
								);

								// attach callbacks from options
								return animation.progress( animation.opts.progress )
												.done( animation.opts.done, animation.opts.complete )
												.fail( animation.opts.fail )
												.always( animation.opts.always );
				}

				jQuery.Animation = jQuery.extend( Animation, {

								tweener: function( props, callback ) {
												if ( jQuery.isFunction( props ) ) {
																callback = props;
																props = [ "*" ];
												} else {
																props = props.split( " " );
												}

												var prop,
																index = 0,
																length = props.length;

												for ( ; index < length; index++ ) {
																prop = props[ index ];
																tweeners[ prop ] = tweeners[ prop ] || [];
																tweeners[ prop ].unshift( callback );
												}
								},

								prefilter: function( callback, prepend ) {
												if ( prepend ) {
																animationPrefilters.unshift( callback );
												} else {
																animationPrefilters.push( callback );
												}
								}
				} );

				jQuery.speed = function( speed, easing, fn ) {
								var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
												complete: fn || !fn && easing ||
																jQuery.isFunction( speed ) && speed,
												duration: speed,
												easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
								};

								opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
												opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

								// normalize opt.queue - true/undefined/null -> "fx"
								if ( opt.queue == null || opt.queue === true ) {
												opt.queue = "fx";
								}

								// Queueing
								opt.old = opt.complete;

								opt.complete = function() {
												if ( jQuery.isFunction( opt.old ) ) {
																opt.old.call( this );
												}

												if ( opt.queue ) {
																jQuery.dequeue( this, opt.queue );
												}
								};

								return opt;
				};

				jQuery.fn.extend( {
								fadeTo: function( speed, to, easing, callback ) {

												// show any hidden elements after setting opacity to 0
												return this.filter( isHidden ).css( "opacity", 0 ).show()

												// animate to the value specified
												.end().animate( {
																opacity: to
												}, speed, easing, callback );
								},
								animate: function( prop, speed, easing, callback ) {
												var empty = jQuery.isEmptyObject( prop ),
																optall = jQuery.speed( speed, easing, callback ),
																doAnimation = function() {
																				// Operate on a copy of prop so per-property easing won't be lost
																				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

																				// Empty animations, or finishing resolves immediately
																				if ( empty || data_priv.get( this, "finish" ) ) {
																								anim.stop( true );
																				}
																};
												doAnimation.finish = doAnimation;

												return empty || optall.queue === false ?
																this.each( doAnimation ) :
																this.queue( optall.queue, doAnimation );
								},
								stop: function( type, clearQueue, gotoEnd ) {
												var stopQueue = function( hooks ) {
																var stop = hooks.stop;
																delete hooks.stop;
																stop( gotoEnd );
												};

												if ( typeof type !== "string" ) {
																gotoEnd = clearQueue;
																clearQueue = type;
																type = undefined;
												}
												if ( clearQueue && type !== false ) {
																this.queue( type || "fx", [] );
												}

												return this.each( function() {
																var dequeue = true,
																				index = type != null && type + "queueHooks",
																				timers = jQuery.timers,
																				data = data_priv.get( this );

																if ( index ) {
																				if ( data[ index ] && data[ index ].stop ) {
																								stopQueue( data[ index ] );
																				}
																} else {
																				for ( index in data ) {
																								if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
																												stopQueue( data[ index ] );
																								}
																				}
																}

																for ( index = timers.length; index--; ) {
																				if ( timers[ index ].elem === this && ( type == null || timers[ index ].queue === type ) ) {
																								timers[ index ].anim.stop( gotoEnd );
																								dequeue = false;
																								timers.splice( index, 1 );
																				}
																}

																// start the next in the queue if the last step wasn't forced
																// timers currently will call their complete callbacks, which will dequeue
																// but only if they were gotoEnd
																if ( dequeue || !gotoEnd ) {
																				jQuery.dequeue( this, type );
																}
												} );
								},
								finish: function( type ) {
												if ( type !== false ) {
																type = type || "fx";
												}
												return this.each( function() {
																var index,
																				data = data_priv.get( this ),
																				queue = data[ type + "queue" ],
																				hooks = data[ type + "queueHooks" ],
																				timers = jQuery.timers,
																				length = queue ? queue.length : 0;

																// enable finishing flag on private data
																data.finish = true;

																// empty the queue first
																jQuery.queue( this, type, [] );

																if ( hooks && hooks.stop ) {
																				hooks.stop.call( this, true );
																}

																// look for any active animations, and finish them
																for ( index = timers.length; index--; ) {
																				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
																								timers[ index ].anim.stop( true );
																								timers.splice( index, 1 );
																				}
																}

																// look for any animations in the old queue and finish them
																for ( index = 0; index < length; index++ ) {
																				if ( queue[ index ] && queue[ index ].finish ) {
																								queue[ index ].finish.call( this );
																				}
																}

																// turn off finishing flag
																delete data.finish;
												} );
								}
				} );

				jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
								var cssFn = jQuery.fn[ name ];
								jQuery.fn[ name ] = function( speed, easing, callback ) {
												return speed == null || typeof speed === "boolean" ?
																cssFn.apply( this, arguments ) :
																this.animate( genFx( name, true ), speed, easing, callback );
								};
				} );

				// Generate shortcuts for custom animations
				jQuery.each( {
								slideDown: genFx( "show" ),
								slideUp: genFx( "hide" ),
								slideToggle: genFx( "toggle" ),
								fadeIn: {
												opacity: "show"
								},
								fadeOut: {
												opacity: "hide"
								},
								fadeToggle: {
												opacity: "toggle"
								}
				}, function( name, props ) {
								jQuery.fn[ name ] = function( speed, easing, callback ) {
												return this.animate( props, speed, easing, callback );
								};
				} );

				jQuery.timers = [];
				jQuery.fx.tick = function() {
								var timer,
												i = 0,
												timers = jQuery.timers;

								fxNow = jQuery.now();

								for ( ; i < timers.length; i++ ) {
												timer = timers[ i ];
												// Checks the timer has not already been removed
												if ( !timer() && timers[ i ] === timer ) {
																timers.splice( i--, 1 );
												}
								}

								if ( !timers.length ) {
												jQuery.fx.stop();
								}
								fxNow = undefined;
				};

				jQuery.fx.timer = function( timer ) {
								jQuery.timers.push( timer );
								if ( timer() ) {
												jQuery.fx.start();
								} else {
												jQuery.timers.pop();
								}
				};

				jQuery.fx.interval = 13;

				jQuery.fx.start = function() {
								if ( !timerId ) {
												timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
								}
				};

				jQuery.fx.stop = function() {
								clearInterval( timerId );
								timerId = null;
				};

				jQuery.fx.speeds = {
								slow: 600,
								fast: 200,
								// Default speed
								_default: 400
				};


				// Based off of the plugin by Clint Helfers, with permission.
				// http://blindsignals.com/index.php/2009/07/jquery-delay/
				jQuery.fn.delay = function( time, type ) {
								time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
								type = type || "fx";

								return this.queue( type, function( next, hooks ) {
												var timeout = setTimeout( next, time );
												hooks.stop = function() {
																clearTimeout( timeout );
												};
								} );
				};


				( function() {
								var input = document.createElement( "input" ),
												select = document.createElement( "select" ),
												opt = select.appendChild( document.createElement( "option" ) );

								input.type = "checkbox";

								// Support: iOS 5.1, Android 4.x, Android 2.3
								// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
								support.checkOn = input.value !== "";

								// Must access the parent to make an option select properly
								// Support: IE9, IE10
								support.optSelected = opt.selected;

								// Make sure that the options inside disabled selects aren't marked as disabled
								// (WebKit marks them as disabled)
								select.disabled = true;
								support.optDisabled = !opt.disabled;

								// Check if an input maintains its value after becoming a radio
								// Support: IE9, IE10
								input = document.createElement( "input" );
								input.value = "t";
								input.type = "radio";
								support.radioValue = input.value === "t";
				} )();


				var nodeHook, boolHook,
								attrHandle = jQuery.expr.attrHandle;

				jQuery.fn.extend( {
								attr: function( name, value ) {
												return access( this, jQuery.attr, name, value, arguments.length > 1 );
								},

								removeAttr: function( name ) {
												return this.each( function() {
																jQuery.removeAttr( this, name );
												} );
								}
				} );

				jQuery.extend( {
								attr: function( elem, name, value ) {
												var hooks, ret,
																nType = elem.nodeType;

												// don't get/set attributes on text, comment and attribute nodes
												if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
																return;
												}

												// Fallback to prop when attributes are not supported
												if ( typeof elem.getAttribute === strundefined ) {
																return jQuery.prop( elem, name, value );
												}

												// All attributes are lowercase
												// Grab necessary hook if one is defined
												if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
																name = name.toLowerCase();
																hooks = jQuery.attrHooks[ name ] ||
																				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
												}

												if ( value !== undefined ) {

																if ( value === null ) {
																				jQuery.removeAttr( elem, name );

																} else if ( hooks && "set" in hooks && ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
																				return ret;

																} else {
																				elem.setAttribute( name, value + "" );
																				return value;
																}

												} else if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
																return ret;

												} else {
																ret = jQuery.find.attr( elem, name );

																// Non-existent attributes return null, we normalize to undefined
																return ret == null ?
																				undefined :
																				ret;
												}
								},

								removeAttr: function( elem, value ) {
												var name, propName,
																i = 0,
																attrNames = value && value.match( rnotwhite );

												if ( attrNames && elem.nodeType === 1 ) {
																while ( ( name = attrNames[ i++ ] ) ) {
																				propName = jQuery.propFix[ name ] || name;

																				// Boolean attributes get special treatment (#10870)
																				if ( jQuery.expr.match.bool.test( name ) ) {
																								// Set corresponding property to false
																								elem[ propName ] = false;
																				}

																				elem.removeAttribute( name );
																}
												}
								},

								attrHooks: {
												type: {
																set: function( elem, value ) {
																				if ( !support.radioValue && value === "radio" &&
																								jQuery.nodeName( elem, "input" ) ) {
																								// Setting the type on a radio button after the value resets the value in IE6-9
																								// Reset value to default in case type is set after value during creation
																								var val = elem.value;
																								elem.setAttribute( "type", value );
																								if ( val ) {
																												elem.value = val;
																								}
																								return value;
																				}
																}
												}
								}
				} );

				// Hooks for boolean attributes
				boolHook = {
								set: function( elem, value, name ) {
												if ( value === false ) {
																// Remove boolean attributes when set to false
																jQuery.removeAttr( elem, name );
												} else {
																elem.setAttribute( name, name );
												}
												return name;
								}
				};
				jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
								var getter = attrHandle[ name ] || jQuery.find.attr;

								attrHandle[ name ] = function( elem, name, isXML ) {
												var ret, handle;
												if ( !isXML ) {
																// Avoid an infinite loop by temporarily removing this function from the getter
																handle = attrHandle[ name ];
																attrHandle[ name ] = ret;
																ret = getter( elem, name, isXML ) != null ?
																				name.toLowerCase() :
																				null;
																attrHandle[ name ] = handle;
												}
												return ret;
								};
				} );



				var rfocusable = /^(?:input|select|textarea|button)$/i;

				jQuery.fn.extend( {
								prop: function( name, value ) {
												return access( this, jQuery.prop, name, value, arguments.length > 1 );
								},

								removeProp: function( name ) {
												return this.each( function() {
																delete this[ jQuery.propFix[ name ] || name ];
												} );
								}
				} );

				jQuery.extend( {
								propFix: {
												"for": "htmlFor",
												"class": "className"
								},

								prop: function( elem, name, value ) {
												var ret, hooks, notxml,
																nType = elem.nodeType;

												// don't get/set properties on text, comment and attribute nodes
												if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
																return;
												}

												notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

												if ( notxml ) {
																// Fix name and attach hooks
																name = jQuery.propFix[ name ] || name;
																hooks = jQuery.propHooks[ name ];
												}

												if ( value !== undefined ) {
																return hooks && "set" in hooks && ( ret = hooks.set( elem, value, name ) ) !== undefined ?
																				ret :
																				( elem[ name ] = value );

												} else {
																return hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ?
																				ret :
																				elem[ name ];
												}
								},

								propHooks: {
												tabIndex: {
																get: function( elem ) {
																				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
																								elem.tabIndex : -1;
																}
												}
								}
				} );

				// Support: IE9+
				// Selectedness for an option in an optgroup can be inaccurate
				if ( !support.optSelected ) {
								jQuery.propHooks.selected = {
												get: function( elem ) {
																var parent = elem.parentNode;
																if ( parent && parent.parentNode ) {
																				parent.parentNode.selectedIndex;
																}
																return null;
												}
								};
				}

				jQuery.each( [
								"tabIndex",
								"readOnly",
								"maxLength",
								"cellSpacing",
								"cellPadding",
								"rowSpan",
								"colSpan",
								"useMap",
								"frameBorder",
								"contentEditable"
				], function() {
								jQuery.propFix[ this.toLowerCase() ] = this;
				} );



				var rclass = /[\t\r\n\f]/g;

				jQuery.fn.extend( {
								addClass: function( value ) {
												var classes, elem, cur, clazz, j, finalValue,
																proceed = typeof value === "string" && value,
																i = 0,
																len = this.length;

												if ( jQuery.isFunction( value ) ) {
																return this.each( function( j ) {
																				jQuery( this ).addClass( value.call( this, j, this.className ) );
																} );
												}

												if ( proceed ) {
																// The disjunction here is for better compressibility (see removeClass)
																classes = ( value || "" ).match( rnotwhite ) || [];

																for ( ; i < len; i++ ) {
																				elem = this[ i ];
																				cur = elem.nodeType === 1 && ( elem.className ?
																								( " " + elem.className + " " ).replace( rclass, " " ) :
																								" "
																				);

																				if ( cur ) {
																								j = 0;
																								while ( ( clazz = classes[ j++ ] ) ) {
																												if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
																																cur += clazz + " ";
																												}
																								}

																								// only assign if different to avoid unneeded rendering.
																								finalValue = jQuery.trim( cur );
																								if ( elem.className !== finalValue ) {
																												elem.className = finalValue;
																								}
																				}
																}
												}

												return this;
								},

								removeClass: function( value ) {
												var classes, elem, cur, clazz, j, finalValue,
																proceed = arguments.length === 0 || typeof value === "string" && value,
																i = 0,
																len = this.length;

												if ( jQuery.isFunction( value ) ) {
																return this.each( function( j ) {
																				jQuery( this ).removeClass( value.call( this, j, this.className ) );
																} );
												}
												if ( proceed ) {
																classes = ( value || "" ).match( rnotwhite ) || [];

																for ( ; i < len; i++ ) {
																				elem = this[ i ];
																				// This expression is here for better compressibility (see addClass)
																				cur = elem.nodeType === 1 && ( elem.className ?
																								( " " + elem.className + " " ).replace( rclass, " " ) :
																								""
																				);

																				if ( cur ) {
																								j = 0;
																								while ( ( clazz = classes[ j++ ] ) ) {
																												// Remove *all* instances
																												while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
																																cur = cur.replace( " " + clazz + " ", " " );
																												}
																								}

																								// only assign if different to avoid unneeded rendering.
																								finalValue = value ? jQuery.trim( cur ) : "";
																								if ( elem.className !== finalValue ) {
																												elem.className = finalValue;
																								}
																				}
																}
												}

												return this;
								},

								toggleClass: function( value, stateVal ) {
												var type = typeof value;

												if ( typeof stateVal === "boolean" && type === "string" ) {
																return stateVal ? this.addClass( value ) : this.removeClass( value );
												}

												if ( jQuery.isFunction( value ) ) {
																return this.each( function( i ) {
																				jQuery( this ).toggleClass( value.call( this, i, this.className, stateVal ), stateVal );
																} );
												}

												return this.each( function() {
																if ( type === "string" ) {
																				// toggle individual class names
																				var className,
																								i = 0,
																								self = jQuery( this ),
																								classNames = value.match( rnotwhite ) || [];

																				while ( ( className = classNames[ i++ ] ) ) {
																								// check each className given, space separated list
																								if ( self.hasClass( className ) ) {
																												self.removeClass( className );
																								} else {
																												self.addClass( className );
																								}
																				}

																				// Toggle whole class name
																} else if ( type === strundefined || type === "boolean" ) {
																				if ( this.className ) {
																								// store className if set
																								data_priv.set( this, "__className__", this.className );
																				}

																				// If the element has a class name or if we're passed "false",
																				// then remove the whole classname (if there was one, the above saved it).
																				// Otherwise bring back whatever was previously saved (if anything),
																				// falling back to the empty string if nothing was stored.
																				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
																}
												} );
								},

								hasClass: function( selector ) {
												var className = " " + selector + " ",
																i = 0,
																l = this.length;
												for ( ; i < l; i++ ) {
																if ( this[ i ].nodeType === 1 && ( " " + this[ i ].className + " " ).replace( rclass, " " ).indexOf( className ) >= 0 ) {
																				return true;
																}
												}

												return false;
								}
				} );



				var rreturn = /\r/g;

				jQuery.fn.extend( {
								val: function( value ) {
												var hooks, ret, isFunction,
																elem = this[ 0 ];

												if ( !arguments.length ) {
																if ( elem ) {
																				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

																				if ( hooks && "get" in hooks && ( ret = hooks.get( elem, "value" ) ) !== undefined ) {
																								return ret;
																				}

																				ret = elem.value;

																				return typeof ret === "string" ?
																				// handle most common string cases
																				ret.replace( rreturn, "" ) :
																				// handle cases where value is null/undef or number
																				ret == null ? "" : ret;
																}

																return;
												}

												isFunction = jQuery.isFunction( value );

												return this.each( function( i ) {
																var val;

																if ( this.nodeType !== 1 ) {
																				return;
																}

																if ( isFunction ) {
																				val = value.call( this, i, jQuery( this ).val() );
																} else {
																				val = value;
																}

																// Treat null/undefined as ""; convert numbers to string
																if ( val == null ) {
																				val = "";

																} else if ( typeof val === "number" ) {
																				val += "";

																} else if ( jQuery.isArray( val ) ) {
																				val = jQuery.map( val, function( value ) {
																								return value == null ? "" : value + "";
																				} );
																}

																hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

																// If set returns undefined, fall back to normal setting
																if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
																				this.value = val;
																}
												} );
								}
				} );

				jQuery.extend( {
								valHooks: {
												select: {
																get: function( elem ) {
																				var value, option,
																								options = elem.options,
																								index = elem.selectedIndex,
																								one = elem.type === "select-one" || index < 0,
																								values = one ? null : [],
																								max = one ? index + 1 : options.length,
																								i = index < 0 ?
																												max :
																												one ? index : 0;

																				// Loop through all the selected options
																				for ( ; i < max; i++ ) {
																								option = options[ i ];

																								// IE6-9 doesn't update selected after form reset (#2551)
																								if ( ( option.selected || i === index ) &&
																												// Don't return options that are disabled or in a disabled optgroup
																												( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
																												( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

																												// Get the specific value for the option
																												value = jQuery( option ).val();

																												// We don't need an array for one selects
																												if ( one ) {
																																return value;
																												}

																												// Multi-Selects return an array
																												values.push( value );
																								}
																				}

																				return values;
																},

																set: function( elem, value ) {
																				var optionSet, option,
																								options = elem.options,
																								values = jQuery.makeArray( value ),
																								i = options.length;

																				while ( i-- ) {
																								option = options[ i ];
																								if ( ( option.selected = jQuery.inArray( jQuery( option ).val(), values ) >= 0 ) ) {
																												optionSet = true;
																								}
																				}

																				// force browsers to behave consistently when non-matching value is set
																				if ( !optionSet ) {
																								elem.selectedIndex = -1;
																				}
																				return values;
																}
												}
								}
				} );

				// Radios and checkboxes getter/setter
				jQuery.each( [ "radio", "checkbox" ], function() {
								jQuery.valHooks[ this ] = {
												set: function( elem, value ) {
																if ( jQuery.isArray( value ) ) {
																				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) >= 0 );
																}
												}
								};
								if ( !support.checkOn ) {
												jQuery.valHooks[ this ].get = function( elem ) {
																// Support: Webkit
																// "" is returned instead of "on" if a value isn't specified
																return elem.getAttribute( "value" ) === null ? "on" : elem.value;
												};
								}
				} );



				// Return jQuery for attributes-only inclusion


				jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
								"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
								"change select submit keydown keypress keyup error contextmenu" ).split( " " ), function( i, name ) {

								// Handle event binding
								jQuery.fn[ name ] = function( data, fn ) {
												return arguments.length > 0 ?
																this.on( name, null, data, fn ) :
																this.trigger( name );
								};
				} );

				jQuery.fn.extend( {
								hover: function( fnOver, fnOut ) {
												return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
								},

								bind: function( types, data, fn ) {
												return this.on( types, null, data, fn );
								},
								unbind: function( types, fn ) {
												return this.off( types, null, fn );
								},

								delegate: function( selector, types, data, fn ) {
												return this.on( types, selector, data, fn );
								},
								undelegate: function( selector, types, fn ) {
												// ( namespace ) or ( selector, types [, fn] )
												return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
								}
				} );


				var nonce = jQuery.now();

				var rquery = ( /\?/ );



				// Support: Android 2.3
				// Workaround failure to string-cast null input
				jQuery.parseJSON = function( data ) {
								return JSON.parse( data + "" );
				};


				// Cross-browser xml parsing
				jQuery.parseXML = function( data ) {
								var xml, tmp;
								if ( !data || typeof data !== "string" ) {
												return null;
								}

								// Support: IE9
								try {
												tmp = new DOMParser();
												xml = tmp.parseFromString( data, "text/xml" );
								} catch ( e ) {
												xml = undefined;
								}

								if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
												jQuery.error( "Invalid XML: " + data );
								}
								return xml;
				};


				var
				// Document location
				ajaxLocParts,
								ajaxLocation,

								rhash = /#.*$/,
								rts = /([?&])_=[^&]*/,
								rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
								// #7653, #8125, #8152: local protocol detection
								rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
								rnoContent = /^(?:GET|HEAD)$/,
								rprotocol = /^\/\//,
								rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

								/* Prefilters
								 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
								 * 2) These are called:
								 *    - BEFORE asking for a transport
								 *    - AFTER param serialization (s.data is a string if s.processData is true)
								 * 3) key is the dataType
								 * 4) the catchall symbol "*" can be used
								 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
								 */
								prefilters = {},

								/* Transports bindings
								 * 1) key is the dataType
								 * 2) the catchall symbol "*" can be used
								 * 3) selection will start with transport dataType and THEN go to "*" if needed
								 */
								transports = {},

								// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
								allTypes = "*/".concat( "*" );

				// #8138, IE may throw an exception when accessing
				// a field from window.location if document.domain has been set
				try {
								ajaxLocation = location.href;
				} catch ( e ) {
								// Use the href attribute of an A element
								// since IE will modify it given document.location
								ajaxLocation = document.createElement( "a" );
								ajaxLocation.href = "";
								ajaxLocation = ajaxLocation.href;
				}

				// Segment location into parts
				ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

				// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
				function addToPrefiltersOrTransports( structure ) {

								// dataTypeExpression is optional and defaults to "*"
								return function( dataTypeExpression, func ) {

												if ( typeof dataTypeExpression !== "string" ) {
																func = dataTypeExpression;
																dataTypeExpression = "*";
												}

												var dataType,
																i = 0,
																dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

												if ( jQuery.isFunction( func ) ) {
																// For each dataType in the dataTypeExpression
																while ( ( dataType = dataTypes[ i++ ] ) ) {
																				// Prepend if requested
																				if ( dataType[ 0 ] === "+" ) {
																								dataType = dataType.slice( 1 ) || "*";
																								( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

																								// Otherwise append
																				} else {
																								( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
																				}
																}
												}
								};
				}

				// Base inspection function for prefilters and transports
				function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

								var inspected = {},
												seekingTransport = ( structure === transports );

								function inspect( dataType ) {
												var selected;
												inspected[ dataType ] = true;
												jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
																var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
																if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
																				options.dataTypes.unshift( dataTypeOrTransport );
																				inspect( dataTypeOrTransport );
																				return false;
																} else if ( seekingTransport ) {
																				return !( selected = dataTypeOrTransport );
																}
												} );
												return selected;
								}

								return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
				}

				// A special extend for ajax options
				// that takes "flat" options (not to be deep extended)
				// Fixes #9887
				function ajaxExtend( target, src ) {
								var key, deep,
												flatOptions = jQuery.ajaxSettings.flatOptions || {};

								for ( key in src ) {
												if ( src[ key ] !== undefined ) {
																( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
												}
								}
								if ( deep ) {
												jQuery.extend( true, target, deep );
								}

								return target;
				}

				/* Handles responses to an ajax request:
				 * - finds the right dataType (mediates between content-type and expected dataType)
				 * - returns the corresponding response
				 */
				function ajaxHandleResponses( s, jqXHR, responses ) {

								var ct, type, finalDataType, firstDataType,
												contents = s.contents,
												dataTypes = s.dataTypes;

								// Remove auto dataType and get content-type in the process
								while ( dataTypes[ 0 ] === "*" ) {
												dataTypes.shift();
												if ( ct === undefined ) {
																ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
												}
								}

								// Check if we're dealing with a known content-type
								if ( ct ) {
												for ( type in contents ) {
																if ( contents[ type ] && contents[ type ].test( ct ) ) {
																				dataTypes.unshift( type );
																				break;
																}
												}
								}

								// Check to see if we have a response for the expected dataType
								if ( dataTypes[ 0 ] in responses ) {
												finalDataType = dataTypes[ 0 ];
								} else {
												// Try convertible dataTypes
												for ( type in responses ) {
																if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
																				finalDataType = type;
																				break;
																}
																if ( !firstDataType ) {
																				firstDataType = type;
																}
												}
												// Or just use first one
												finalDataType = finalDataType || firstDataType;
								}

								// If we found a dataType
								// We add the dataType to the list if needed
								// and return the corresponding response
								if ( finalDataType ) {
												if ( finalDataType !== dataTypes[ 0 ] ) {
																dataTypes.unshift( finalDataType );
												}
												return responses[ finalDataType ];
								}
				}

				/* Chain conversions given the request and the original response
				 * Also sets the responseXXX fields on the jqXHR instance
				 */
				function ajaxConvert( s, response, jqXHR, isSuccess ) {
								var conv2, current, conv, tmp, prev,
												converters = {},
												// Work with a copy of dataTypes in case we need to modify it for conversion
												dataTypes = s.dataTypes.slice();

								// Create converters map with lowercased keys
								if ( dataTypes[ 1 ] ) {
												for ( conv in s.converters ) {
																converters[ conv.toLowerCase() ] = s.converters[ conv ];
												}
								}

								current = dataTypes.shift();

								// Convert to each sequential dataType
								while ( current ) {

												if ( s.responseFields[ current ] ) {
																jqXHR[ s.responseFields[ current ] ] = response;
												}

												// Apply the dataFilter if provided
												if ( !prev && isSuccess && s.dataFilter ) {
																response = s.dataFilter( response, s.dataType );
												}

												prev = current;
												current = dataTypes.shift();

												if ( current ) {

																// There's only work to do if current dataType is non-auto
																if ( current === "*" ) {

																				current = prev;

																				// Convert response if prev dataType is non-auto and differs from current
																} else if ( prev !== "*" && prev !== current ) {

																				// Seek a direct converter
																				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

																				// If none found, seek a pair
																				if ( !conv ) {
																								for ( conv2 in converters ) {

																												// If conv2 outputs current
																												tmp = conv2.split( " " );
																												if ( tmp[ 1 ] === current ) {

																																// If prev can be converted to accepted input
																																conv = converters[ prev + " " + tmp[ 0 ] ] ||
																																				converters[ "* " + tmp[ 0 ] ];
																																if ( conv ) {
																																				// Condense equivalence converters
																																				if ( conv === true ) {
																																								conv = converters[ conv2 ];

																																								// Otherwise, insert the intermediate dataType
																																				} else if ( converters[ conv2 ] !== true ) {
																																								current = tmp[ 0 ];
																																								dataTypes.unshift( tmp[ 1 ] );
																																				}
																																				break;
																																}
																												}
																								}
																				}

																				// Apply converter (if not an equivalence)
																				if ( conv !== true ) {

																								// Unless errors are allowed to bubble, catch and return them
																								if ( conv && s[ "throws" ] ) {
																												response = conv( response );
																								} else {
																												try {
																																response = conv( response );
																												} catch ( e ) {
																																return {
																																				state: "parsererror",
																																				error: conv ? e : "No conversion from " + prev + " to " + current
																																};
																												}
																								}
																				}
																}
												}
								}

								return {
												state: "success",
												data: response
								};
				}

				jQuery.extend( {

								// Counter for holding the number of active queries
								active: 0,

								// Last-Modified header cache for next request
								lastModified: {},
								etag: {},

								ajaxSettings: {
												url: ajaxLocation,
												type: "GET",
												isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
												global: true,
												processData: true,
												async: true,
												contentType: "application/x-www-form-urlencoded; charset=UTF-8",
												/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

												accepts: {
																"*": allTypes,
																text: "text/plain",
																html: "text/html",
																xml: "application/xml, text/xml",
																json: "application/json, text/javascript"
												},

												contents: {
																xml: /xml/,
																html: /html/,
																json: /json/
												},

												responseFields: {
																xml: "responseXML",
																text: "responseText",
																json: "responseJSON"
												},

												// Data converters
												// Keys separate source (or catchall "*") and destination types with a single space
												converters: {

																// Convert anything to text
																"* text": String,

																// Text to html (true = no transformation)
																"text html": true,

																// Evaluate text as a json expression
																"text json": jQuery.parseJSON,

																// Parse text as xml
																"text xml": jQuery.parseXML
												},

												// For options that shouldn't be deep extended:
												// you can add your own custom options here if
												// and when you create one that shouldn't be
												// deep extended (see ajaxExtend)
												flatOptions: {
																url: true,
																context: true
												}
								},

								// Creates a full fledged settings object into target
								// with both ajaxSettings and settings fields.
								// If target is omitted, writes into ajaxSettings.
								ajaxSetup: function( target, settings ) {
												return settings ?

												// Building a settings object
												ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

												// Extending ajaxSettings
												ajaxExtend( jQuery.ajaxSettings, target );
								},

								ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
								ajaxTransport: addToPrefiltersOrTransports( transports ),

								// Main method
								ajax: function( url, options ) {

												// If url is an object, simulate pre-1.5 signature
												if ( typeof url === "object" ) {
																options = url;
																url = undefined;
												}

												// Force options to be an object
												options = options || {};

												var transport,
																// URL without anti-cache param
																cacheURL,
																// Response headers
																responseHeadersString,
																responseHeaders,
																// timeout handle
																timeoutTimer,
																// Cross-domain detection vars
																parts,
																// To know if global events are to be dispatched
																fireGlobals,
																// Loop variable
																i,
																// Create the final options object
																s = jQuery.ajaxSetup( {}, options ),
																// Callbacks context
																callbackContext = s.context || s,
																// Context for global events is callbackContext if it is a DOM node or jQuery collection
																globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
																				jQuery( callbackContext ) :
																				jQuery.event,
																// Deferreds
																deferred = jQuery.Deferred(),
																completeDeferred = jQuery.Callbacks( "once memory" ),
																// Status-dependent callbacks
																statusCode = s.statusCode || {},
																// Headers (they are sent all at once)
																requestHeaders = {},
																requestHeadersNames = {},
																// The jqXHR state
																state = 0,
																// Default abort message
																strAbort = "canceled",
																// Fake xhr
																jqXHR = {
																				readyState: 0,

																				// Builds headers hashtable if needed
																				getResponseHeader: function( key ) {
																								var match;
																								if ( state === 2 ) {
																												if ( !responseHeaders ) {
																																responseHeaders = {};
																																while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
																																				responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
																																}
																												}
																												match = responseHeaders[ key.toLowerCase() ];
																								}
																								return match == null ? null : match;
																				},

																				// Raw string
																				getAllResponseHeaders: function() {
																								return state === 2 ? responseHeadersString : null;
																				},

																				// Caches the header
																				setRequestHeader: function( name, value ) {
																								var lname = name.toLowerCase();
																								if ( !state ) {
																												name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
																												requestHeaders[ name ] = value;
																								}
																								return this;
																				},

																				// Overrides response content-type header
																				overrideMimeType: function( type ) {
																								if ( !state ) {
																												s.mimeType = type;
																								}
																								return this;
																				},

																				// Status-dependent callbacks
																				statusCode: function( map ) {
																								var code;
																								if ( map ) {
																												if ( state < 2 ) {
																																for ( code in map ) {
																																				// Lazy-add the new callback in a way that preserves old ones
																																				statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
																																}
																												} else {
																																// Execute the appropriate callbacks
																																jqXHR.always( map[ jqXHR.status ] );
																												}
																								}
																								return this;
																				},

																				// Cancel the request
																				abort: function( statusText ) {
																								var finalText = statusText || strAbort;
																								if ( transport ) {
																												transport.abort( finalText );
																								}
																								done( 0, finalText );
																								return this;
																				}
																};

												// Attach deferreds
												deferred.promise( jqXHR ).complete = completeDeferred.add;
												jqXHR.success = jqXHR.done;
												jqXHR.error = jqXHR.fail;

												// Remove hash character (#7531: and string promotion)
												// Add protocol if not provided (prefilters might expect it)
												// Handle falsy url in the settings object (#10093: consistency with old signature)
												// We also use the url parameter if available
												s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
																.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

												// Alias method option to type as per ticket #12004
												s.type = options.method || options.type || s.method || s.type;

												// Extract dataTypes list
												s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

												// A cross-domain request is in order when we have a protocol:host:port mismatch
												if ( s.crossDomain == null ) {
																parts = rurl.exec( s.url.toLowerCase() );
																s.crossDomain = !! ( parts &&
																				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
																								( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
																								( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
																);
												}

												// Convert data if not already a string
												if ( s.data && s.processData && typeof s.data !== "string" ) {
																s.data = jQuery.param( s.data, s.traditional );
												}

												// Apply prefilters
												inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

												// If request was aborted inside a prefilter, stop there
												if ( state === 2 ) {
																return jqXHR;
												}

												// We can fire global events as of now if asked to
												fireGlobals = s.global;

												// Watch for a new set of requests
												if ( fireGlobals && jQuery.active++ === 0 ) {
																jQuery.event.trigger( "ajaxStart" );
												}

												// Uppercase the type
												s.type = s.type.toUpperCase();

												// Determine if request has content
												s.hasContent = !rnoContent.test( s.type );

												// Save the URL in case we're toying with the If-Modified-Since
												// and/or If-None-Match header later on
												cacheURL = s.url;

												// More options handling for requests with no content
												if ( !s.hasContent ) {

																// If data is available, append data to url
																if ( s.data ) {
																				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
																				// #9682: remove data so that it's not used in an eventual retry
																				delete s.data;
																}

																// Add anti-cache in url if needed
																if ( s.cache === false ) {
																				s.url = rts.test( cacheURL ) ?

																				// If there is already a '_' parameter, set its value
																				cacheURL.replace( rts, "$1_=" + nonce++ ) :

																				// Otherwise add one to the end
																				cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
																}
												}

												// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
												if ( s.ifModified ) {
																if ( jQuery.lastModified[ cacheURL ] ) {
																				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
																}
																if ( jQuery.etag[ cacheURL ] ) {
																				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
																}
												}

												// Set the correct header, if data is being sent
												if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
																jqXHR.setRequestHeader( "Content-Type", s.contentType );
												}

												// Set the Accepts header for the server, depending on the dataType
												jqXHR.setRequestHeader(
																"Accept",
																s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
																s.accepts[ s.dataTypes[ 0 ] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
																s.accepts[ "*" ]
												);

												// Check for headers option
												for ( i in s.headers ) {
																jqXHR.setRequestHeader( i, s.headers[ i ] );
												}

												// Allow custom headers/mimetypes and early abort
												if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
																// Abort if not done already and return
																return jqXHR.abort();
												}

												// aborting is no longer a cancellation
												strAbort = "abort";

												// Install callbacks on deferreds
												for ( i in {
																success: 1,
																error: 1,
																complete: 1
												} ) {
																jqXHR[ i ]( s[ i ] );
												}

												// Get transport
												transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

												// If no transport, we auto-abort
												if ( !transport ) {
																done( -1, "No Transport" );
												} else {
																jqXHR.readyState = 1;

																// Send global event
																if ( fireGlobals ) {
																				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
																}
																// Timeout
																if ( s.async && s.timeout > 0 ) {
																				timeoutTimer = setTimeout( function() {
																								jqXHR.abort( "timeout" );
																				}, s.timeout );
																}

																try {
																				state = 1;
																				transport.send( requestHeaders, done );
																} catch ( e ) {
																				// Propagate exception as error if not done
																				if ( state < 2 ) {
																								done( -1, e );
																								// Simply rethrow otherwise
																				} else {
																								throw e;
																				}
																}
												}

												// Callback for when everything is done
												function done( status, nativeStatusText, responses, headers ) {
																var isSuccess, success, error, response, modified,
																				statusText = nativeStatusText;

																// Called once
																if ( state === 2 ) {
																				return;
																}

																// State is "done" now
																state = 2;

																// Clear timeout if it exists
																if ( timeoutTimer ) {
																				clearTimeout( timeoutTimer );
																}

																// Dereference transport for early garbage collection
																// (no matter how long the jqXHR object will be used)
																transport = undefined;

																// Cache response headers
																responseHeadersString = headers || "";

																// Set readyState
																jqXHR.readyState = status > 0 ? 4 : 0;

																// Determine if successful
																isSuccess = status >= 200 && status < 300 || status === 304;

																// Get response data
																if ( responses ) {
																				response = ajaxHandleResponses( s, jqXHR, responses );
																}

																// Convert no matter what (that way responseXXX fields are always set)
																response = ajaxConvert( s, response, jqXHR, isSuccess );

																// If successful, handle type chaining
																if ( isSuccess ) {

																				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
																				if ( s.ifModified ) {
																								modified = jqXHR.getResponseHeader( "Last-Modified" );
																								if ( modified ) {
																												jQuery.lastModified[ cacheURL ] = modified;
																								}
																								modified = jqXHR.getResponseHeader( "etag" );
																								if ( modified ) {
																												jQuery.etag[ cacheURL ] = modified;
																								}
																				}

																				// if no content
																				if ( status === 204 || s.type === "HEAD" ) {
																								statusText = "nocontent";

																								// if not modified
																				} else if ( status === 304 ) {
																								statusText = "notmodified";

																								// If we have data, let's convert it
																				} else {
																								statusText = response.state;
																								success = response.data;
																								error = response.error;
																								isSuccess = !error;
																				}
																} else {
																				// We extract error from statusText
																				// then normalize statusText and status for non-aborts
																				error = statusText;
																				if ( status || !statusText ) {
																								statusText = "error";
																								if ( status < 0 ) {
																												status = 0;
																								}
																				}
																}

																// Set data for the fake xhr object
																jqXHR.status = status;
																jqXHR.statusText = ( nativeStatusText || statusText ) + "";

																// Success/Error
																if ( isSuccess ) {
																				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
																} else {
																				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
																}

																// Status-dependent callbacks
																jqXHR.statusCode( statusCode );
																statusCode = undefined;

																if ( fireGlobals ) {
																				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ] );
																}

																// Complete
																completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

																if ( fireGlobals ) {
																				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
																				// Handle the global AJAX counter
																				if ( !( --jQuery.active ) ) {
																								jQuery.event.trigger( "ajaxStop" );
																				}
																}
												}

												return jqXHR;
								},

								getJSON: function( url, data, callback ) {
												return jQuery.get( url, data, callback, "json" );
								},

								getScript: function( url, callback ) {
												return jQuery.get( url, undefined, callback, "script" );
								}
				} );

				jQuery.each( [ "get", "post" ], function( i, method ) {
								jQuery[ method ] = function( url, data, callback, type ) {
												// shift arguments if data argument was omitted
												if ( jQuery.isFunction( data ) ) {
																type = type || callback;
																callback = data;
																data = undefined;
												}

												return jQuery.ajax( {
																url: url,
																type: method,
																dataType: type,
																data: data,
																success: callback
												} );
								};
				} );

				// Attach a bunch of functions for handling common AJAX events
				jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
								jQuery.fn[ type ] = function( fn ) {
												return this.on( type, fn );
								};
				} );


				jQuery._evalUrl = function( url ) {
								return jQuery.ajax( {
												url: url,
												type: "GET",
												dataType: "script",
												async: false,
												global: false,
												"throws": true
								} );
				};


				jQuery.fn.extend( {
								wrapAll: function( html ) {
												var wrap;

												if ( jQuery.isFunction( html ) ) {
																return this.each( function( i ) {
																				jQuery( this ).wrapAll( html.call( this, i ) );
																} );
												}

												if ( this[ 0 ] ) {

																// The elements to wrap the target around
																wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

																if ( this[ 0 ].parentNode ) {
																				wrap.insertBefore( this[ 0 ] );
																}

																wrap.map( function() {
																				var elem = this;

																				while ( elem.firstElementChild ) {
																								elem = elem.firstElementChild;
																				}

																				return elem;
																} ).append( this );
												}

												return this;
								},

								wrapInner: function( html ) {
												if ( jQuery.isFunction( html ) ) {
																return this.each( function( i ) {
																				jQuery( this ).wrapInner( html.call( this, i ) );
																} );
												}

												return this.each( function() {
																var self = jQuery( this ),
																				contents = self.contents();

																if ( contents.length ) {
																				contents.wrapAll( html );

																} else {
																				self.append( html );
																}
												} );
								},

								wrap: function( html ) {
												var isFunction = jQuery.isFunction( html );

												return this.each( function( i ) {
																jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
												} );
								},

								unwrap: function() {
												return this.parent().each( function() {
																if ( !jQuery.nodeName( this, "body" ) ) {
																				jQuery( this ).replaceWith( this.childNodes );
																}
												} ).end();
								}
				} );


				jQuery.expr.filters.hidden = function( elem ) {
								// Support: Opera <= 12.12
								// Opera reports offsetWidths and offsetHeights less than zero on some elements
								return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
				};
				jQuery.expr.filters.visible = function( elem ) {
								return !jQuery.expr.filters.hidden( elem );
				};



				var r20 = /%20/g,
								rbracket = /\[\]$/,
								rCRLF = /\r?\n/g,
								rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
								rsubmittable = /^(?:input|select|textarea|keygen)/i;

				function buildParams( prefix, obj, traditional, add ) {
								var name;

								if ( jQuery.isArray( obj ) ) {
												// Serialize array item.
												jQuery.each( obj, function( i, v ) {
																if ( traditional || rbracket.test( prefix ) ) {
																				// Treat each array item as a scalar.
																				add( prefix, v );

																} else {
																				// Item is non-scalar (array or object), encode its numeric index.
																				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
																}
												} );

								} else if ( !traditional && jQuery.type( obj ) === "object" ) {
												// Serialize object item.
												for ( name in obj ) {
																buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
												}

								} else {
												// Serialize scalar item.
												add( prefix, obj );
								}
				}

				// Serialize an array of form elements or a set of
				// key/values into a query string
				jQuery.param = function( a, traditional ) {
								var prefix,
												s = [],
												add = function( key, value ) {
																// If value is a function, invoke it and return its value
																value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
																s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
												};

								// Set traditional to true for jQuery <= 1.3.2 behavior.
								if ( traditional === undefined ) {
												traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
								}

								// If an array was passed in, assume that it is an array of form elements.
								if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
												// Serialize the form elements
												jQuery.each( a, function() {
																add( this.name, this.value );
												} );

								} else {
												// If traditional, encode the "old" way (the way 1.3.2 or older
												// did it), otherwise encode params recursively.
												for ( prefix in a ) {
																buildParams( prefix, a[ prefix ], traditional, add );
												}
								}

								// Return the resulting serialization
								return s.join( "&" ).replace( r20, "+" );
				};

				jQuery.fn.extend( {
								serialize: function() {
												return jQuery.param( this.serializeArray() );
								},
								serializeArray: function() {
												return this.map( function() {
																// Can add propHook for "elements" to filter or add form elements
																var elements = jQuery.prop( this, "elements" );
																return elements ? jQuery.makeArray( elements ) : this;
												} )
																.filter( function() {
																				var type = this.type;

																				// Use .is( ":disabled" ) so that fieldset[disabled] works
																				return this.name && !jQuery( this ).is( ":disabled" ) &&
																								rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
																								( this.checked || !rcheckableType.test( type ) );
																} )
																.map( function( i, elem ) {
																				var val = jQuery( this ).val();

																				return val == null ?
																								null :
																								jQuery.isArray( val ) ?
																								jQuery.map( val, function( val ) {
																												return {
																																name: elem.name,
																																value: val.replace( rCRLF, "\r\n" )
																												};
																								} ) : {
																												name: elem.name,
																												value: val.replace( rCRLF, "\r\n" )
																				};
																} ).get();
								}
				} );


				jQuery.ajaxSettings.xhr = function() {
								try {
												return new XMLHttpRequest();
								} catch ( e ) {}
				};

				var xhrId = 0,
								xhrCallbacks = {},
								xhrSuccessStatus = {
												// file protocol always yields status code 0, assume 200
												0: 200,
												// Support: IE9
												// #1450: sometimes IE returns 1223 when it should be 204
												1223: 204
								},
								xhrSupported = jQuery.ajaxSettings.xhr();

				// Support: IE9
				// Open requests must be manually aborted on unload (#5280)
				if ( window.ActiveXObject ) {
								jQuery( window ).on( "unload", function() {
												for ( var key in xhrCallbacks ) {
																xhrCallbacks[ key ]();
												}
								} );
				}

				support.cors = !! xhrSupported && ( "withCredentials" in xhrSupported );
				support.ajax = xhrSupported = !! xhrSupported;

				jQuery.ajaxTransport( function( options ) {
								var callback;

								// Cross domain only allowed if supported through XMLHttpRequest
								if ( support.cors || xhrSupported && !options.crossDomain ) {
												return {
																send: function( headers, complete ) {
																				var i,
																								xhr = options.xhr(),
																								id = ++xhrId;

																				xhr.open( options.type, options.url, options.async, options.username, options.password );

																				// Apply custom fields if provided
																				if ( options.xhrFields ) {
																								for ( i in options.xhrFields ) {
																												xhr[ i ] = options.xhrFields[ i ];
																								}
																				}

																				// Override mime type if needed
																				if ( options.mimeType && xhr.overrideMimeType ) {
																								xhr.overrideMimeType( options.mimeType );
																				}

																				// X-Requested-With header
																				// For cross-domain requests, seeing as conditions for a preflight are
																				// akin to a jigsaw puzzle, we simply never set it to be sure.
																				// (it can always be set on a per-request basis or even using ajaxSetup)
																				// For same-domain requests, won't change header if already provided.
																				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
																								headers[ "X-Requested-With" ] = "XMLHttpRequest";
																				}

																				// Set headers
																				for ( i in headers ) {
																								xhr.setRequestHeader( i, headers[ i ] );
																				}

																				// Callback
																				callback = function( type ) {
																								return function() {
																												if ( callback ) {
																																delete xhrCallbacks[ id ];
																																callback = xhr.onload = xhr.onerror = null;

																																if ( type === "abort" ) {
																																				xhr.abort();
																																} else if ( type === "error" ) {
																																				complete(
																																								// file: protocol always yields status 0; see #8605, #14207
																																								xhr.status,
																																								xhr.statusText
																																				);
																																} else {
																																				complete(
																																								xhrSuccessStatus[ xhr.status ] || xhr.status,
																																								xhr.statusText,
																																								// Support: IE9
																																								// Accessing binary-data responseText throws an exception
																																								// (#11426)
																																								typeof xhr.responseText === "string" ? {
																																												text: xhr.responseText
																																								} : undefined,
																																								xhr.getAllResponseHeaders()
																																				);
																																}
																												}
																								};
																				};

																				// Listen to events
																				xhr.onload = callback();
																				xhr.onerror = callback( "error" );

																				// Create the abort callback
																				callback = xhrCallbacks[ id ] = callback( "abort" );

																				// Do send the request
																				// This may raise an exception which is actually
																				// handled in jQuery.ajax (so no try/catch here)
																				xhr.send( options.hasContent && options.data || null );
																},

																abort: function() {
																				if ( callback ) {
																								callback();
																				}
																}
												};
								}
				} );



				// Install script dataType
				jQuery.ajaxSetup( {
								accepts: {
												script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
								},
								contents: {
												script: /(?:java|ecma)script/
								},
								converters: {
												"text script": function( text ) {
																jQuery.globalEval( text );
																return text;
												}
								}
				} );

				// Handle cache's special case and crossDomain
				jQuery.ajaxPrefilter( "script", function( s ) {
								if ( s.cache === undefined ) {
												s.cache = false;
								}
								if ( s.crossDomain ) {
												s.type = "GET";
								}
				} );

				// Bind script tag hack transport
				jQuery.ajaxTransport( "script", function( s ) {
								// This transport only deals with cross domain requests
								if ( s.crossDomain ) {
												var script, callback;
												return {
																send: function( _, complete ) {
																				script = jQuery( "<script>" ).prop( {
																								async: true,
																								charset: s.scriptCharset,
																								src: s.url
																				} ).on(
																								"load error",
																								callback = function( evt ) {
																												script.remove();
																												callback = null;
																												if ( evt ) {
																																complete( evt.type === "error" ? 404 : 200, evt.type );
																												}
																								}
																				);
																				document.head.appendChild( script[ 0 ] );
																},
																abort: function() {
																				if ( callback ) {
																								callback();
																				}
																}
												};
								}
				} );



				var oldCallbacks = [],
								rjsonp = /(=)\?(?=&|$)|\?\?/;

				// Default jsonp settings
				jQuery.ajaxSetup( {
								jsonp: "callback",
								jsonpCallback: function() {
												var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
												this[ callback ] = true;
												return callback;
								}
				} );

				// Detect, normalize options and install callbacks for jsonp requests
				jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

								var callbackName, overwritten, responseContainer,
												jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
																"url" :
																typeof s.data === "string" && !( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) && rjsonp.test( s.data ) && "data"
												);

								// Handle iff the expected data type is "jsonp" or we have a parameter to set
								if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

												// Get callback name, remembering preexisting value associated with it
												callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
																s.jsonpCallback() :
																s.jsonpCallback;

												// Insert callback into url or form data
												if ( jsonProp ) {
																s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
												} else if ( s.jsonp !== false ) {
																s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
												}

												// Use data converter to retrieve json after script execution
												s.converters[ "script json" ] = function() {
																if ( !responseContainer ) {
																				jQuery.error( callbackName + " was not called" );
																}
																return responseContainer[ 0 ];
												};

												// force json dataType
												s.dataTypes[ 0 ] = "json";

												// Install callback
												overwritten = window[ callbackName ];
												window[ callbackName ] = function() {
																responseContainer = arguments;
												};

												// Clean-up function (fires after converters)
												jqXHR.always( function() {
																// Restore preexisting value
																window[ callbackName ] = overwritten;

																// Save back as free
																if ( s[ callbackName ] ) {
																				// make sure that re-using the options doesn't screw things around
																				s.jsonpCallback = originalSettings.jsonpCallback;

																				// save the callback name for future use
																				oldCallbacks.push( callbackName );
																}

																// Call if it was a function and we have a response
																if ( responseContainer && jQuery.isFunction( overwritten ) ) {
																				overwritten( responseContainer[ 0 ] );
																}

																responseContainer = overwritten = undefined;
												} );

												// Delegate to script
												return "script";
								}
				} );



				// data: string of html
				// context (optional): If specified, the fragment will be created in this context, defaults to document
				// keepScripts (optional): If true, will include scripts passed in the html string
				jQuery.parseHTML = function( data, context, keepScripts ) {
								if ( !data || typeof data !== "string" ) {
												return null;
								}
								if ( typeof context === "boolean" ) {
												keepScripts = context;
												context = false;
								}
								context = context || document;

								var parsed = rsingleTag.exec( data ),
												scripts = !keepScripts && [];

								// Single tag
								if ( parsed ) {
												return [ context.createElement( parsed[ 1 ] ) ];
								}

								parsed = jQuery.buildFragment( [ data ], context, scripts );

								if ( scripts && scripts.length ) {
												jQuery( scripts ).remove();
								}

								return jQuery.merge( [], parsed.childNodes );
				};


				// Keep a copy of the old load method
				var _load = jQuery.fn.load;

				/**
				 * Load a url into a page
				 */
				jQuery.fn.load = function( url, params, callback ) {
								if ( typeof url !== "string" && _load ) {
												return _load.apply( this, arguments );
								}

								var selector, type, response,
												self = this,
												off = url.indexOf( " " );

								if ( off >= 0 ) {
												selector = url.slice( off );
												url = url.slice( 0, off );
								}

								// If it's a function
								if ( jQuery.isFunction( params ) ) {

												// We assume that it's the callback
												callback = params;
												params = undefined;

												// Otherwise, build a param string
								} else if ( params && typeof params === "object" ) {
												type = "POST";
								}

								// If we have elements to modify, make the request
								if ( self.length > 0 ) {
												jQuery.ajax( {
																url: url,

																// if "type" variable is undefined, then "GET" method will be used
																type: type,
																dataType: "html",
																data: params
												} ).done( function( responseText ) {

																// Save response for use in complete callback
																response = arguments;

																self.html( selector ?

																				// If a selector was specified, locate the right elements in a dummy div
																				// Exclude scripts to avoid IE 'Permission Denied' errors
																				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

																				// Otherwise use the full result
																				responseText );

												} ).complete( callback && function( jqXHR, status ) {
																self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
												} );
								}

								return this;
				};



				jQuery.expr.filters.animated = function( elem ) {
								return jQuery.grep( jQuery.timers, function( fn ) {
												return elem === fn.elem;
								} ).length;
				};



				var docElem = window.document.documentElement;

				/**
				 * Gets a window from an element
				 */
				function getWindow( elem ) {
								return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
				}

				jQuery.offset = {
								setOffset: function( elem, options, i ) {
												var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
																position = jQuery.css( elem, "position" ),
																curElem = jQuery( elem ),
																props = {};

												// Set position first, in-case top/left are set even on static elem
												if ( position === "static" ) {
																elem.style.position = "relative";
												}

												curOffset = curElem.offset();
												curCSSTop = jQuery.css( elem, "top" );
												curCSSLeft = jQuery.css( elem, "left" );
												calculatePosition = ( position === "absolute" || position === "fixed" ) &&
																( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

												// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
												if ( calculatePosition ) {
																curPosition = curElem.position();
																curTop = curPosition.top;
																curLeft = curPosition.left;

												} else {
																curTop = parseFloat( curCSSTop ) || 0;
																curLeft = parseFloat( curCSSLeft ) || 0;
												}

												if ( jQuery.isFunction( options ) ) {
																options = options.call( elem, i, curOffset );
												}

												if ( options.top != null ) {
																props.top = ( options.top - curOffset.top ) + curTop;
												}
												if ( options.left != null ) {
																props.left = ( options.left - curOffset.left ) + curLeft;
												}

												if ( "using" in options ) {
																options.using.call( elem, props );

												} else {
																curElem.css( props );
												}
								}
				};

				jQuery.fn.extend( {
								offset: function( options ) {
												if ( arguments.length ) {
																return options === undefined ?
																				this :
																				this.each( function( i ) {
																								jQuery.offset.setOffset( this, options, i );
																				} );
												}

												var docElem, win,
																elem = this[ 0 ],
																box = {
																				top: 0,
																				left: 0
																},
																doc = elem && elem.ownerDocument;

												if ( !doc ) {
																return;
												}

												docElem = doc.documentElement;

												// Make sure it's not a disconnected DOM node
												if ( !jQuery.contains( docElem, elem ) ) {
																return box;
												}

												// If we don't have gBCR, just use 0,0 rather than error
												// BlackBerry 5, iOS 3 (original iPhone)
												if ( typeof elem.getBoundingClientRect !== strundefined ) {
																box = elem.getBoundingClientRect();
												}
												win = getWindow( doc );
												return {
																top: box.top + win.pageYOffset - docElem.clientTop,
																left: box.left + win.pageXOffset - docElem.clientLeft
												};
								},

								position: function() {
												if ( !this[ 0 ] ) {
																return;
												}

												var offsetParent, offset,
																elem = this[ 0 ],
																parentOffset = {
																				top: 0,
																				left: 0
																};

												// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
												if ( jQuery.css( elem, "position" ) === "fixed" ) {
																// We assume that getBoundingClientRect is available when computed position is fixed
																offset = elem.getBoundingClientRect();

												} else {
																// Get *real* offsetParent
																offsetParent = this.offsetParent();

																// Get correct offsets
																offset = this.offset();
																if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
																				parentOffset = offsetParent.offset();
																}

																// Add offsetParent borders
																parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
																parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
												}

												// Subtract parent offsets and element margins
												return {
																top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
																left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
												};
								},

								offsetParent: function() {
												return this.map( function() {
																var offsetParent = this.offsetParent || docElem;

																while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
																				offsetParent = offsetParent.offsetParent;
																}

																return offsetParent || docElem;
												} );
								}
				} );

				// Create scrollLeft and scrollTop methods
				jQuery.each( {
								scrollLeft: "pageXOffset",
								scrollTop: "pageYOffset"
				}, function( method, prop ) {
								var top = "pageYOffset" === prop;

								jQuery.fn[ method ] = function( val ) {
												return access( this, function( elem, method, val ) {
																var win = getWindow( elem );

																if ( val === undefined ) {
																				return win ? win[ prop ] : elem[ method ];
																}

																if ( win ) {
																				win.scrollTo( !top ? val : window.pageXOffset,
																								top ? val : window.pageYOffset
																				);

																} else {
																				elem[ method ] = val;
																}
												}, method, val, arguments.length, null );
								};
				} );

				// Add the top/left cssHooks using jQuery.fn.position
				// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
				// getComputedStyle returns percent when specified for top/left/bottom/right
				// rather than make the css module depend on the offset module, we just check for it here
				jQuery.each( [ "top", "left" ], function( i, prop ) {
								jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
												function( elem, computed ) {
																if ( computed ) {
																				computed = curCSS( elem, prop );
																				// if curCSS returns percentage, fallback to offset
																				return rnumnonpx.test( computed ) ?
																								jQuery( elem ).position()[ prop ] + "px" :
																								computed;
																}
												}
								);
				} );


				// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
				jQuery.each( {
								Height: "height",
								Width: "width"
				}, function( name, type ) {
								jQuery.each( {
												padding: "inner" + name,
												content: type,
												"": "outer" + name
								}, function( defaultExtra, funcName ) {
												// margin is only for outerHeight, outerWidth
												jQuery.fn[ funcName ] = function( margin, value ) {
																var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
																				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

																return access( this, function( elem, type, value ) {
																				var doc;

																				if ( jQuery.isWindow( elem ) ) {
																								// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
																								// isn't a whole lot we can do. See pull request at this URL for discussion:
																								// https://github.com/jquery/jquery/pull/764
																								return elem.document.documentElement[ "client" + name ];
																				}

																				// Get document width or height
																				if ( elem.nodeType === 9 ) {
																								doc = elem.documentElement;

																								// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
																								// whichever is greatest
																								return Math.max(
																												elem.body[ "scroll" + name ], doc[ "scroll" + name ],
																												elem.body[ "offset" + name ], doc[ "offset" + name ],
																												doc[ "client" + name ]
																								);
																				}

																				return value === undefined ?
																				// Get width or height on the element, requesting but not forcing parseFloat
																				jQuery.css( elem, type, extra ) :

																				// Set width or height on the element
																				jQuery.style( elem, type, value, extra );
																}, type, chainable ? margin : undefined, chainable, null );
												};
								} );
				} );


				// The number of elements contained in the matched element set
				jQuery.fn.size = function() {
								return this.length;
				};

				jQuery.fn.andSelf = jQuery.fn.addBack;



				// Register as a named AMD module, since jQuery can be concatenated with other
				// files that may use define, but not via a proper concatenation script that
				// understands anonymous AMD modules. A named AMD is safest and most robust
				// way to register. Lowercase jquery is used because AMD module names are
				// derived from file names, and jQuery is normally delivered in a lowercase
				// file name. Do this after creating the global so that if an AMD module wants
				// to call noConflict to hide this version of jQuery, it will work.
				if ( typeof define === "function" && define.amd ) {
								define( "jquery", [], function() {
												return jQuery;
								} );
				}



				var
				// Map over jQuery in case of overwrite
				_jQuery = window.jQuery,

								// Map over the $ in case of overwrite
								_$ = window.$;

				jQuery.noConflict = function( deep ) {
								if ( window.$ === jQuery ) {
												window.$ = _$;
								}

								if ( deep && window.jQuery === jQuery ) {
												window.jQuery = _jQuery;
								}

								return jQuery;
				};

				// Expose jQuery and $ identifiers, even in
				// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
				// and CommonJS for browser emulators (#13566)
				if ( typeof noGlobal === strundefined ) {
								window.jQuery = window.$ = jQuery;
				}



				return jQuery;

} ) );

define("jquery", function(){});

/* Modernizr (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-printshiv-cssclasses-json-touch-svg-input-canvastext-csstransforms3d-flexbox-cssgradients-opacity-backgroundsize-borderimage-borderradius-boxshadow-cssanimations-csscolumns-cssreflections-csstransitions-prefixed-csstransforms-mq-hashchange-draganddrop-generatedcontent-inlinesvg-smil-svgclippaths-inputtypes-fontface-websockets-cors-applicationcache-audio-canvas-geolocation-history-hsla-localstorage-multiplebgs-postmessage-sessionstorage-textshadow-rgba-video-webgl-websqldatabase-webworkers-indexedDB
 */
;



window.Modernizr = (function( window, document, undefined ) {

    var version = '2.7.1',

    Modernizr = {},

    enableClasses = true,

    docElement = document.documentElement,

    mod = 'modernizr',
    modElem = document.createElement(mod),
    mStyle = modElem.style,

    inputElem  = document.createElement('input')  ,

    smile = ':)',

    toString = {}.toString,

    prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),



    omPrefixes = 'Webkit Moz O ms',

    cssomPrefixes = omPrefixes.split(' '),

    domPrefixes = omPrefixes.toLowerCase().split(' '),

    ns = {'svg': 'http://www.w3.org/2000/svg'},

    tests = {},
    inputs = {},
    attrs = {},

    classes = [],

    slice = classes.slice,

    featureName, 


    injectElementWithStyles = function( rule, callback, nodes, testnames ) {

      var style, ret, node, docOverflow,
          div = document.createElement('div'),
                body = document.body,
                fakeBody = body || document.createElement('body');

      if ( parseInt(nodes, 10) ) {
                      while ( nodes-- ) {
              node = document.createElement('div');
              node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
              div.appendChild(node);
          }
      }

                style = ['&#173;','<style id="s', mod, '">', rule, '</style>'].join('');
      div.id = mod;
          (body ? div : fakeBody).innerHTML += style;
      fakeBody.appendChild(div);
      if ( !body ) {
                fakeBody.style.background = '';
                fakeBody.style.overflow = 'hidden';
          docOverflow = docElement.style.overflow;
          docElement.style.overflow = 'hidden';
          docElement.appendChild(fakeBody);
      }

      ret = callback(div, rule);
        if ( !body ) {
          fakeBody.parentNode.removeChild(fakeBody);
          docElement.style.overflow = docOverflow;
      } else {
          div.parentNode.removeChild(div);
      }

      return !!ret;

    },

    testMediaQuery = function( mq ) {

      var matchMedia = window.matchMedia || window.msMatchMedia;
      if ( matchMedia ) {
        return matchMedia(mq).matches;
      }

      var bool;

      injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function( node ) {
        bool = (window.getComputedStyle ?
                  getComputedStyle(node, null) :
                  node.currentStyle)['position'] == 'absolute';
      });

      return bool;

     },
 

    isEventSupported = (function() {

      var TAGNAMES = {
        'select': 'input', 'change': 'input',
        'submit': 'form', 'reset': 'form',
        'error': 'img', 'load': 'img', 'abort': 'img'
      };

      function isEventSupported( eventName, element ) {

        element = element || document.createElement(TAGNAMES[eventName] || 'div');
        eventName = 'on' + eventName;

            var isSupported = eventName in element;

        if ( !isSupported ) {
                if ( !element.setAttribute ) {
            element = document.createElement('div');
          }
          if ( element.setAttribute && element.removeAttribute ) {
            element.setAttribute(eventName, '');
            isSupported = is(element[eventName], 'function');

                    if ( !is(element[eventName], 'undefined') ) {
              element[eventName] = undefined;
            }
            element.removeAttribute(eventName);
          }
        }

        element = null;
        return isSupported;
      }
      return isEventSupported;
    })(),


    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
      hasOwnProp = function (object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function (object, property) { 
        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
      };
    }


    if (!Function.prototype.bind) {
      Function.prototype.bind = function bind(that) {

        var target = this;

        if (typeof target != "function") {
            throw new TypeError();
        }

        var args = slice.call(arguments, 1),
            bound = function () {

            if (this instanceof bound) {

              var F = function(){};
              F.prototype = target.prototype;
              var self = new F();

              var result = target.apply(
                  self,
                  args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return self;

            } else {

              return target.apply(
                  that,
                  args.concat(slice.call(arguments))
              );

            }

        };

        return bound;
      };
    }

    function setCss( str ) {
        mStyle.cssText = str;
    }

    function setCssAll( str1, str2 ) {
        return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
    }

    function is( obj, type ) {
        return typeof obj === type;
    }

    function contains( str, substr ) {
        return !!~('' + str).indexOf(substr);
    }

    function testProps( props, prefixed ) {
        for ( var i in props ) {
            var prop = props[i];
            if ( !contains(prop, "-") && mStyle[prop] !== undefined ) {
                return prefixed == 'pfx' ? prop : true;
            }
        }
        return false;
    }

    function testDOMProps( props, obj, elem ) {
        for ( var i in props ) {
            var item = obj[props[i]];
            if ( item !== undefined) {

                            if (elem === false) return props[i];

                            if (is(item, 'function')){
                                return item.bind(elem || obj);
                }

                            return item;
            }
        }
        return false;
    }

    function testPropsAll( prop, prefixed, elem ) {

        var ucProp  = prop.charAt(0).toUpperCase() + prop.slice(1),
            props   = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');

            if(is(prefixed, "string") || is(prefixed, "undefined")) {
          return testProps(props, prefixed);

            } else {
          props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
          return testDOMProps(props, prefixed, elem);
        }
    }    tests['flexbox'] = function() {
      return testPropsAll('flexWrap');
    };    tests['canvas'] = function() {
        var elem = document.createElement('canvas');
        return !!(elem.getContext && elem.getContext('2d'));
    };

    tests['canvastext'] = function() {
        return !!(Modernizr['canvas'] && is(document.createElement('canvas').getContext('2d').fillText, 'function'));
    };



    tests['webgl'] = function() {
        return !!window.WebGLRenderingContext;
    };


    tests['touch'] = function() {
        var bool;

        if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(''), function( node ) {
            bool = node.offsetTop === 9;
          });
        }

        return bool;
    };



    tests['geolocation'] = function() {
        return 'geolocation' in navigator;
    };


    tests['postmessage'] = function() {
      return !!window.postMessage;
    };


    tests['websqldatabase'] = function() {
      return !!window.openDatabase;
    };


    tests['hashchange'] = function() {
      return isEventSupported('hashchange', window) && (document.documentMode === undefined || document.documentMode > 7);
    };

    tests['history'] = function() {
      return !!(window.history && history.pushState);
    };

    tests['draganddrop'] = function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
    };

    tests['websockets'] = function() {
        return 'WebSocket' in window || 'MozWebSocket' in window;
    };


    tests['rgba'] = function() {
        setCss('background-color:rgba(150,255,150,.5)');

        return contains(mStyle.backgroundColor, 'rgba');
    };

    tests['hsla'] = function() {
            setCss('background-color:hsla(120,40%,100%,.5)');

        return contains(mStyle.backgroundColor, 'rgba') || contains(mStyle.backgroundColor, 'hsla');
    };

    tests['multiplebgs'] = function() {
                setCss('background:url(https://),url(https://),red url(https://)');

            return (/(url\s*\(.*?){3}/).test(mStyle.background);
    };    tests['backgroundsize'] = function() {
        return testPropsAll('backgroundSize');
    };

    tests['borderimage'] = function() {
        return testPropsAll('borderImage');
    };



    tests['borderradius'] = function() {
        return testPropsAll('borderRadius');
    };

    tests['boxshadow'] = function() {
        return testPropsAll('boxShadow');
    };

    tests['textshadow'] = function() {
        return document.createElement('div').style.textShadow === '';
    };


    tests['opacity'] = function() {
                setCssAll('opacity:.55');

                    return (/^0.55$/).test(mStyle.opacity);
    };


    tests['cssanimations'] = function() {
        return testPropsAll('animationName');
    };


    tests['csscolumns'] = function() {
        return testPropsAll('columnCount');
    };


    tests['cssgradients'] = function() {
        var str1 = 'background-image:',
            str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));',
            str3 = 'linear-gradient(left top,#9f9, white);';

        setCss(
                       (str1 + '-webkit- '.split(' ').join(str2 + str1) +
                       prefixes.join(str3 + str1)).slice(0, -str1.length)
        );

        return contains(mStyle.backgroundImage, 'gradient');
    };


    tests['cssreflections'] = function() {
        return testPropsAll('boxReflect');
    };


    tests['csstransforms'] = function() {
        return !!testPropsAll('transform');
    };


    tests['csstransforms3d'] = function() {

        var ret = !!testPropsAll('perspective');

                        if ( ret && 'webkitPerspective' in docElement.style ) {

                      injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function( node, rule ) {
            ret = node.offsetLeft === 9 && node.offsetHeight === 3;
          });
        }
        return ret;
    };


    tests['csstransitions'] = function() {
        return testPropsAll('transition');
    };



    tests['fontface'] = function() {
        var bool;

        injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function( node, rule ) {
          var style = document.getElementById('smodernizr'),
              sheet = style.sheet || style.styleSheet,
              cssText = sheet ? (sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || '') : '';

          bool = /src/i.test(cssText) && cssText.indexOf(rule.split(' ')[0]) === 0;
        });

        return bool;
    };

    tests['generatedcontent'] = function() {
        var bool;

        injectElementWithStyles(['#',mod,'{font:0/0 a}#',mod,':after{content:"',smile,'";visibility:hidden;font:3px/1 a}'].join(''), function( node ) {
          bool = node.offsetHeight >= 3;
        });

        return bool;
    };
    tests['video'] = function() {
        var elem = document.createElement('video'),
            bool = false;

            try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('video/ogg; codecs="theora"')      .replace(/^no$/,'');

                            bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"') .replace(/^no$/,'');

                bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,'');
            }

        } catch(e) { }

        return bool;
    };

    tests['audio'] = function() {
        var elem = document.createElement('audio'),
            bool = false;

        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,'');
                bool.mp3  = elem.canPlayType('audio/mpeg;')               .replace(/^no$/,'');

                                                    bool.wav  = elem.canPlayType('audio/wav; codecs="1"')     .replace(/^no$/,'');
                bool.m4a  = ( elem.canPlayType('audio/x-m4a;')            ||
                              elem.canPlayType('audio/aac;'))             .replace(/^no$/,'');
            }
        } catch(e) { }

        return bool;
    };


    tests['localstorage'] = function() {
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };

    tests['sessionstorage'] = function() {
        try {
            sessionStorage.setItem(mod, mod);
            sessionStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };


    tests['webworkers'] = function() {
        return !!window.Worker;
    };


    tests['applicationcache'] = function() {
        return !!window.applicationCache;
    };


    tests['svg'] = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, 'svg').createSVGRect;
    };

    tests['inlinesvg'] = function() {
      var div = document.createElement('div');
      div.innerHTML = '<svg/>';
      return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
    };

    tests['smil'] = function() {
        return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, 'animate')));
    };


    tests['svgclippaths'] = function() {
        return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, 'clipPath')));
    };

    function webforms() {
                                            Modernizr['input'] = (function( props ) {
            for ( var i = 0, len = props.length; i < len; i++ ) {
                attrs[ props[i] ] = !!(props[i] in inputElem);
            }
            if (attrs.list){
                                  attrs.list = !!(document.createElement('datalist') && window.HTMLDataListElement);
            }
            return attrs;
        })('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '));
                            Modernizr['inputtypes'] = (function(props) {

            for ( var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++ ) {

                inputElem.setAttribute('type', inputElemType = props[i]);
                bool = inputElem.type !== 'text';

                                                    if ( bool ) {

                    inputElem.value         = smile;
                    inputElem.style.cssText = 'position:absolute;visibility:hidden;';

                    if ( /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ) {

                      docElement.appendChild(inputElem);
                      defaultView = document.defaultView;

                                        bool =  defaultView.getComputedStyle &&
                              defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' &&
                                                                                  (inputElem.offsetHeight !== 0);

                      docElement.removeChild(inputElem);

                    } else if ( /^(search|tel)$/.test(inputElemType) ){
                                                                                    } else if ( /^(url|email)$/.test(inputElemType) ) {
                                        bool = inputElem.checkValidity && inputElem.checkValidity() === false;

                    } else {
                                        bool = inputElem.value != smile;
                    }
                }

                inputs[ props[i] ] = !!bool;
            }
            return inputs;
        })('search tel url email datetime date month week time datetime-local number range color'.split(' '));
        }
    for ( var feature in tests ) {
        if ( hasOwnProp(tests, feature) ) {
                                    featureName  = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();

            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
    }

    Modernizr.input || webforms();


     Modernizr.addTest = function ( feature, test ) {
       if ( typeof feature == 'object' ) {
         for ( var key in feature ) {
           if ( hasOwnProp( feature, key ) ) {
             Modernizr.addTest( key, feature[ key ] );
           }
         }
       } else {

         feature = feature.toLowerCase();

         if ( Modernizr[feature] !== undefined ) {
                                              return Modernizr;
         }

         test = typeof test == 'function' ? test() : test;

         if (typeof enableClasses !== "undefined" && enableClasses) {
           docElement.className += ' ' + (test ? '' : 'no-') + feature;
         }
         Modernizr[feature] = test;

       }

       return Modernizr; 
     };


    setCss('');
    modElem = inputElem = null;


    Modernizr._version      = version;

    Modernizr._prefixes     = prefixes;
    Modernizr._domPrefixes  = domPrefixes;
    Modernizr._cssomPrefixes  = cssomPrefixes;

    Modernizr.mq            = testMediaQuery;

    Modernizr.hasEvent      = isEventSupported;

    Modernizr.testProp      = function(prop){
        return testProps([prop]);
    };

    Modernizr.testAllProps  = testPropsAll;


    Modernizr.testStyles    = injectElementWithStyles;
    Modernizr.prefixed      = function(prop, obj, elem){
      if(!obj) {
        return testPropsAll(prop, 'pfx');
      } else {
            return testPropsAll(prop, obj, elem);
      }
    };


    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') +

                                                    (enableClasses ? ' js ' + classes.join(' ') : '');

    return Modernizr;

})(this, this.document);

;(function(window, document) {  var options = window.html5 || {};  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;  var saveClones = /^<|^(?:a|b|button|code|div|fieldset|form|h1|h2|h3|h4|h5|h6|i|iframe|img|input|label|li|link|ol|option|p|param|q|script|select|span|strong|style|table|tbody|td|textarea|tfoot|th|thead|tr|ul)$/i;  var supportsHtml5Styles;  var expando = '_html5shiv';  var expanID = 0;  var expandoData = {};  var supportsUnknownElements;

  (function() {
    try {
        var a = document.createElement('a');
        a.innerHTML = '<xyz></xyz>';
            supportsHtml5Styles = ('hidden' in a);

        supportsUnknownElements = a.childNodes.length == 1 || (function() {
                (document.createElement)('a');
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == 'undefined' ||
            typeof frag.createDocumentFragment == 'undefined' ||
            typeof frag.createElement == 'undefined'
          );
        }());
    } catch(e) {
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }

  }());
  
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement('p'),
        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

    p.innerHTML = 'x<style>' + cssText + '</style>';
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }  function getElements() {
    var elements = html5.elements;
    return typeof elements == 'string' ? elements.split(' ') : elements;
  }
  
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
    }
    return data;
  }  function createElement(nodeName, ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createElement(nodeName);
    }
    if (!data) {
        data = getExpandoData(ownerDocument);
    }
    var node;

    if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
        node = data.createElem(nodeName);
    }

    return node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;
  }  function createDocumentFragment(ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
    for(;i<l;i++){
        clone.createElement(elems[i]);
    }
    return clone;
  }  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
    }


    ownerDocument.createElement = function(nodeName) {
        if (!html5.shivMethods) {
          return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };

    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
      'var n=f.cloneNode(),c=n.createElement;' +
      'h.shivMethods&&(' +
            getElements().join().replace(/\w+/g, function(nodeName) {
          data.createElem(nodeName);
          data.frag.createElement(nodeName);
          return 'c("' + nodeName + '")';
        }) +
      ');return n}'
    )(html5, data.frag);
  }
  
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
        ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);

    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(ownerDocument,
            'article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}' +
            'mark{background:#FF0;color:#000}'
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }
  
  var html5 = {

    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video',

    'shivCSS': (options.shivCSS !== false),

    'supportsUnknownElements': supportsUnknownElements,

    'shivMethods': (options.shivMethods !== false),

    'type': 'default',

    'shivDocument': shivDocument,

    createElement: createElement,

    createDocumentFragment: createDocumentFragment
  };
  
  window.html5 = html5;  shivDocument(document);
  
  var reMedia = /^$|\b(?:all|print)\b/;  var shivNamespace = 'html5shiv';  var supportsShivableSheets = !supportsUnknownElements && (function() {
    var docEl = document.documentElement;
    return !(
      typeof document.namespaces == 'undefined' ||
      typeof document.parentWindow == 'undefined' ||
      typeof docEl.applyElement == 'undefined' ||
      typeof docEl.removeNode == 'undefined' ||
      typeof window.attachEvent == 'undefined'
    );
  }());
  
  function addWrappers(ownerDocument) {
    var node,
        nodes = ownerDocument.getElementsByTagName('*'),
        index = nodes.length,
        reElements = RegExp('^(?:' + getElements().join('|') + ')$', 'i'),
        result = [];

    while (index--) {
      node = nodes[index];
      if (reElements.test(node.nodeName)) {
        result.push(node.applyElement(createWrapper(node)));
      }
    }
    return result;
  }  function createWrapper(element) {
    var node,
        nodes = element.attributes,
        index = nodes.length,
        wrapper = element.ownerDocument.createElement(shivNamespace + ':' + element.nodeName);

    while (index--) {
      node = nodes[index];
      node.specified && wrapper.setAttribute(node.nodeName, node.nodeValue);
    }
    wrapper.style.cssText = element.style.cssText;
    return wrapper;
  }  function shivCssText(cssText) {
    var pair,
        parts = cssText.split('{'),
        index = parts.length,
        reElements = RegExp('(^|[\\s,>+~])(' + getElements().join('|') + ')(?=[[\\s,>+~#.:]|$)', 'gi'),
        replacement = '$1' + shivNamespace + '\\:$2';

    while (index--) {
      pair = parts[index] = parts[index].split('}');
      pair[pair.length - 1] = pair[pair.length - 1].replace(reElements, replacement);
      parts[index] = pair.join('}');
    }
    return parts.join('{');
  }  function removeWrappers(wrappers) {
    var index = wrappers.length;
    while (index--) {
      wrappers[index].removeNode();
    }
  }
  
  function shivPrint(ownerDocument) {
    var shivedSheet,
        wrappers,
        data = getExpandoData(ownerDocument),
        namespaces = ownerDocument.namespaces,
        ownerWindow = ownerDocument.parentWindow;

    if (!supportsShivableSheets || ownerDocument.printShived) {
      return ownerDocument;
    }
    if (typeof namespaces[shivNamespace] == 'undefined') {
      namespaces.add(shivNamespace);
    }

    function removeSheet() {
      clearTimeout(data._removeSheetTimer);
      if (shivedSheet) {
          shivedSheet.removeNode(true);
      }
      shivedSheet= null;
    }

    ownerWindow.attachEvent('onbeforeprint', function() {

      removeSheet();

      var imports,
          length,
          sheet,
          collection = ownerDocument.styleSheets,
          cssText = [],
          index = collection.length,
          sheets = Array(index);

        while (index--) {
        sheets[index] = collection[index];
      }
        while ((sheet = sheets.pop())) {
                if (!sheet.disabled && reMedia.test(sheet.media)) {

          try {
            imports = sheet.imports;
            length = imports.length;
          } catch(er){
            length = 0;
          }

          for (index = 0; index < length; index++) {
            sheets.push(imports[index]);
          }

          try {
            cssText.push(sheet.cssText);
          } catch(er){}
        }
      }

        cssText = shivCssText(cssText.reverse().join(''));
      wrappers = addWrappers(ownerDocument);
      shivedSheet = addStyleSheet(ownerDocument, cssText);

    });

    ownerWindow.attachEvent('onafterprint', function() {
        removeWrappers(wrappers);
      clearTimeout(data._removeSheetTimer);
      data._removeSheetTimer = setTimeout(removeSheet, 500);
    });

    ownerDocument.printShived = true;
    return ownerDocument;
  }
  
  html5.type += ' print';
  html5.shivPrint = shivPrint;  shivPrint(document);

}(this, document));
Modernizr.addTest('json', !!window.JSON && !!JSON.parse);


Modernizr.addTest('cors', !!(window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()));;
define("Modernizr", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Modernizr;
    };
}(this)));

/**
 * Copyright (C) 2012 Martijn van de Rijdt for JavaRosa functions added to XPathJS to make XPathJS_javarosa
 *
 * Original copyright notice for XPathJS:
 *
 * Copyright (C) 2011 Andrej Pavlovic for XPathJS
 *
 * This file is part of XPathJS.
 *
 * XPathJS is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, version 3 of the License.
 *
 * XPathJS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/* global window */
/* global XPathJS */

XPathJS = (function(){
	var XPathException,
		XPathEvaluator,
		XPathExpression,
		XPathNSResolver,
		XPathResult,
		XPathNamespace,
		module,
		evaluateExpressionTree,
		expressions,
		functions,
		Context,
		namespaceCache = [],
		
		NAMESPACE_URI_XML = 'http://www.w3.org/XML/1998/namespace',
		NAMESPACE_URI_XMLNS = 'http://www.w3.org/2000/xmlns/',
		NAMESPACE_URI_XHTML = 'http://www.w3.org/1999/xhtml',
		
		// XPath types
		BaseType,
		BooleanType,
		StringType,
		NumberType,
		NodeSetType,
		
		// HACK: track expression currently being evaluated
		currentExpression,
		
		/**
		 * @param {Node} node
		 * @return {Node}
		 */
		nodeOwnerDocument = function(node)
		{
			return node.ownerDocument;
		},
		
		/**
		 * Return all direct children of given node, but only those explicitly
		 * allowed by XPath specification.
		 *
		 * @param {Node} node
		 * @return {Array} List of nodes in document order.
		 */
		nodeChildren = function(node)
		{
			var nodes = [],
				filterSupportedNodeTypes = function(nodes, types)
				{
					var item, i, filteredNodes = [];
					
					for(i=0; i < nodes.length; i++)
					{
						item = nodes.item(i);
						if (false !== arrayIndexOf(item.nodeType, types))
						{
							filteredNodes.push(item);
						}
					}
					
					return filteredNodes;
				}
			;
			
			switch(node.nodeType)
			{
				/**
				 * @see http://www.w3.org/TR/xpath/#element-nodes
				 *
				 * The children of an element node are the element nodes, comment nodes, processing
				 * instruction nodes and text nodes for its content.
				 */
				case 1: // element,
					nodes = filterSupportedNodeTypes(node.childNodes, supportedChildNodeTypes = [
						1, // element
						3, // text
						4, // CDATASection
						7, // processing instruction
						8  // comment
					]);
					break;
				
				/**
				 * @see http://www.w3.org/TR/xpath/#root-node
				 *
				 * The element node for the document element is a child of the root node. The root
				 * node also has as children processing instruction and comment nodes for
				 * processing instructions and comments that occur in the prolog and
				 * after the end of the document element.
				 */
				case 9: // document
					nodes = filterSupportedNodeTypes(node.childNodes, supportedChildNodeTypes = [
						1, // element
						7, // processing instruction
						8  // comment
					]);
					break;
				
				case 2: // attribute
				case 3: // text
				case 4: // CDATASection
				case 7: // processing instruction
				case 8: // comment
				case 13: // namespace
					break;
				
				default:
					throw new Error('Internal Error: nodeChildren - unsupported node type: ' + node.nodeType);
					break;
			}
			
			return nodes;
		},
		
		/**
		 * Return all decendants of given node.
		 *
		 * @param {Node} node
		 * @return {Array} List of nodes in document order.
		 */
		nodeDescendant = function(node)
		{
			var nodes,
				i,
				nodes2 = []
			;
			
			nodes = nodeChildren(node);
			
			for(i = 0; i < nodes.length; i++)
			{
				nodes2.push(nodes[i]);
				nodes2.push.apply(nodes2, nodeDescendant(nodes[i]));
			}
			
			return nodes2;
		},
		
		/**
		 * Return parent of given node if there is one.
		 *
		 * @param {Node} node
		 * @return {Node}
		 */
		nodeParent = function(node)
		{
			/**
			 * All nodes, except Attr, Document, DocumentFragment, Entity, and Notation may have a parent.
			 *
			 * @see http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1060184317
			 */
			var element
			;
			
			switch(node.nodeType)
			{
				case 1: // element
				case 3: // text
				case 4: // CDATAsection
				case 7: // processing instruction
				case 8: // comment
				case 9: // document
					return node.parentNode;
					break;
				
				case 2: // Node.ATTRIBUTE_NODE
					// DOM 2 has ownerElement
					if (node.ownerElement) {
						return node.ownerElement;
					}
					
					// Other DOM 1 implementations must search the entire document...
					element = nodeAttributeSearch(node.ownerDocument, true, function(element, attribute) {
						if (attribute === node)
						{
							return true;
						}
					});
					
					return element;
					break;
				
				case 13: // Node.NAMESPACE_NODE
					return node.ownerElement;
					break;
				
				default:
					throw new Error('Internal Error: nodeParent - node type not supported: ' + node.type);
					break;
			}
		},
		
		
		/**
		 * Return ancestors of given node.
		 *
		 * @param {Node} node
		 * @return {Array} List of nodes in reverse document order
		 */
		nodeAncestor = function(node)
		{
			var parent,
				nodes = []
			;
			
			while(parent = nodeParent(node))
			{
				nodes.push(parent);
				node = parent;
			}
			
			return nodes;
		},
		
		/**
		 * Return following siblings of given node.
		 *
		 * @param {Node} node
		 * @return {Array} List of nodes in document order
		 */
		nodeFollowingSibling = function(node)
		{
			return nodeXSibling(node, 'nextSibling');
		},
		
		/**
		 * Return preceding siblings of given node.
		 *
		 * @param {Node} node
		 * @return {Array} List of nodes in reverse document order
		 */
		nodePrecedingSibling = function(node)
		{
			return nodeXSibling(node, 'previousSibling');
		},
		
		nodeXSibling = function(node, type)
		{
			var sibling,
				nodes = []
			;
			
			while (sibling = node[type])
			{
				switch(sibling.nodeType)
				{
					case 1: // element
					case 3: // text
					case 4: // CDATAsection
					case 7: // processing instruction
					case 8: // comment
					case 9: // document
						nodes.push(sibling);
						break;
						
					default:
						// don't add it
						break;
				}
				
				node = sibling;
			}
			
			return nodes;
		},
		
		/**
		 * Return following nodes of given node in document order excluding direct descendants.
		 *
		 * @param {Node} node
		 * @return {Array} List of nodes in document order
		 */
		nodeFollowing = function(node)
		{
			var nodes = [],
				parents,
				i,
				siblings,
				j
			;
			
			parents = nodeAncestor(node);
			parents.unshift(node);
			
			for(i=0; i < parents.length; i++)
			{
				siblings = nodeFollowingSibling(parents[i]);
				for(j=0; j < siblings.length; j++)
				{
					nodes.push(siblings[j]);
					nodes.push.apply(nodes, nodeDescendant(siblings[j]));
				}
			}
			
			return nodes;
		},
		
		/**
		 * Return preceding nodes of given node excluding direct ancestors.
		 *
		 * @param {Node} node
		 * @return {Array} List of nodes in reverse document order
		 */
		nodePreceding = function(node)
		{
			var nodes = [],
				parents,
				i,
				siblings,
				j
			;
			
			parents = nodeAncestor(node);
			parents.unshift(node);
			
			for(i=0; i < parents.length; i++)
			{
				siblings = nodePrecedingSibling(parents[i]);
				for(j=0; j < siblings.length; j++)
				{
					nodes.push.apply(nodes, nodeDescendant(siblings[j]).reverse());
					nodes.push(siblings[j]);
				}
			}
			
			return nodes;
		},
		
		/**
		 * Return owner document of node, or node itself if document
		 *
		 * @param {Node} node
		 * @return {Document} 
		 */
		nodeOwnerDocument = function(node)
		{
			switch(node.nodeType)
			{
				case 9: // document
					return node;
					
				default:
					return node.ownerDocument
			}
		}
		
		/**
		 * Return attributes of given element (no namespaces of course). Empty array otherwise
		 *
		 * @param {Node} node
		 * @return {Array} List of attribute nodes in document order
		 */
		nodeAttribute = function(node)
		{
			var nodes = [],
				i
			;
			
			if (node.nodeType === 1) // element
			{
				for(i=0; i<node.attributes.length; i++)
				{
					if (!node.attributes[i].specified)
					{
						continue;
					}
					
					if (false === isNamespaceAttributeNode(node.attributes[i]))
					{
						nodes.push(node.attributes[i]);
					}
				}
			}
			
			return nodes;
		},
		
		/**
		 * Return namespace nodes of given element node. Empty array otherwise
		 *
		 * @param {Node} node
		 * @param {Array} (optional) List of namespace nodes (in document order) to include
		 * @return {Array} List of namespace nodes in document order
		 */
		nodeNamespace = function(node, nsNodes)
		{
			var nodes = (nsNodes || []),
				i,
				name,
				item
			;
			
			if (node.nodeType === 1) // element
			{
				/**
				 * IE puts all namespaces inside document.namespaces for HTML node
				 *
				 * @see http://msdn.microsoft.com/en-us/library/ms537470(VS.85).aspx
				 * @see http://msdn.microsoft.com/en-us/library/ms535854(v=VS.85).aspx
				 */
				if (node.ownerDocument.documentElement === node && typeof node.ownerDocument.namespaces === 'object')
				{
					for(i=node.ownerDocument.namespaces.length-1; i>=0; i--)
					{
						item = node.ownerDocument.namespaces.item(i);
						insertNamespaceIfNotDeclared.call(this, nodes, item.name, item.urn, node);
					}
				}
				
				for(i=node.attributes.length-1; i>=0; i--)
				{
					if (!node.attributes[i].specified)
					{
						continue;
					}
					
					if (false === (name = isNamespaceAttributeNode(node.attributes[i])))
					{
						continue;
					}
					
					/**
					 * Check the default namespace
					 *
					 * @see http://www.w3.org/TR/xml-names/#defaulting
					 */
					if (name.length === 1)
					{
						insertNamespaceIfNotDeclared.call(this, nodes, '', node.attributes[i].nodeValue, node);
						continue;
					}
					
					/**
					 * Normal attribute checking for namespace declarations
					 */
					insertNamespaceIfNotDeclared.call(this, nodes, name[1], node.attributes[i].nodeValue, node);
				}
				
				/**
				 * ... resolving the namespaceURI from a given prefix using the
				 * current information available in the node's hierarchy ...
				 *
				 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
				 */
				nodeNamespace.call(this, node.parentNode, nodes);
				
				// finished with tracking down all nodes
				if (nsNodes === undefined)
				{
					// always need this namespace
					insertNamespaceIfNotDeclared.call(this, nodes, 'xml', NAMESPACE_URI_XML, node);
					
					// if the default namespace is empty, remove it
					if (nodes[0] && nodes[0].prefix === '' && nodes[0].namespaceURI === '')
					{
						nodes.shift();
					}
				}
				
				if (nsNodes === undefined)
				{
					// before returning to original caller, we need to ensure all namespace nodes are
					// specific to this parent node
					for(i = 0; i < nodes.length; i++)
					{
						if (nodes[i].ownerElement !== node)
						{
							nodes[i] = createNamespaceNode(nodes[i].prefix, nodes[i].nodeValue, node);
						}
					}
				}
			}
			
			return nodes;
		},
		
		insertNamespaceIfNotDeclared = function(namespaces, prefix, ns, parent)
		{
			var i, namespace;
			
			if (!this.opts['case-sensitive'])
			{
				prefix = prefix.toLowerCase();
			}
			
			for(i=0; i < namespaces.length; i++)
			{
				if (namespaces[i].prefix === prefix)
				{
					// namespace already set, do not allow it to be overwritten
					return false;
				}
			}
			
			namespace = createNamespaceNode(prefix, ns, parent);
			
			if (prefix === '' && ns !== null)
			{
				namespaces.unshift(namespace);
			}
			else
			{
				namespaces.push(namespace);
			}
			
			return true;
		},
		
		isNamespaceAttributeNode = function(node)
		{
			var name = node.nodeName.split(':');
			
			if (name[0] === 'xmlns')
			{
				return name;
			}
			
			return false;
		},
		
		nodeIdAttribute = function(node, attribute)
		{
			var i,
				j,
				attributes,
				namespaces,
				ns,
				name,
				id
			;
			
			if (node.nodeType === 1)
			{
				attributes = (!attribute) ? nodeAttribute(node) : [attribute];
				namespaces = nodeNamespace.call(this, node);
				
				for(i=0; i<attributes.length; i++)
				{
					name = attributes[i].nodeName.split(':');
					
					if (name.length === 1)
					{
						// set default namespace
						name[1] = name[0];
						name[0] = '';
					}
					
					// check namespace of attribute
					ns = null;
					for(j=0; j < namespaces.length; j++)
					{
						if (namespaces[j].prefix === name[0])
						{
							ns = namespaces[j].namespaceURI;
							break;
						}
					}
					
					if (ns === null)
						ns = '';
					
					if (this.opts['unique-ids'][ns] === name[1])
					{
						// found it
						return attributes[i];
					}
				}
			}
			
			return null;
		},
		
		nodeAttributeSearch = function(startNode, stopAfterFirstMatch, fn)
		{
			var i,
				j,
				elements,
				element,
				matches = [];
			;
			
			// TODO: Possibly cache attribute nodes
			elements = startNode.getElementsByTagName("*");
			for (i = 0; i < elements.length; i++) {
				element = elements.item(i);
				if (element.nodeType != 1 /*Node.ELEMENT_NODE*/)
				{
					continue;
				}
				for (j = 0; j < element.attributes.length; j++) {
					if (!element.attributes[j].specified)
					{
						continue;
					}
					
					if (fn(element, element.attributes[j]) === true)
					{
						if (stopAfterFirstMatch)
						{
							return element;
						}
						else
						{
							matches.push(element);
							break;
						}
					}
				}
			}
			
			if (stopAfterFirstMatch)
			{
				return null;
			}
			else
			{
				return matches;
			}
		},
		
		nodeExpandedName = function(node)
		{
			var name,
				namespaces,
				i,
				qname
			;
			
			switch(node.nodeType)
			{
				/**
				 * There is an element node for every element in the document. An element node has an
				 * expanded-name computed by expanding the QName of the element specified in the
				 * tag in accordance with the XML Namespaces Recommendation [XML Names]. The namespace
				 * URI of the element's expanded-name will be null if the QName has no prefix and there
				 * is no applicable default namespace.
				 */
				case 1: // element
					// TODO: provide option for case sensitivity
					
					if (typeof node.scopeName != 'undefined')
					{
						/**
						 * IE specific
						 *
						 * @see http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx
						 */
						qname = {
							prefix: (node.scopeName == 'HTML') ? '' : node.scopeName,
							name: node.nodeName
						}
					}
					else
					{
						// other browsers
						name = node.nodeName.split(':');
						
						// check for namespace prefix
						if (name.length == 1)
						{
							qname = {
								prefix: '',
								name: name[0]
							};
						}
						else
						{
							qname = {
								prefix: name[0],
								name: name[1]
							};
						}
					}
					
					if (!this.opts['case-sensitive'])
					{
						qname.prefix = qname.prefix.toLowerCase();
						qname.name = qname.name.toLowerCase();
					}
					
					// resolve namespace
					namespaces = nodeNamespace.call(this, node);
					
					for(i=0; i < namespaces.length; i++)
					{
						if (namespaces[i].prefix === qname.prefix)
						{
							qname.ns = namespaces[i].namespaceURI;
							return qname;
						}
					}
					
					if (qname.prefix === '')
					{
						qname.ns = null;
						return qname;
					}
					
					throw new Error('Internal Error: nodeExpandedName - Failed to expand namespace prefix "' + qname.prefix + '" on element: ' + node.nodeName);
					break;
				
				case 2: // attribute
					name = node.nodeName.split(':');
					
					// check for namespace prefix
					if (name.length == 1)
					{
						/**
						 * The namespace URI of the attribute's name will be null if
						 * the QName of the attribute does not have a prefix.
						 */
						return {
							prefix: '',
							ns: null,
							name: name[0]
						};
					}
					
					qname = {
						prefix: name[0],
						name: name[1]
					};
					
					if (!this.opts['case-sensitive'])
					{
						qname.prefix = qname.prefix.toLowerCase();
						qname.name = qname.name.toLowerCase();
					}
					
					// resolve namespace
					namespaces = nodeNamespace.call(this, nodeParent(node)); // attribute
					
					for(i=0; i < namespaces.length; i++)
					{
						if (namespaces[i].prefix === qname.prefix)
						{
							qname.ns = namespaces[i].namespaceURI;
							return qname;
						}
					}
					
					throw new Error('Internal Error: nodeExpandedName - Failed to expand namespace prefix "' + qname.prefix + '" on attribute: ' + node.nodeName);
					break;
					
				case 13: // namespace
					return {
						prefix: null,
						ns: null,
						name: ((!this.opts['case-sensitive']) ? node.prefix : node.prefix.toLowerCase())
					}
					break;
				
				case 7: // processing instruction
					return {
						prefix: null,
						ns: null,
						name: ((!this.opts['case-sensitive']) ? node.target : node.target.toLowerCase())
					}
					break;
				
				default:
					return false;
					break;
			}
		},
		
		nodeStringValue = function(node)
		{
			var i,
				nodeset,
				value = ''
			;
			
			switch(node.nodeType)
			{
				/**
				 * The string-value of the root node is the concatenation of the string-values of all
				 * text node descendants of the root node in document order.
				 */
				case 9: // document
				/**
				 * The string-value of an element node is the concatenation of the string-values of all
				 * text node descendants of the element node in document order.
				 */
				case 1: // element
					nodeset = evaluateExpressionTree(
						new Context(node, 1, 1, {}, {}, {}), {
							type: 'step',
							args: [
								'descendant',
								{
									type: 'nodeType',
									args: [
										'text',
										[]
									]
								}
							]
						}
					);
					
					nodeset.sortDocumentOrder();
					
					for(i=0; i< nodeset.value.length; i++)
					{
						value += nodeset.value[i].data;
					}
					
					return value;
					break;
				
				/**
				 * The string-value is the normalized value as specified by the XML Recommendation [XML].
				 * An attribute whose normalized value is a zero-length string is not treated specially:
				 * it results in an attribute node whose string-value is a zero-length string.
				 *
				 * @see http://www.w3.org/TR/1998/REC-xml-19980210#AVNormalize
				 */
				case 2: // attribute
					return node.nodeValue;
					break;
				
				/**
				 * The string-value of a namespace node is the namespace URI that is being bound to the
				 * namespace prefix;
				 * TODO-FUTURE: if it is relative, it must be resolved just like a namespace URI in an expanded-name.
				 */
				case 13: // namespace
					return node.namespaceURI;
					break;
				
				/**
				 * The string-value of a processing instruction node is the part of the processing instruction following
				 * the target and any whitespace. It does not include the terminating ?>.
				 */
				case 7: // processing instruction
				/**
				 * The string-value of comment is the content of the comment not including the opening <!-- or the closing -->.
				 */
				case 8: // comment
				/**
				 * The string-value of a text node is the character data. A text node always has at least one character of data.
				 */
				case 3: // text
				case 4: // CDATAsection
					return node.data;
					break;
				
				default:
					throw new Error('Internal Error: nodeStringValue does not support node type: ' + node.nodeType);
					break;
			}
		},
		
		createError = function(code, name, message)
		{
			var err = new Error(message);
			err.name = name;
			err.code = code;
			return err;
		},
		
		/**
		 * @param {Object} needle
		 * @param {Array} haystack
		 * @return {Number}
		 */
		arrayIndexOf = function(needle, haystack)
		{
			var i = haystack.length;
			while (i--) {
				if (haystack[i] === needle) {
					return i;
				}
			}
			return false;
		},
		
		/**
		 * @see http://www.w3.org/TR/xpath/#booleans
		 */
		compareOperator = function(left, right, operator, compareFunction)
		{
			var i,
				j,
				leftValues,
				rightValues,
				result
			;
//			console.debug('right:');
//			console.debug(right);
//			console.debug('left:');
//			console.debug(left);
			if (left instanceof NodeSetType)
			{
				if (right instanceof NodeSetType)
				{
					/**
					 * If both objects to be compared are node-sets, then the comparison
					 * will be true if and only if there is a node in the first node-set
					 * and a node in the second node-set such that the result of performing
					 * the comparison on the string-values of the two nodes is true.
					 */
					rightValues = right.stringValues();
					leftValues = left.stringValues();
					
					for(i=0; i < leftValues.length; i++)
					{
						for(j=0; j < rightValues.length; j++)
						{
							result = compareOperator(leftValues[i], rightValues[j], operator, compareFunction);
							if (result.toBoolean())
							{
								return result;
							}
						}
					}
				}
				else
				{
					/**
					 * If one object to be compared is a node-set and the other is a number,
					 * then the comparison will be true if and only if there is a node in the node-set
					 * such that the result of performing the comparison on the number to be compared
					 * and on the result of converting the string-value of that node to a
					 * number using the number function is true.
					 */
					if (right instanceof NumberType)
					{
						leftValues = left.stringValues();
						
						for(i=0; i < leftValues.length; i++)
						{
							result = compareOperator(new NumberType(leftValues[i].toNumber()), right, operator, compareFunction);
							if (result.toBoolean())
							{
								return result;
							}
						}
					}
					/**
					 * JavaRosa addition:
					 * Check whether string is a date object or a datestring. A datestring is converted to an
					 * instance of DateType. Note that we've already checked for numbers and that DateType is basically
					 * just the native JavaScript Date object. So any string, except a number string, that can convert to
					 * a valid date is considered a date string. It is safe enough hopefully....
					 */
					else if (right instanceof DateType || (right instanceof StringType && right.isDateString()))
					{
						if (right instanceof StringType)
						{
							//console.debug('found right date string: '+right+' and will convert to a Date object');
							right = new DateType(right);
						}
						//console.debug('found right date type: '+right);

						leftValues = left.stringValues();
						
						for(i=0; i < leftValues.length; i++)
						{
							result = compareOperator(new DateType(leftValues[i].toDate()), right, operator, compareFunction);
							if (result.toBoolean())
							{
								return result;
							}
						}
					}
					/**
					 * If one object to be compared is a node-set and the other is a string, then the
					 * comparison will be true if and only if there is a node in the node-set such
					 * that the result of performing the comparison on the string-value of
					 * the node and the other string is true.
					 */
					else if (right instanceof StringType)
					{
						leftValues = left.stringValues();
						
						for(i=0; i < leftValues.length; i++)
						{
							result = compareOperator(leftValues[i], right, operator, compareFunction);
							if (result.toBoolean())
							{
								return result;
							}
						}
					}
					/**
					 * If one object to be compared is a node-set and the other is a boolean, then the comparison
					 * will be true if and only if the result of performing the comparison on the boolean
					 * and on the result of converting the node-set to a boolean using the boolean function is true.
					 */
					else
					{
						return compareOperator(new BooleanType(left.toBoolean()), right, operator, compareFunction);
					}
				}
			}
			else
			{
				if (right instanceof NodeSetType)
				{
					/**
					 * If one object to be compared is a node-set and the other is a number,
					 * then the comparison will be true if and only if there is a node in the node-set
					 * such that the result of performing the comparison on the number to be compared
					 * and on the result of converting the string-value of that node to a
					 * number using the number function is true.
					 */
					if (left instanceof NumberType)
					{
						rightValues = right.stringValues();
						
						for(i=0; i < rightValues.length; i++)
						{
							result = compareOperator(left, new NumberType(rightValues[i].toNumber()), operator, compareFunction);
							if (result.toBoolean())
							{
								return result;
							}
						}
					}
					/** JavaRosa addition:
					 * If one object to be compared is a date object or a datestring....etc. A datestring is converted to an
					 * instance of DateType. Note that we've already checked for numbers and that DateType is basically
					 * just the native JavaScript Date object. So any string, except a number string, that can convert to
					 * a valid date is considered a date string. It is safe enough hopefully...
					 */
					else if (left instanceof DateType || (left instanceof StringType && left.isDateString()))
					{
						if (left instanceof StringType)
						{
							//console.debug('found left date string: '+left.value+' and will convert to a Date object');
							left = new DateType(left);
						}
						//console.debug('found date type: '+left.value);

						rightValues = right.stringValues();

						for(i=0; i < rightValues.length; i++)
						{
							result = compareOperator(left, new DateType(rightValues[i].toDate()), operator, compareFunction);
							if (result.toBoolean())
							{
								return result;
							}
						}
					}
					/**
					 * If one object to be compared is a node-set and the other is a string, then the
					 * comparison will be true if and only if there is a node in the node-set such
					 * that the result of performing the comparison on the string-value of
					 * the node and the other string is true.
					 */
					else if (left instanceof StringType)
					{
						rightValues = right.stringValues();
						
						for(i=0; i < rightValues.length; i++)
						{
							result = compareOperator(left, rightValues[i], operator, compareFunction);
							if (result.toBoolean())
							{
								return result;
							}
						}
					}
					/**
					 * If one object to be compared is a node-set and the other is a boolean, then the comparison
					 * will be true if and only if the result of performing the comparison on the boolean
					 * and on the result of converting the node-set to a boolean using the boolean function is true.
					 */
					else
					{
						return compareOperator(left, new BooleanType(right.toBoolean()), operator, compareFunction);
					}
				}
				else
				{
					switch(operator)
					{
						/**
						 * When neither object to be compared is a node-set and the operator is = or !=,
						 * then the objects are compared by converting them to a common type as
						 * follows and then comparing them.
						 */
						case '=':
						case '!=':
							/**
							 * If at least one object to be compared is a boolean, then each object to be
							 * compared is converted to a boolean as if by applying the boolean function.
							 */
							if (left instanceof BooleanType || right instanceof BooleanType)
							{
								return new BooleanType(compareFunction(left.toBoolean(), right.toBoolean()));
							}
							/**
							 * Otherwise, if at least one object to be compared is a number, then each object
							 * to be compared is converted to a number as if by applying the number function.
							 */
							else if (left instanceof NumberType || right instanceof NumberType)
							{
								return new BooleanType(compareFunction(left.toNumber(), right.toNumber()));
							}
							
							/**
							 * Otherwise, both objects to be compared are converted to strings
							 * as if by applying the string function.
							 */
							return new BooleanType(compareFunction(left.toString(), right.toString()));
							
							break;
						
						/**
						 * When neither object to be compared is a node-set and the operator is <=, <, >= or >,
						 * then the objects are compared by converting both objects to numbers and comparing
						 * the numbers according to IEEE 754.
						 */
						default:
							return new BooleanType(compareFunction(left.toNumber(), right.toNumber()));
							break;
					}
				}
			}
			
			return new BooleanType(false);
		},
		
		getComparableNode = function(node)
		{
			switch(node.nodeType)
			{
				case 2: // attribute
				case 3: // text
				case 4: // CDATASection
				case 7: // processing instruction
				case 8: // comment
					return nodeParent(node);
					break;
				
				case 1: // element
				case 9: // document
					// leave as is
					return node;
					break;
				
				case 13: // namespace
				default:
					throw new Error('Internal Error: getComparableNode - Node type not supported: ' + node.nodeType);
					break;
			}
		},
		
		compareDocumentPosition = function(a, b)
		{
			var result, nodes, i;
			
			if (a.nodeType == 13 &&
				b.nodeType == 13 &&
				a.ownerElement == b.ownerElement
			) {
				// identical
				if (a === b) return 0;
				
				nodes = nodeNamespace.call(currentExpression, a.ownerElement);
				
				for(i=0; i < nodes.length; i++)
				{
					if (nodes[i] === a)
					{
						result = 4;
						break;
					}
					else if (nodes[i] === b)
					{
						result = 2;
						break;
					}
				}
			}
			else
			{
				if (a.nodeType == 13) a = a.ownerElement;
				if (b.nodeType == 13) b = b.ownerElement;
				
				result = compareDocumentPositionNoNamespace(a, b);
			}
			
			return result;
		},
		
		/**
		 * @see http://ejohn.org/blog/comparing-document-position/
		 */
		compareDocumentPositionNoNamespace = function(a, b)
		{
			var a2,
				b2,
				result,
				i,
				item,
				compareOriginalVsComparableNode = function(a, a2, b, b2, result, v16, v8, v4, v2) {
					// if a contains b2 or a == b2
					if (result === 0 || (result & v16) === v16)
					{
						// return result
						return v4 + v16;
					}
					// else if b2 contains a
					else if ((result & v8) === v8)
					{
						// since b != b2, b is an attribute
						// and since a == a2, a is a node,
						// so b has to come before a
						return v2;
					}
					else
					{
						// return result
						return result;
					}
				}
			;
			
			// check for native implementation
			if (a.compareDocumentPosition)
			{
				return a.compareDocumentPosition(b);
			}
			
			if (a === b)
			{
				return 0;
			}
			
			a2 = getComparableNode(a);
			b2 = getComparableNode(b);
			
			// handle document case
			if (a2.nodeType === 9)
			{
				if (b2.nodeType === 9)
				{
					if (a2 !== b2)
					{
						return 1; // different documents
					}
					else
					{
						result = 0; // same nodes
					}
				}
				else
				{
					if (a2 !== b2.ownerDocument)
					{
						return 1; // different documents
					}
					else
					{
						result = 4 + 16; // a2 before b2, a2 contains b2
					}
				}
			}
			else
			{
				if (b2.nodeType === 9)
				{
					if (b2 !== a2.ownerDocument)
					{
						return 1; // different documents
					}
					else
					{
						result = 2 + 8 // b2 before a2, b2 contains a2
					}
				}
				else
				{
					if (a2.ownerDocument !== b2.ownerDocument)
					{
						return 1; // different documents
					}
					else
					{
						// do a contains comparison for element nodes
						if (!a2.contains || typeof a2.sourceIndex === 'undefined' || !b2.contains || typeof b2.sourceIndex === 'undefined')
						{
							throw new Error('Cannot compare elements. Neither "compareDocumentPosition" nor "contains" available.');
						}
						else
						{
							result = 
								(a2 != b2 && a2.contains(b2) && 16) +
								(a2 != b2 && b2.contains(a2) && 8) +
								(a2.sourceIndex >= 0 && b2.sourceIndex >= 0
									? (a2.sourceIndex < b2.sourceIndex && 4) + (a2.sourceIndex > b2.sourceIndex && 2)
									: 1 ) +
								0 ;
						}
					}
				}
			}
			
			if (a === a2 && b === b2)
			{
				return result;
			}
			else if (a === a2)
			{
				return compareOriginalVsComparableNode(a, a2, b, b2, result, 16, 8, 4, 2);
			}
			else if (b === b2)
			{
				return compareOriginalVsComparableNode(b, b2, a, a2, result, 8, 16, 2, 4);
			}
			else
			{
				// if a2 contains b2
				if ((result & 16) === 16)
				{
					// since a and b are attributes, a has to come before b
					return 4;
				}
				// else if b2 contains a2
				else if ((result & 8) === 8)
				{
					// since a and b are attributes, b has to come before a
					return 2;
				}
				// else if a2 === b2
				else if (result === 0)
				{
					// since a and b are attributes, and both have the same parent
					// find out which attribute comes first
					
					// return "a pre b" or "b pre a" depending on a or b occurs first in a2.childNodes
					for(i=0; i<a2.attributes.length; i++)
					{
						item = a2.attributes[i];
						if (!item.specified) continue;
						
						if (item === b)
						{
							return 2;
						}
						else if (item === a)
						{
							return 4;
						}
					}
					
					throw new Error('Internal Error: compareDocumentPosition failed to sort attributes.');
				}	
				// else
				else
				{
					// return result
					return result;
				}
			}
			
			throw new Error('Internal Error: compareDocumentPosition failed to sort nodes.');
		},
		
		nodeSupported = function(contextNode)
		{
			if (!contextNode) {
				throw createError(9, 'NOT_SUPPORTED_ERR', 'Context node was not supplied.');
			}
			else if (
					contextNode.nodeType != 9 && // Document
					contextNode.nodeType != 1 && // Element
					contextNode.nodeType != 2 && // Attribute
					contextNode.nodeType != 3 && // Text
					contextNode.nodeType != 4 && // CDATASection
					contextNode.nodeType != 8 && // Comment
					contextNode.nodeType != 7 && // ProcessingInstruction
					contextNode.nodeType != 13   // XPathNamespace
			) {
				throw createError(9, 'NOT_SUPPORTED_ERR', 'The supplied node type is not supported. (nodeType: ' + contextNode.nodeType + ')');
			}
			else if (contextNode.nodeType == 2 && !contextNode.specified)
			{
				throw createError(9, 'NOT_SUPPORTED_ERR', 'The supplied node is a non-specified attribute node. Only specified attribute nodes are supported.');
			}
		},
		
		createNamespaceNode = function(prefix, ns, parent)
		{
			var i, namespaceNode;
			
			for(i = 0; i < namespaceCache.length; i++)
			{
				namespaceNode = namespaceCache[i];
				
				if (namespaceNode.prefix === prefix &&
					namespaceNode.nodeValue === ns &&
					namespaceNode.ownerElement === parent)
				{
					// we have already created this namespace node, so use this one
					return namespaceNode;
				}
			}
			
			// no such node created in the past, so create it now
			namespaceNode = new XPathNamespace(prefix, ns, parent);
			
			// add node to cache
			namespaceCache.push(namespaceNode);
			
			return namespaceNode;
		}
	;
	
	BaseType = function(value, type, supports)
	{
		this.value = value;
		this.type = type;
		this.supports = supports
	}
	
	BaseType.prototype = {
		value: null,
		type: null,
		supports: [],
		
		toBoolean: function() {
			throw new Error('Unable to convert "' + this.type + '" to "boolean".');
		},
		
		toString: function() {
			throw new Error('Unable to convert "' + this.type + '" to "string".');
		},
		
		toNumber: function() {
			throw new Error('Unable to convert "' + this.type + '" to "number".');
		},
		
		toNodeSet: function() {
			throw new Error('Unable to convert "' + this.type + '" to "node-set".');
		},

		toDate: function() {
			throw new Error('Unable to convert "' + this.type + '" to "date".');
		},
		
		/**
		 * Check if this type can be converted to a particular javascript type.
		 */
		canConvertTo: function(type)
		{
			return false !== arrayIndexOf(type, this.supports);
		}
	}
	
	BooleanType = function(value)
	{
		BaseType.call(this, value, 'boolean', [
			'boolean',
			'string',
			'number',
			'date'
		]);
	}
	BooleanType.prototype = new BaseType;
	BooleanType.constructor = BooleanType;
	BooleanType.prototype.toBoolean = function() {
		return this.value;
	}
	/**
	 * The boolean false value is converted to the string false. The boolean true value is converted to the string true.
	 */
	BooleanType.prototype.toString = function() {
		return (this.value === true) ? 'true' : 'false';
	}
	/**
	 * boolean true is converted to 1; boolean false is converted to 0
	 */
	BooleanType.prototype.toNumber = function() {
		return (this.value) ? 1 : 0;
	}
	BooleanType.prototype.toDate = function(){
		return null;
	}
	
	NodeSetType = function(value, documentOrder)
	{
		BaseType.call(this, value, 'node-set', [
			'boolean',
			'string',
			'number',
			'node-set',
			'date'
		]);
		
		this.docOrder = (documentOrder || 'unsorted');
	}
	NodeSetType.prototype = new BaseType;
	NodeSetType.constructor = NodeSetType;
	/**
	 * a node-set is true if and only if it is non-empty
	 */
	NodeSetType.prototype.toBoolean = function() {
		return (this.value.length > 0) ? true : false;
	}
	/**
	 * A node-set is converted to a string by returning the string-value of the node
	 * in the node-set that is first in document order. If the node-set
	 * is empty, an empty string is returned.
	 */
	NodeSetType.prototype.toString = function() {
		if (this.value.length < 1)
		{
			return '';
		}
		
		this.sortDocumentOrder();
		return nodeStringValue(this.value[0]);
	}
	/**
	 * a node-set is first converted to a string as if by a call to the string
	 * function and then converted in the same way as a string argument
	 */
	NodeSetType.prototype.toNumber = function() {
		return (new StringType(this.toString())).toNumber();
	}
	NodeSetType.prototype.toNodeSet = function() {
		return this.value;
	}
	NodeSetType.prototype.toDate = function(){
		//console.log('Nodeset.toDate() going to return:')
		//console.log((new StringType(this.toString())).toDate());
		return (new StringType(this.toString())).toDate();
	}
	NodeSetType.prototype.sortDocumentOrder = function() {
		switch(this.docOrder)
		{
			case 'document-order':
				// already sorted
				break;
				
			case 'reverse-document-order':
				// reverse the order
				this.value.reverse();
				break;
				
			default:
				this.value.sort(function(a, b) {
					var result = compareDocumentPosition(a, b);
					
					if ( (result & 4) == 4 ) // a before b
					{
						return -1;
					}
					else if ( (result & 2) == 2 ) // b before a
					{
						return 1;
					}
					else
					{
						throw new Error('NodeSetType.sortDocumentOrder - unexpected compare result: ' + result);
					}
				});
				break;
		}
		
		this.docOrder = 'document-order';
	}
	NodeSetType.prototype.sortReverseDocumentOrder = function() {
		switch(this.docOrder)
		{
			case 'document-order':
				// reverse the order
				this.value.reverse();
				break;
				
			case 'reverse-document-order':
				// already sorted
				break;
				
			default:
				this.sortDocumentOrder();
				this.value.reverse();
				break;
		}
		
		this.docOrder = 'reverse-document-order';
	}
	
	NodeSetType.prototype.append = function(nodeset) {
		var length,
			i = 0,
			j = 0,
			result
		;
		
		if(!nodeset instanceof NodeSetType)
		{
			throw new Error('NodeSetType can be passed into NodeSetType.append method');
		}
		
		// use merge sort algorithm
		this.sortDocumentOrder();
		nodeset.sortDocumentOrder();
		
		while(i < this.value.length && j < nodeset.value.length)
		{
			result = compareDocumentPosition(this.value[i], nodeset.value[j]);
			
			if (result == 0) // same nodes
			{
				// ignore duplicates
				j++
			}
			else if ( (result & 4) == 4 ) // a before b
			{
				i++;
			}
			else if ( (result & 2) == 2 ) // b before a
			{
				this.value.splice(i, 0, nodeset.value[j]);
				i++;
				j++;
			}
			else
			{
				throw new Error('Internal Error: NodeSetType.append - unable to sort nodes. (result: ' + result + ')');
			}
		}
		
		// append remaining elements
		for (;j < nodeset.value.length; j++)
		{
			this.value.push(nodeset.value[j]);
		}
		
		this.docOrder = 'document-order';
	}
	
	NodeSetType.prototype.stringValues = function()
	{
		var i, obj,
			values = []
		;
		
		for(i=0; i < this.value.length; i++)
		{
			//seems like an ugly hack, original commented out below
			obj = new StringType(nodeStringValue(this.value[i]));
			if (obj.isDateString()){
				//console.debug('obj:');
				//console.debug(obj);
				obj = new DateType(obj.value);
				//console.debug('converted obj:');
				//console.debug(obj);
			} 
			values.push(obj);
			//values.push(new StringType(nodeStringValue(this.value[i])));
		}
		
		return values;
	}
	
	StringType = function(value)
	{
		BaseType.call(this, value, 'string', [
			'boolean',
			'string',
			'number',
			'date'
		]);
	}
	StringType.prototype = new BaseType;
	StringType.constructor = StringType;
	/**
	 * a string is true if and only if its length is non-zero
	 */
	StringType.prototype.toBoolean = function() {
		return (this.value.length > 0) ? true : false;
	}
	StringType.prototype.toString = function() {
		return this.value;
	}
	/**
	 * a string that consists of optional whitespace followed by an optional minus sign
	 * followed by a Number followed by whitespace is converted to the IEEE 754 number
	 * that is nearest (according to the IEEE 754 round-to-nearest rule) to the mathematical
	 * value represented by the string; any other string is converted to NaN
	 */
	StringType.prototype.toNumber = function() {
		var result;
		
		if (this.isDateString(this.value)){
			return new DateType(this.value).toNumber();
		}
			
		// Digits ('.' Digits?)?
		result = this.value.match(/^[ \t\r\n]*(-?[0-9]+(?:[.][0-9]*)?)[ \t\r\n]*$/)
		if (result !== null)
		{
			return parseFloat(result[1]);
		}
		
		// '.' Digits
		result = this.value.match(/^[ \t\r\n]*(-?[.][0-9]+)[ \t\r\n]*$/)
		if (result !== null)
		{
			return parseFloat(result[1]);
		}
		
		// Invalid number
		return Number.NaN;
	}
	StringType.prototype.toDate = function() {
		return new Date(this.value);
	}
	/**
	 * Test whether the value of a String is (probably a date string)
	 * It seems like a bit of a hack (and inefficient because it is called for all strings)
	 * but not sure how else to do this.
	 * Note that "'4'" and '"4'" can be parse as valid dates.
	 * 
	 * @return {Boolean} 
	 */
	StringType.prototype.isDateString = function(){	
		// if it is a number
		if (!isNaN(this.value)){
			return false;
		}
		// if JavaScript cannot parse the value to a date
		if (isNaN(Date.parse(this.value))){
			return false;
		}
		// if it does not conform to this crude regex 
		// (required on old versions of Android webview that parse weird strings such as "opv_3" to a valid date...)
		// it is just a bug fix we can remove around 2018 probably
		if (!/('|")?[0-9]{4}(-|\/)[0-9]{2}(-|\/)[0-9]{2}('|")?/.test(this.value)){
			return false;
		}
		console.debug('found string value that passes check for datestringiness: '+this.value);
		return true;
	}
	
	NumberType = function(value)
	{
		BaseType.call(this, value, 'number', [
			'boolean',
			'string',
			'number',
			'date'
		]);
	}
	NumberType.prototype = new BaseType;
	NumberType.constructor = NumberType;
	/**
	 * a number is true if and only if it is neither positive or negative zero nor NaN
	 */
	NumberType.prototype.toBoolean = function() {
		return (this.value !== 0 && !isNaN(this.value)) ? true : false;
	}
	/**
	 * A number is converted to a string as follows:
	 *     NaN is converted to the string NaN
	 *     positive zero is converted to the string 0
	 *     negative zero is converted to the string 0
	 *     positive infinity is converted to the string Infinity
	 *     negative infinity is converted to the string -Infinity
	 *     if the number is an integer, the number is represented in decimal form as a Number with no decimal point
	 *     and no leading zeros, preceded by a minus sign (-) if the number is negative ...
	 *     otherwise, the number is represented in decimal form as a Number
	 */
	NumberType.prototype.toString = function() {
		return this.value.toString();
	}
	NumberType.prototype.toNumber = function() {
		return this.value;
	}
	/**
	 * This is where JavaRosa's date object deviates from the built-in 
	 * javascript Date object. It instantiates a date based on the amount of days since the 
	 * epoch (and not milliseconds)
	 * 
	 */
	NumberType.prototype.toDate = function() {
		return new Date(this.value * (1000 * 60 * 60 * 24) );
	}
	/** 
     * Date type used in JavaRosa functions 
     **/
    DateType = function(value)
    {
    	BaseType.call(this, value, 'date', [
    		'date',
    		'string',
    		'number',
    		'boolean'
    	])
    }

	DateType.prototype = new BaseType;
	DateType.constructor = DateType;

	DateType.prototype.toDate = function() {
		return new Date(this.value);
	}
	//maybe the string should be build 'manually' with milliseconds appended to it
	//more in line with JavaRosa
	DateType.prototype.toString = function(){
		return new Date(this.value).toUTCString();
	}
	//gets milliseconds since epoch
	DateType.prototype.toNumber = function(){
		return ( new Date(this.value).getTime() ) / (1000 * 60 * 60 * 24) ;
	}

	DateType.prototype.toBoolean = function(){
		return (!isNaN(new Date(this.value).getTime()));
	}

	/**
	 * A new exception has been created for exceptions specific to these XPath interfaces.
	 *
	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathException
	 * 
	 */
	XPathException = function(code, message)
	{
		var err;
		
		/**
		 * @type {number}
		 */
		this.code = code;
		
		switch(this.code)
		{
			case XPathException.INVALID_EXPRESSION_ERR:
				this.name = 'INVALID_EXPRESSION_ERR';
				break;
				
			case XPathException.TYPE_ERR:
				this.name = 'TYPE_ERR';
				break;
			
			default:
				err = new Error('Unsupported XPathException code: ' + this.code);
				err.name = 'XPathExceptionInternalError';
				throw err;
				break;
		}
		
		this.message = (message || "");
	}
	
	XPathException.prototype.toString = function() {
		return 'XPathException: "' + this.message + '"'
			+ ', code: "' + this.code + '"'
			+ ', name: "' + this.name + '"'
		;
	}
	
	/**
	 * If the expression has a syntax error or otherwise is not a legal expression
	 * according to the rules of the specific XPathEvaluator or contains specialized
	 * extension functions or variables not supported by this implementation.
	 *
	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#INVALID_EXPRESSION_ERR
	 */
	XPathException.INVALID_EXPRESSION_ERR = 51;
	
	/**
	 * If the expression cannot be converted to return the specified type.
	 *
	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#TYPE_ERR
	 */
	XPathException.TYPE_ERR = 52;
	
	/**
	 * The evaluation of XPath expressions is provided by XPathEvaluator. In a DOM
	 * implementation which supports the XPath 3.0 feature, as described above,
	 * the XPathEvaluator interface will be implemented on the same object which
	 * implements the Document interface permitting it to be obtained by the usual
	 * binding-specific method such as casting or by using the DOM Level 3
	 * getInterface method. In this case the implementation obtained from the Document
	 * supports the XPath DOM module and is compatible with the XPath 1.0 specification.
	 *
	 * Evaluation of expressions with specialized extension functions or variables
	 * may not work in all implementations and is, therefore, not portable.
	 * XPathEvaluator implementations may be available from other sources that
	 * could provide specific support for specialized extension functions or variables
	 * as would be defined by other specifications.
	 *
	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator
	 */
	XPathEvaluator = function(options)
	{
		var option, defaultOption, found;
		
		for (option in options)
		{
			found = false;
			for(defaultOption in this.opts)
			{
				if (option === defaultOption)
				{
					this.opts[option] = options[option];
					found = true;
					break;
				}
			}
			if (found)
				continue;
			
			throw new Error('Unsupported option: ' + option);
		}
		
		// define unique ids
		this.opts['unique-ids'][NAMESPACE_URI_XML] = 'id';
		this.opts['unique-ids'][NAMESPACE_URI_XHTML] = 'id';
	}
	XPathEvaluator.prototype = {
		opts: {
			/**
			 * List of unique ID for each namespace
			 *
			 * @see http://www.w3.org/TR/xpath/#unique-id
			 */
			'unique-ids': {},
			
			/**
			 * Specifies whether node name tests should be case sensitive
			 */
			'case-sensitive': false
		},
		
		/**
		 * Creates a parsed XPath expression with resolved namespaces. This is
		 * useful when an expression will be reused in an application since it
		 * makes it possible to compile the expression string into a more efficient
		 * internal form and preresolve all namespace prefixes which occur within
		 * the expression.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createExpression
		 * @param {string} expression The XPath expression string to be parsed.
		 * @param {XPathNSResolver} resolver The resolver permits translation of all prefixes,
		 *        including the xml namespace prefix, within the XPath expression into
		 *        appropriate namespace URIs. If this is specified as null, any namespace
		 *        prefix within the expression will result in DOMException being thrown
		 *        with the code NAMESPACE_ERR.
		 * @return {XPathExpression} The compiled form of the XPath expression.
		 * @exception {XPathException} INVALID_EXPRESSION_ERR: Raised if the expression is not
		 *        legal according to the rules of the XPathEvaluator.
		 * @exception {DOMException} NAMESPACE_ERR: Raised if the expression contains namespace
		 *        prefixes which cannot be resolved by the specified XPathNSResolver.
		 */
		createExpression: function(expression, resolver)
		{
			var tree,
				message,
				i,
				nsMapping = {},
				prefix
			;
			
			// Parse the expression
			try {
				tree = XPathJS._parser.parse(expression);
			} catch(err) {
				message = 'The expression is not a legal expression.';
				if (err instanceof XPathJS._parser.SyntaxError)
				{
					message += ' (line: ' + err.line + ', character: ' + err.column + ')';
				}
				else
				{
					// this shouldn't happen, but it's here just in case
					message += ' (' + err.message + ')';
				}
				throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, message);
			}
			
			// Resolve namespaces if any
			if (tree.nsPrefixes.length > 0)
			{
				// ensure resolver supports lookupNamespaceURI function
				if (typeof resolver != 'object' ||
					typeof resolver.lookupNamespaceURI === 'undefined')
				{
					throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
						"No namespace resolver provided or lookupNamespaceURI function not supported."
					);
				}
				
				for(i=0; i < tree.nsPrefixes.length; i++)
				{
					prefix = tree.nsPrefixes[i];
					nsMapping[prefix] = resolver.lookupNamespaceURI(prefix);
					
					if (nsMapping[prefix] === null)
					{
						throw createError(14, 'NAMESPACE_ERR', 'Undefined namespace prefix "' + prefix + '" in the context of the given resolver.');
					}
				}
			}
			
			return new XPathExpression(tree, nsMapping, this.opts);
		}
		
		/**
		 * Adapts any DOM node to resolve namespaces so that an XPath expression
		 * can be easily evaluated relative to the context of the node where it
		 * appeared within the document. This adapter works like the DOM Level 3
		 * method lookupNamespaceURI on nodes in resolving the namespaceURI from a
		 * given prefix using the current information available in the node's
		 * hierarchy at the time lookupNamespaceURI is called. also correctly
		 * resolving the implicit xml prefix.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
		 * @param {Node} nodeResolver The node to be used as a context for namespace resolution.
		 * @return {XPathNSResolver} Resolves namespaces with respect to the definitions in scope for a specified node.
		 */
		,createNSResolver: function(nodeResolver)
		{
			return new XPathNSResolver(nodeResolver);
		}
		
		/**
		 * Evaluates an XPath expression string and returns a result of the specified type if possible.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-evaluate
		 * @param {string} expression The XPath expression string to be parsed and evaluated.
		 * @param {Node} contextNode The context is context node for the evaluation of this XPath expression.
		 *        If the XPathEvaluator was obtained by casting the Document then this must
		 *        be owned by the same document and must be a Document, Element, Attribute,
		 *        Text, CDATASection, Comment, ProcessingInstruction, or XPathNamespace node.
		 *        If the context node is a Text or a CDATASection, then the context is
		 *        interpreted as the whole logical text node as seen by XPath, unless the node
		 *        is empty in which case it may not serve as the XPath context.
		 * @param {XPathNSResolver} resolver The resolver permits translation of all prefixes, including the
		 *        xml namespace prefix, within the XPath expression into appropriate namespace
		 *        URIs. If this is specified as null, any namespace prefix within the
		 *        expression will result in DOMException being thrown with the code NAMESPACE_ERR.
		 * @param {number} type If a specific type is specified, then the result will be returned as the corresponding type.
		 *        For XPath 1.0 results, this must be one of the codes of the XPathResult interface.
		 * @param {XPathResult} result The result specifies a specific result object which may be reused and
		 *        returned by this method. If this is specified as nullor the implementation does
		 *        not reuse the specified result, a new result object will be constructed and returned.
		 * @return {XPathResult} The result of the evaluation of the XPath expression.
		 * @exception {XPathException} INVALID_EXPRESSION_ERR: Raised if the expression is not
		 *        legal according to the rules of the XPathEvaluator.
		 *        TYPE_ERR: Raised if the result cannot be converted to return the specified type.
		 * @exception {Error} NAMESPACE_ERR: Raised if the expression contains namespace prefixes
		 *        which cannot be resolved by the specified XPathNSResolver.
		 *        WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by this XPathEvaluator.
		 *        NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath context node or the request
		 *        type is not permitted by this XPathEvaluator.
		 */
		,evaluate: function(expression, contextNode, resolver, type, result)
		{
			// create expression
			var expression = this.createExpression(expression, resolver);
			
			// evaluate expression
			return expression.evaluate(contextNode, type, result);
		}
	};
	
	/**
	 * The XPathExpression interface represents a parsed and resolved XPath expression.
	 *
	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathExpression
	 */
	XPathExpression = function(parsedExpression, namespaceMapping, options) {
		this.parsedExpression = parsedExpression;
		this.namespaceMapping = namespaceMapping;
		this.opts = options || {};
	}
	
	XPathExpression.prototype = {
		/**
		 * Parsed expression tree
		 *
		 * @type {Object}
		 */
		parsedExpression: null,
		
		/**
		 * Mapping of prefixes to namespaces
		 *
		 * @type {Object}
		 */
		namespaceMapping: null,
		
		/**
		 * Options used to tweak expression evaluation
		 *
		 * @type {Object}
		 */
		opts: {},
		
		/**
		 * Evaluates this XPath expression and returns a result.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathExpression-evaluate
		 * @param {Node} contextNode The context is context node for the evaluation of this XPath expression.
		 *        If the XPathEvaluator was obtained by casting the Document then this must
		 *        be owned by the same document and must be a Document, Element, Attribute,
		 *        Text, CDATASection, Comment, ProcessingInstruction, or XPathNamespace node.
		 *        If the context node is a Text or a CDATASection, then the context is
		 *        interpreted as the whole logical text node as seen by XPath, unless the node
		 *        is empty in which case it may not serve as the XPath context.
		 * @param {number} type If a specific type is specified, then the result will be
		 *        coerced to return the specified type relying on XPath conversions and
		 *        fail if the desired coercion is not possible. This must be one of the
		 *        type codes of XPathResult.
		 * @param {XPathResult} result The result specifies a specific result object which may be reused and
		 *        returned by this method. If this is specified as nullor the implementation does
		 *        not reuse the specified result, a new result object will be constructed and returned.
		 * @return {XPathResult} The result of the evaluation of the XPath expression.
		 * @exception {XPathException} TYPE_ERR: Raised if the result cannot be converted to return the specified type.
		 * @exception {Error} WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by this XPathEvaluator.
		 *        NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath context node or the request
		 *        type is not permitted by this XPathEvaluator.
		 */
		evaluate: function(contextNode, type, result)
		{
			var context;
			
			// HACK: track current expression being evaluated
			currentExpression = this;
			
			// check if our implementation supports this node type
			nodeSupported(contextNode);
			
			context = new Context(contextNode, 1, 1, {}, functions, this.namespaceMapping, this.opts);
			
			return XPathResult.factory(
				context,
				type,
				evaluateExpressionTree(context, this.parsedExpression.tree)
			)
		}
	}
	
	/**
	 * Expression evaluation occurs with respect to a context.
	 *
	 * @see http://www.w3.org/TR/xpath/#dt-context-node
	 */
	Context = function(node, position, size, vars, functions, namespaceMap, options)
	{
		this.node = node;
		this.pos = position;
		this.size = size;
		this.vars = vars;
		this.fns = functions;
		this.nsMap = namespaceMap;
		this.opts = options || {};
	}
	
	Context.prototype = {
		// a node (the context node)
		node: null,
		
		// a pair of non-zero positive integers (the context position and the context size)
		pos: null,
		size: null,
		
		// a set of variable bindings
		vars: null,
		
		// a function library
		fns: null,
		
		// the set of namespace declarations in scope for the expression
		nsMap: null,
		
		// Options used to tweak expression evaluation
		opts: null,
		
		clone: function(node, position, size)
		{
			return new Context(
				node || this.node,
				(typeof position != 'undefined') ? position : this.pos,
				(typeof size != 'undefined') ? size : this.size,
				this.vars,
				this.fns,
				this.nsMap,
				this.opts
			);
		}
	};
	
	/**
	 * The XPathNSResolver interface permit prefix strings in the expression to be
	 * properly bound to namespaceURI strings. XPathEvaluator can construct an
	 * implementation of XPathNSResolver from a node, or the interface may be
	 * implemented by any application. 
	 *
	 * @see http://www.w3.org/TR/DOM-Lstring-3-XPath/xpath.html#XPathNSResolver
	 */
	XPathNSResolver = function(nodeResolver)
	{
		nodeSupported(nodeResolver);
		this.node = nodeResolver;
	}
	
	XPathNSResolver.prototype = {
		
		/**
		 * Node used as a reference to resolve prefix to a namespace.
		 *
		 * @type {Node}
		 */
		node: null,
		
		/**
		 * Look up the namespace URI associated to the given namespace prefix.
		 * The XPath evaluator must never call this with a null or empty argument,
		 * because the result of doing this is undefined.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathNSResolver-lookupNamespaceURI
		 * @param {string} prefix The prefix to look for.
		 * @return {string} Returns the associated namespace URI or null if none is found.
		 */
		lookupNamespaceURI: function(prefix)
		{
			var node = this.node
				,i
				,namespace
				,tmpNode
			;
			
			switch(prefix)
			{
				case 'xml': // http://www.w3.org/TR/REC-xml-names/#xmlReserved
					return NAMESPACE_URI_XML;
					break;
				
				case 'xmlns': // http://www.w3.org/TR/REC-xml-names/#xmlReserved
					return NAMESPACE_URI_XMLNS;
					break;
				
				default:
					switch(this.node.nodeType)
					{
						case 9: // Node.DOCUMENT_NODE
							node = node.documentElement;
							break;
							
						case 1: // Node.ELEMENT_NODE
							// leave as is
							break;
							
						default:
							node = nodeParent(node);
							break;
					}
					
					if (node != null && node.nodeType == 1 /*Node.ELEMENT_NODE*/)
					{
						/**
						 * Check the default namespace
						 *
						 * @see http://www.w3.org/TR/xml-names/#defaulting
						 */
						if ('' == prefix)
						{
							namespace = node.getAttribute('xmlns');
							if (namespace  !== null)
							{
								return namespace;
							}
						}
						/**
						 * IE puts all namespaces inside document.namespaces for HTML node
						 *
						 * @see http://msdn.microsoft.com/en-us/library/ms537470(VS.85).aspx
						 * @see http://msdn.microsoft.com/en-us/library/ms535854(v=VS.85).aspx
						 */
						else if (node.ownerDocument.documentElement === node && typeof node.ownerDocument.namespaces === 'object')
						{
							for(i=0; i<node.ownerDocument.namespaces.length; i++)
							{
								namespace = node.ownerDocument.namespaces.item(i);
								if (namespace.name == prefix)
								{
									return namespace.urn;
								}
							}
						}
						/**
						 * Normal attribute checking for namespace declarations
						 */
						else
						{
							for(i=0; i<node.attributes.length; i++)
							{
								if (!node.attributes[i].specified)
								{
									continue;
								}
								if ('xmlns:' + prefix == node.attributes[i].nodeName)
								{
									return node.attributes[i].nodeValue;
								}
							}
						}
						
						/**
						 * ... resolving the namespaceURI from a given prefix using the
						 * current information available in the node's hierarchy ...
						 *
						 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
						 */
						if (node.ownerDocument.documentElement !== node && node.parentNode)
						{
							// HACK: Maybe replace with a function call and pass in prefix with parentNode
							tmpNode = this.node;
							this.node = node.parentNode;
							namespace = this.lookupNamespaceURI(prefix);
							this.node = tmpNode;
							return namespace;
						}
					}
					return null;
					break;
			}
		}
	}
	
	expressions = {
		'/': function(left, right)
		{
			var type,
				i,
				nodeset,
				nodeset2,
				resultNodeset,
				newContext
			;
			
			// Evaluate left
			if (left === null)
			{
				// A / by itself selects the root node of the document containing the context node.
				nodeset = new NodeSetType([nodeOwnerDocument(this.node)], 'document-order');
			}
			else
			{
				nodeset = evaluateExpressionTree(this, left);
				
				if (!nodeset instanceof NodeSetType)
				{
					throw new Error('Left side of path separator (/) must be of node-set type. (type: ' + nodeset.type + ')');
				}
			}
			
			// Evaluate right with respect to left
			if (right === null)
			{
				resultNodeset = nodeset;
			}
			else
			{
				/**
				 * If it is followed by a relative location path, then the location path selects
				 * the set of nodes that would be selected by the relative location path relative
				 * to the root node of the document containing the context node.
				 */
				
				resultNodeset = new NodeSetType([], 'document-order');
				
				for(i=0; i<nodeset.value.length; i++)
				{
					newContext = this.clone(nodeset.value[i]);
					nodeset2 = evaluateExpressionTree(newContext, right);
				
					if (!nodeset2 instanceof NodeSetType)
					{
						throw new Error('Right side of path separator (/) must be of node-set type. (type: ' + nodeset2.type + ')');
					}
					
					resultNodeset.append(nodeset2);
				}
			}
			
			return resultNodeset;
		},
		
		step: function(axis, nodeTest)
		{
			var nodeset,
				i,
				node,
				nodes,
				qname,
				nodeType,
				expandedName
			;
			
			/*
			 * @ see http://www.w3.org/TR/xpath/#axes
			 */
			switch(axis)
			{
				/*
				 * the child axis contains the children of the context node
				 */
				case 'child':
					nodeset = new NodeSetType(nodeChildren(this.node), 'document-order');
					break;
				
				/*
				 * the descendant axis contains the descendants of the context
				 * node; a descendant is a child or a child of a child and so on;
				 * thus the descendant axis never contains attribute or namespace nodes
				 */
				case 'descendant':
					nodeset = new NodeSetType(nodeDescendant(this.node), 'document-order');
					break;
				
				/*
				 * the parent axis contains the parent of the context node, if there is one
				 */
				case 'parent':
					node = nodeParent(this.node);
					nodeset = new NodeSetType((!node) ? [] : [node], 'document-order');
					break;
				
				/*
				 * the ancestor axis contains the ancestors of the context node; the ancestors
				 * of the context node consist of the parent of context node and the parent's
				 * parent and so on; thus, the ancestor axis will always include the root node,
				 * unless the context node is the root node
				 */
				case 'ancestor':
					nodeset = new NodeSetType(nodeAncestor(this.node), 'reverse-document-order');
					break;
				
				/*
				 * the following-sibling axis contains all the following siblings of the context node;
				 * if the context node is an attribute node or namespace node, the following-sibling axis is empty
				 */
				case 'following-sibling':
					nodeset = new NodeSetType(nodeFollowingSibling(this.node), 'document-order');
					break;
				
				/*
				 * the preceding-sibling axis contains all the preceding siblings of the context node; if the
				 * context node is an attribute node or namespace node, the preceding-sibling axis is empty
				 */
				case 'preceding-sibling':
					nodeset = new NodeSetType(nodePrecedingSibling(this.node), 'reverse-document-order');
					break;
				
				/*
				 * the following axis contains all nodes in the same document as the context node that are after
				 * the context node in document order, excluding any descendants and excluding attribute
				 * nodes and namespace nodes
				 */
				case 'following':
					nodeset = new NodeSetType(nodeFollowing(this.node), 'document-order');
					break;
				
				/*
				 * the preceding axis contains all nodes in the same document as the context node that are before 
				 * the context node in document order, excluding any ancestors and excluding attribute 
				 * nodes and namespace nodes
				 */
				case 'preceding':
					nodeset = new NodeSetType(nodePreceding(this.node), 'reverse-document-order');
					break;
				
				/*
				 * the attribute axis contains the attributes of the context node; the axis will 
				 * be empty unless the context node is an element
				 */
				case 'attribute':
					nodeset = new NodeSetType(nodeAttribute(this.node), 'document-order');
					break;
				
				/*
				 * the namespace axis contains the namespace nodes of the context node; the axis 
				 * will be empty unless the context node is an element
				 */
				case 'namespace':
					nodeset = new NodeSetType(nodeNamespace.call(this, this.node), 'document-order');
					break;
				
				/*
				 * the self axis contains just the context node itself
				 */
				case 'self':
					nodeset = new NodeSetType([this.node], 'document-order');
					break;
				
				/*
				 * the descendant-or-self axis contains the context node and the descendants of the context node
				 */
				case 'descendant-or-self':
					nodes = nodeDescendant(this.node);
					nodes.unshift(this.node);
					nodeset = new NodeSetType(nodes, 'document-order');
					break;
				
				/*
				 * the ancestor-or-self axis contains the context node and the ancestors of the context node; 
				 * thus, the ancestor axis will always include the root node
				 */
				case 'ancestor-or-self':
					nodes = nodeAncestor(this.node);
					nodes.unshift(this.node);
					nodeset = new NodeSetType(nodes, 'reverse-document-order');
					break;
				
				default:
					throw new Error("Axis type not supported: " + axis);
					break;
			}
			
			switch(nodeTest.type)
			{
				case 'nodeType':
					if (nodeTest.args[0] == 'node')
					{
						// leave node as is
						break;
					}
					
					for(i=nodeset.value.length-1; i>=0; i--)
					{
						// TODO-FUTURE: perhaps move the switch outside of the loop
						switch(nodeTest.args[0])
						{
							case 'text':
								if (nodeset.value[i].nodeType != 3 && // text
									nodeset.value[i].nodeType != 4 // cdata
								) {
									nodeset.value.splice(i, 1);
								}
								break;
							
							case 'comment':
								if (nodeset.value[i].nodeType != 8) // comment
								{
									nodeset.value.splice(i, 1);
								}
								break;
							
							case 'processing-instruction':
								if (nodeset.value[i].nodeType != 7 || // processing-instruction
									(nodeTest.args[1].length > 0 &&
										evaluateExpressionTree(this, nodeTest.args[1][0]) != nodeset.value[i].nodeName) // name
								) {
									nodeset.value.splice(i, 1);
								}
								break;
						}
					}
					break;
					
				case 'name':
					qname = evaluateExpressionTree(this, nodeTest);
					
					/**
					 * Every axis has a principal node type. If an axis can contain elements, then the
					 * principal node type is element; otherwise, it is the type of the nodes
					 * that the axis can contain.
					 *
					 * @see http://www.w3.org/TR/xpath/#node-tests
					 */
					switch(axis)
					{
						// For the attribute axis, the principal node type is attribute.
						case 'attribute':
							nodeType = 2;
							break;
						
						// For the namespace axis, the principal node type is namespace.
						case 'namespace':
							nodeType = 13;
							break;
						
						// For other axes, the principal node type is element.
						default:
							nodeType = 1;
							break;
					}
					
					for(i=nodeset.value.length-1; i>=0; i--)
					{
						if (nodeset.value[i].nodeType != nodeType)
						{
							// not of principal node type, so remove node
							nodeset.value.splice(i, 1);
							continue;
						}
						
						// *
						if (qname.ns === null && qname.name === null)
						{
							continue;
						}
						
						// get expanded name
						expandedName = nodeExpandedName.call(this, nodeset.value[i]);
						
						// check namespace
						//alert(expandedName.ns + ' ' + qname.ns + "\r\n" + expandedName.name + ' ' + qname.name);
						if (expandedName === false || expandedName.ns !== qname.ns)
						{
							// namespaces don't match
							nodeset.value.splice(i, 1);
							continue;
						}
						
						// check name
						if (qname.name !== null &&
							// TODO: provide option for case sensitivity
							expandedName.name.toLowerCase() != qname.name.toLowerCase()
						) {
							// names don't match
							nodeset.value.splice(i, 1);
						}
					}
					break;
					
				default:
					throw new Error('NodeTest type not supported in step: ' + nodeTest.type);
					break;
			}
			
			return nodeset;
		},
		
		/**
		 * @see http://www.w3.org/TR/xpath/#predicates
		 */
		predicate: function(axis, expr, predicateExprs)
		{
			var nodeset,
				i,
				result,
				j,
				k,
				length
			;
			
			// Evaluate expression
			nodeset = evaluateExpressionTree(this, expr);
			
			// Ensure we get a node-set
			if (!nodeset instanceof NodeSetType)
			{
				throw new Error('Expected "node-set", got: ' + nodeset.type);
			}
			
			/**
			 * A predicate filters a node-set with respect to an axis to produce a new node-set.
			 */
			switch(axis)
			{
				case 'ancestor':
				case 'ancestor-or-self':
				case 'preceding':
				case 'preceding-sibling':
					nodeset.sortReverseDocumentOrder();
					break;
					
				default:
					nodeset.sortDocumentOrder();
					break;
			}
			
			for (j=0; j<predicateExprs.length; j++)
			{
				/**
				 * For each node in the node-set to be filtered, ...
				 */
				for(i=0,k=1, length=nodeset.value.length; i<nodeset.value.length;k++)
				{
					/**
					 * ... the PredicateExpr is evaluated with that node as the context node, with the
					 * number of nodes in the node-set as the context size, and with the proximity
					 * position of the node in the node-set with respect to the axis as the context
					 * position; if PredicateExpr evaluates to true for that node, the node is
					 * included in the new node-set; otherwise, it is not included.
					 */
					result = evaluateExpressionTree(this.clone(nodeset.value[i], k, length), predicateExprs[j]);
					
					/**
					 * If the result is a number, the result will be converted to true if the number
					 * is equal to the context position and will be converted to false otherwise;
					 */
					if (result instanceof NumberType)
					{
						if (result.value != k)
						{
							nodeset.value.splice(i, 1);
							continue;
						}
					}
					
					/**
					 * if the result is not a number, then the result will be converted as
					 * if by a call to the boolean function.
					 */
					else if (!result.toBoolean())
					{
						nodeset.value.splice(i, 1);
						continue;
					}
					
					i++;
				}
			}

			return nodeset;
		},
		
		/**
		 * @see http://www.w3.org/TR/xpath/#section-Function-Calls
		 */
		'function': function(name, args)
		{
			var qname,
				argVals = [],
				formatName = function(qname)
				{
					return ((qname.ns !== null) ? '{' + qname.ns + '}' : '{}') + qname.name;
				},
				formatFnArgs = function(args)
				{
					var i,
						types = [],
						type
					;
					
					for(i=0; i < args.length; i++)
					{
						type = (args[i].t === undefined) ? 'object' : args[i].t;
						
						if (args[i].r !== false) // required
						{
							if (args[i].rep === true)
							{
								type += '+'; // one or more
							}
						}
						else
						{
							if (args[i].rep === true)
							{
								type += '*'; // zero or more
							}
							else
							{
								type += '?' // optional
							}
						}
						
						types.push(type);
					}
					
					return '(' + types.join(', ') + ')';
				},
				fnInfo,
				i,
				j = 0,
				argTypes = [],
				val
			;
			
			/**
			 * Does the function exist?
			 * TODO-FUTURE: this should be done during createExpression, not evaluate
			 */
			qname = evaluateExpressionTree(this, name);
			
			if (qname.ns === null)
			{
				// since we cannot use null as key
				qname.ns = '';
			}
			
			if (!this.fns[qname.ns] || !this.fns[qname.ns][qname.name])
			{
				throw new Error('Function "' + formatName(qname) + '" does not exist.');
			}
			
			fnInfo = this.fns[qname.ns][qname.name];
			
			/**
			 * Does the supplied number of arguments match what the function expects?
			 * TODO-FUTURE: this should be done during createExpression, not evaluate
			 */
			if (!fnInfo.args) fnInfo.args = [];

			for(i=0, j=0; i < fnInfo.args.length; j++, i++)
			{
				if (args[j] === undefined)
				{
					// no supplied arg
					if (fnInfo.args[i].r !== false) // required
					{
						// not enough supplied args
						throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.');
					}
				}
				else
				{
					// has supplied arg
					argTypes.push(
						(fnInfo.args[i].t === undefined) ? 'object' : fnInfo.args[i].t
					);
				}
				
				if (fnInfo.args[i].rep === true)
				{
					// repeated args
					for(;j < args.length; j++)
					{
						argTypes.push(
							(fnInfo.args[i].t === undefined) ? 'object' : fnInfo.args[i].t
						);
					}
					break;
				}
			}
			
			if (argTypes.length < args.length)
			{
				// too many supplied args
				throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.');
			}
			
			// Evaluate args
			for(i=0; i<args.length; i++)
			{
				// Evaluate expression
				val = evaluateExpressionTree(this, args[i]);
				
				if (argTypes[i] !== 'object' && !val.canConvertTo(argTypes[i]))
				{
					// TODO-FUTURE: supported arg types should be checked during createExpression
					throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.' +
						'Cannot convert "' + val.type + '" to "' + argTypes[i] +'".' );
				}
				
				argVals.push(val);
			}
			
			result = fnInfo.fn.apply(this, argVals);
			
			if (!result instanceof BaseType)
			{
				throw new Error('Function "' + formatName(qname) + '" did not return a value that inherits from BaseType.');
			}
			else if (fnInfo.ret !== 'object' && !result.canConvertTo(fnInfo.ret))
			{
				throw new Error('Function "' + formatName(qname) + '" return "' + result.type + '" type that cannot be converted to "' + fnInfo.ret + '".');
			}
			
			return result;
		},
		
		'|': function(left, right)
		{
			left = evaluateExpressionTree(this, left);
			right = evaluateExpressionTree(this, right);
			
			if (typeof left == 'undefined' ||
				typeof right == 'undefined' ||
				!left instanceof NodeSetType ||
				!right instanceof NodeSetType)
			{
				throw new Error('Unable to perform union on non-"node-set" types.');
			}
			
			left.append(right);
			return left;
		},
		
		/**
		 * An or expression is evaluated by evaluating each operand and converting its value to a boolean
		 * as if by a call to the boolean function. The result is true if either value is true and
		 * false otherwise. The right operand is not evaluated if the left operand evaluates to true.
		 *
		 * @see http://www.w3.org/TR/xpath/#booleans
		 * @return {BooleanType}
		 */
		or: function(left, right)
		{
			if (evaluateExpressionTree(this, left).toBoolean())
			{
				return new BooleanType(true);
			}
			
			return new BooleanType(evaluateExpressionTree(this, right).toBoolean());
		},
		
		/**
		 * An and expression is evaluated by evaluating each operand and converting its value to a boolean
		 * as if by a call to the boolean function. The result is true if both values are true and
		 * false otherwise. The right operand is not evaluated if the left operand evaluates to false.
		 *
		 * @see http://www.w3.org/TR/xpath/#booleans
		 * @return {BooleanType}
		 */
		and: function(left, right)
		{
			if (evaluateExpressionTree(this, left).toBoolean())
			{
				return new BooleanType(evaluateExpressionTree(this, right).toBoolean());
			}
			
			return new BooleanType(false);
		},
		
		'=': function(left, right)
		{
			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '=', function(left, right) {
				return left == right;
			});
		},
		
		'!=': function(left, right)
		{
			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '!=', function(left, right) {
				return left != right;
			});
		},
		
		'<=': function(left, right)
		{
			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '<=', function(left, right) {
				return left <= right;
			});
		},
		
		'<': function(left, right)
		{
			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '<', function(left, right) {
				return left < right;
			});
		},
		
		'>=': function(left, right)
		{
			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '>=', function(left, right) {
				return left >= right;
			});
		},
		
		'>': function(left, right)
		{
			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '>', function(left, right) {
				return left > right;
			});
		},
		
		'+': function(left, right)
		{
			return new NumberType(
				evaluateExpressionTree(this, left).toNumber()
				+
				evaluateExpressionTree(this, right).toNumber()
			);
		},
		
		'-': function(left, right)
		{
			return new NumberType(
				evaluateExpressionTree(this, left).toNumber()
				-
				evaluateExpressionTree(this, right).toNumber()
			);
		},
		
		div: function(left, right)
		{
			return new NumberType(
				evaluateExpressionTree(this, left).toNumber()
				/
				evaluateExpressionTree(this, right).toNumber()
			);
		},
		
		mod: function(left, right)
		{
			return new NumberType(
				evaluateExpressionTree(this, left).toNumber()
				%
				evaluateExpressionTree(this, right).toNumber()
			);
		},
		
		'*': function(left, right)
		{
			return new NumberType(
				evaluateExpressionTree(this, left).toNumber()
				*
				evaluateExpressionTree(this, right).toNumber()
			);
		},
		
		/**
		 * @param {String} string
		 * @return {String}
		 */
		string: function(string)
		{
			return new StringType(string);
		},
		
		/**
		 * @param {Number} number
		 * @return {Number}
		 */
		number: function(number)
		{
			return new NumberType(number);
		},
		
		'$': function(name)
		{
			throw new Error("TODO: Not implemented.16");
		},
		
		/**
		 * @param {String} ns
		 * @param {String} name
		 * @return {Object}
		 */
		name: function(prefix, name)
		{
			var ns = null;
			
			if (prefix !== null)
			{
				ns = this.nsMap[prefix];
				if (!ns)
				{
					throw new Error('Namespace prefix "' + prefix + '" is not mapped to a namespace.');
				}
			}
			
			return {
				ns: ns,
				name: name
			};
		}
	}
	
	functions = {
		/**
		 * Core Function Library
		 *
		 * This section describes functions that XPath implementations must always include in the function library that is used to evaluate expressions.
		 * Each function in the function library is specified using a function prototype, which gives the return type, the name of the function, and the type of the arguments. If an argument type is followed by a question mark, then the argument is optional; otherwise, the argument is required.
		 */
		'' : {
			// Node Set Functions
			
			last: {
				/**
				 * The last function returns a number equal to the context size from the expression evaluation context.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-last
				 * @return {NumberType}
				 */
				fn: function()
				{
					return new NumberType(this.size);
				},
				
				ret: 'number'
			},
			
//			position: {
//				/**
//				 * The position function returns a number equal to the context position from the expression evaluation context.
//				 *
//				 * @see http://www.w3.org/TR/xpath/#function-position
//				 * @return {NumberType}
//				 */
//				fn: function()
//				{
//					return new NumberType(this.pos);
//				},
//				
//				ret: 'number'
//			},
			
			count: {
				/**
				 * The count function returns the number of nodes in the argument node-set.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-count
				 * @param {NodeSetType} nodeset
				 * @return {NumberType}
				 */
				fn: function(nodeset)
				{
					return new NumberType(nodeset.toNodeSet().length);
				},
				
				args: [
					{t: 'node-set'}
				],
				
				ret: 'number'
			},
			
			id: {
				/**
				 * The id function selects elements by their unique ID.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-id
				 * @param {BaseType} object
				 * @return {NodeSetType}
				 */
				fn: function(object)
				{
					var context = this,
						ids = [],
						i,
						j,
						node,
						nodes = [],
						value,
						splitStringByWhitespace = function(str)
						{
							var i,
								// split string by whitespace (#x20 | #x9 | #xD | #xA)+
								chunks = str.split(/[\u0020\u0009\u000D\u000A]+/)
							;
							
							for(i = chunks.length - 1; i >= 0; i--)
							{
								// trim left/right
								if (chunks[i].length == 0)
								{
									chunks.splice(i, 1);
								}
							}
							
							return chunks;
						}
					;
					
					if (object instanceof NodeSetType)
					{
						/**
						 * When the argument to id is of type node-set, then the result is the
						 * union of the result of applying id to the string-value of
						 * each of the nodes in the argument node-set.
						 */
						for(i=0; i<object.value.length; i++)
						{
							ids.push.apply(ids, splitStringByWhitespace(nodeStringValue(object.value[i])));
						}
					}
					else
					{
						/**
						 * When the argument to id is of any other type, the argument is
						 * converted to a string as if by a call to the string function
						 */
						object = object.toString();
						
						/**
						 * the string is split into a whitespace-separated list of tokens
						 */
						
						// split string by whitespace (#x20 | #x9 | #xD | #xA)+
						ids = splitStringByWhitespace(object);
					}
					
					// remove duplicate ids
					for(i=ids.length-1; i>=0; i--)
					{
						for(j=i-1; j >= 0; j--)
						{
							if (ids[i] == ids[j] && i != j)
							{
								ids.splice(i, 1);
								break;
							}
						}
					}
					
					/**
					 * the result is a node-set containing the elements in the same document
					 * as the context node that have a unique ID equal to any of the tokens in the list.
					 *
					 * An element node may have a unique identifier (ID). This is the value of the
					 * attribute that is declared in the DTD as type ID.
					 */
					for(i=0; i<ids.length; i++)
					{
						node = nodeOwnerDocument(this.node).getElementById(ids[i]);
						
						if (node)
						{
							// ensure that this node does indeed have a valid id attibute in namespace scope
							if (nodeIdAttribute.call(this, node))
							{
								nodes.push(node);
								continue;
							}
						}
						
						// node not found by id, need to search manually
						nodeAttributeSearch(nodeOwnerDocument(this.node), true, function(element, attribute) {
							
							var idAttribute = nodeIdAttribute.call(context, element, attribute);
							
							if (idAttribute && idAttribute.nodeValue == ids[i])
							{
								nodes.push(element);
								return true;
							}
						});
					}
					
					return new NodeSetType(nodes);
				},
				
				args: [
					{}
				],
				
				ret: 'node-set'
			},
			
			'local-name': {
				/**
				 * The local-name function returns the local part of the expanded-name
				 * of the node in the argument node-set that is first in document order.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-local-name
				 * @param {NodeSetType} nodeset
				 * @return {StringType}
				 */
				fn: function(nodeset)
				{
					var qname,
						localName = ''
					;
					
					/**
					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
					 */
					if (arguments.length == 0)
					{
						nodeset = new NodeSetType([this.node]);
					}
					
					/**
					 * If the argument node-set is empty or the first node has no expanded-name, an empty string is returned.
					 */
					if (nodeset.toNodeSet().length > 0)
					{
						nodeset.sortDocumentOrder();
						qname = nodeExpandedName.call(this, nodeset.value[0]);
						
						if (qname !== false)
						{
							localName = qname.name;
						}
					}
					
					return new StringType(localName);
				},
				
				args: [
					{t: 'node-set', r: false}
				],
				
				ret: 'string'
			},
			
			'namespace-uri': {
				/**
				 * The namespace-uri function returns the namespace URI of the expanded-name
				 * of the node in the argument node-set that is first in document order.
				 *
				 * The string returned by the namespace-uri function will be empty
				 * except for element nodes and attribute nodes.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-namespace-uri
				 * @param {NodeSetType} nodeset
				 * @return {StringType}
				 */
				fn: function(nodeset)
				{
					var qname,
						namespaceURI = ''
					;
					
					/**
					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
					 */
					if (arguments.length == 0)
					{
						nodeset = new NodeSetType([this.node]);
					}
					
					/**
					 * If the argument node-set is empty, the first node has no expanded-name,
					 * or the namespace URI of the expanded-name is null, an empty string is returned.
					 */
					if (nodeset.toNodeSet().length > 0)
					{
						nodeset.sortDocumentOrder();
						qname = nodeExpandedName.call(this, nodeset.value[0]);
						
						if (qname !== false && qname.ns !== null)
						{
							namespaceURI = qname.ns;
						}
					}
					
					return new StringType(namespaceURI);
				},
				
				args: [
					{t: 'node-set', r: false}
				],
				
				ret: 'string'
			},
			
			name: {
				/**
				 * The name function returns a string containing a QName representing the expanded-name
				 * of the node in the argument node-set that is first in document order.
				 *
				 * The string returned by the name function will be the same as the string returned
				 * by the local-name function except for element nodes and attribute nodes.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-name
				 * @param {NodeSetType} nodeset
				 * @param {StringType}
				 */
				fn: function(nodeset)
				{
					var qname,
						name = ''
					;
					
					/**
					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
					 */
					if (arguments.length == 0)
					{
						nodeset = new NodeSetType([this.node]);
					}
					
					if (nodeset.toNodeSet().length > 0)
					{
						nodeset.sortDocumentOrder();
						qname = nodeExpandedName.call(this, nodeset.value[0]);
						
						if (qname !== false)
						{
							name = (qname.prefix && qname.prefix.length > 0)
								? qname.prefix + ':' + qname.name
								: qname.name
							;
						}
					}
					
					return new StringType(name);
				},
				
				args: [
					{t: 'node-set', r: false}
				],
				
				ret: 'string'
			},
			
			// String functions
			
			string: {
				/**
				 * The string function converts an object to a string.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-string
				 * @param {BaseType} object
				 * @return {StringType}
				 */
				fn: function(object)
				{
					/**
					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
					 */
					if (arguments.length == 0)
					{
						object = new NodeSetType([this.node], 'document-order');
					}
					
					return new StringType(object.toString());
				},
				
				args: [
					{t: 'object', r: false}
				],
				
				ret: 'string'
			},
			
			//native concat() was replaced with a javarosa-style concat() without breaking the native functionality
			//concat: {
			//	/**
			//	 * The concat function returns the concatenation of its arguments.
			//	 *
			//	 * @see http://www.w3.org/TR/xpath/#function-concat
			//	 * @param {StringType} str1
			//	 * @param {StringType} str2
			//	 * @return {StringType}
			//	 */
			//	fn: function(str1, str2 /*, str3 ... */)
			//	{
			//		var i,
			//			value = ''
			//		;
			//		
			//		for(i=0; i < arguments.length; i++)
			//		{
			//			value += arguments[i].toString();
			//		}
			//		
			//		return new StringType(value);
			//	},
			//	
			//	args: [
			//		{t: 'string'},
			//		{t: 'string'},
			//		{t: 'string', r: false, rep: true}
			//	],
			//	
			//	ret: 'string'
			//},
			
			'starts-with': {
				/**
				 * The starts-with function returns true if the first argument string
				 * starts with the second argument string, and otherwise returns false.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-starts-with
				 * @param {StringType} haystack
				 * @param {StringType} needle
				 * @return {StringType}
				 */
				fn: function(haystack, needle)
				{
					return new BooleanType(haystack.toString().substr(0, (needle = needle.toString()).length) == needle);
				},
				
				args: [
					{t: 'string'},
					{t: 'string'}
				],
				
				ret: 'string'
			},
			
			contains: {
				/**
				 * The contains function returns true if the first argument string
				 * contains the second argument string, and otherwise returns false.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-contains
				 * @param {StringType} haystack
				 * @param {StringType} needle
				 * @return {StringType}
				 */
				fn: function(haystack, needle)
				{
					return new BooleanType(haystack.toString().indexOf(needle = needle.toString()) != -1);
				},
				
				args: [
					{t: 'string'},
					{t: 'string'}
				],
				
				ret: 'string'
			},
			
			'substring-before': {
				/**
				 * The substring-before function returns the substring of the first argument
				 * string that precedes the first occurrence of the second argument string
				 * in the first argument string, or the empty string if the first argument
				 * string does not contain the second argument string.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-substring-before
				 * @param {StringType} haystack
				 * @param {StringType} needle
				 * @return {StringType}
				 */
				fn: function(haystack, needle)
				{
					haystack = haystack.toString();
					needle = haystack.indexOf(needle.toString());
					return new StringType(needle == -1 ?  '' : haystack.substr(0, needle));
				},
				
				args: [
					{t: 'string'},
					{t: 'string'}
				],
				
				ret: 'string'
			},
			
			'substring-after': {
				/**
				 * The substring-after function returns the substring of the first argument
				 * string that follows the first occurrence of the second argument string
				 * in the first argument string, or the empty string if the first argument
				 * string does not contain the second argument string.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-substring-after
				 * @param {StringType} haystack
				 * @param {StringType} needle
				 * @return {StringType}
				 */
				fn: function(haystack, needle)
				{
					var pos;
					
					haystack = haystack.toString();
					needle = needle.toString();
					pos = haystack.indexOf(needle);
					
					return new StringType(pos == -1 ?  '' : haystack.substr(pos + needle.length));
				},
				
				args: [
					{t: 'string'},
					{t: 'string'}
				],
				
				ret: 'string'
			},
			
			substring: {
				/**
				 * The substring function returns the substring of the first argument
				 * starting at the position specified in the second argument
				 * with length specified in the third argument.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-substring
				 * @param {StringType} str
				 * @param {NumberType} start
				 * @param {NumberType} length
				 * @return {StringType}
				 */
				fn: function(str, start, length)
				{
					str = str.toString();
					
					start = Math.round(start.toNumber()) - 1;
					
					return new StringType(
						isNaN(start)
							? ''
							: ((arguments.length == 2)
								? str.substring(start < 0 ? 0 : start)
								: str.substring(start < 0 ? 0 : start, start + Math.round(length.toNumber()))
							)
					);
				},
				
				args: [
					{t: 'string'},
					{t: 'number'},
					{t: 'number', r: false}
				],
				
				ret: 'string'
			},
			
			'string-length': {
				/**
				 * The string-length returns the number of characters in the string.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-string-length
				 * @param {StringType} str
				 * @return {NumberType}
				 */
				fn: function(str)
				{
					str = (arguments.length == 0)
						? nodeStringValue(this.node)
						: str.toString()
					;
					return new NumberType(str.length);
				},
				
				args: [
					{t: 'string', r: false}
				],
				
				ret: 'number'
			},
			
			'normalize-space': {
				/**
				 * The normalize-space function returns the argument string with whitespace
				 * normalized by stripping leading and trailing whitespace and replacing
				 * sequences of whitespace characters by a single space.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-normalize-space
				 * @param {StringType} str
				 * @return {StringType}
				 */
				fn: function(str)
				{
					str = (arguments.length == 0)
						? nodeStringValue(this.node)
						: str.toString()
					;
					return new StringType(str.replace(/^[\u0020\u0009\u000D\u000A]+/,'').replace(/[\u0020\u0009\u000D\u000A]+$/,'').replace(/[\u0020\u0009\u000D\u000A]+/g, ' '));
				},
				
				args: [
					{t: 'string', r: false}
				],
				
				ret: 'string'
			},
							
			translate: {
				/**
				 * The translate function returns the first argument string with occurrences
				 * of characters in the second argument string replaced by the character
				 * at the corresponding position in the third argument string.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-normalize-space
				 * @param {StringType} haystack
				 * @param {StringType} search
				 * @param {StringType} replace
				 * @return {StringType}
				 */
				fn: function(haystack, search, replace)
				{
					var result = '',
						i,
						j,
						x
					;
					
					haystack = haystack.toString();
					search = search.toString();
					replace = replace.toString();
					
					for(i = 0; i < haystack.length; i++)
					{
						if ((j = search.indexOf(x = haystack.charAt(i))) == -1 ||
							(x = replace.charAt(j)))
							result += x;
					}
					
					return new StringType(result);
				},
				
				args: [
					{t: 'string'},
					{t: 'string'},
					{t: 'string'}
				],
				
				ret: 'string'
			},
			
			// Boolean Functions
			
			'boolean': {
				/**
				 * The boolean function converts its argument to a boolean.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-boolean
				 * @param {BaseType}
				 * @return {BooleanType} 
				 */
				fn: function(object)
				{
					return new BooleanType(object.toBoolean());
				},
				
				args: [
					{r: true}
				],
				
				ret: 'boolean'
			},
			
			not: {
				/**
				 * The not function returns true if its argument is false, and false otherwise.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-not
				 * @param {BooleanType}
				 * @return {BooleanType} 
				 */
				fn: function(bool)
				{
					return new BooleanType(!bool.toBoolean());
				},
				
				args: [
					{t: 'boolean'}
				],
				
				ret: 'boolean'
			},
			
			'true': {
				/**
				 * The true function returns true.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-true
				 * @return {BooleanType} 
				 */
				fn: function()
				{
					return new BooleanType(true);
				},
				
				ret: 'boolean'
			},
			
			'false': {
				/**
				 * The false function returns false.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-false
				 * @return {BooleanType} 
				 */
				fn: function()
				{
					return new BooleanType(false);
				},
				
				ret: 'boolean'
			},
			
			/**
			 * The lang function returns true or false depending on whether the language
			 * of the context node as specified by xml:lang attributes is the same
			 * as or is a sublanguage of the language specified by the argument string.
			 *
			 * @see http://www.w3.org/TR/xpath/#function-lang
			 * @param {StringType}
			 * @return {BooleanType} 
			 */
			lang: {
				fn: function(string)
				{
					var node = this.node,
						attributes,
						attributeName,
						attributeValueParts,
						langParts = string.toString().toLowerCase().split('-'),
						namespaceNodes,
						i,
						j,
						partsEqual
					;
					
					for(;node.nodeType != 9; node = nodeParent(node)) // document node
					{
						attributes = nodeAttribute(node);
						
						for(i = 0; i < attributes.length; i++)
						{
							// parse attribute name and namespace prefix
							attributeName = attributes[i].nodeName.split(':');
							if (attributeName.length === 1)
							{
								// set default namespace
								attributeName[1] = attributeName[0];
								attributeName[0] = '';
							}
							
							// compare attribute name
							if (attributeName[1] == 'lang')
							{
								attributeValueParts = attributes[i].nodeValue.toLowerCase().split('-');
								
								if (attributeValueParts.length < langParts.length)
									continue;
								
								// compare attribute value
								partsEqual = true;
								for(j=0; j < langParts.length; j++)
								{
									if (langParts[j] != attributeValueParts[j])
									{
										partsEqual = false;
										break;
									}
								}
								
								if (partsEqual)
								{
									// ensure xml namespace
									namespaceNodes = nodeNamespace.call(this, node);
									
									for(j=0; j < namespaceNodes.length; j++)
									{
										if(namespaceNodes[j].prefix == attributeName[0]
											&& namespaceNodes[j].nodeValue == NAMESPACE_URI_XML)
										{
											return new BooleanType(true);
										}
									}
								}
							}
						}
					}
					
					return new BooleanType(false);
				},
				
				args: [
					{t: 'string'}
				],
				
				ret: 'boolean'
			},
			
			// Number Functions
			
			number: {
				/**
				 * The number function converts its argument to a number.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-number
				 * @param {BaseType} object
				 * @return {NumberType}
				 */
				fn: function(object)
				{
					/**
					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
					 */
					if (arguments.length == 0)
					{
						object = new NodeSetType([this.node], 'document-order');
					}
					
					return new NumberType(object.toNumber());
				},
				
				args: [
					{t: 'object', r: false}
				],
				
				ret: 'number'
			},
			
			sum: {
				/**
				 * The sum function returns the sum, for each node in the argument node-set,
				 * of the result of converting the string-values of the node to a number.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-sum
				 * @param {NodeSetType} 
				 * @return {NumberType}
				 */
				fn: function(nodeset)
				{
					var i,
						sum = 0;
					;
					
					nodeset = nodeset.toNodeSet();
					
					for(i = 0; i < nodeset.length; i++)
					{
						sum += (new StringType(nodeStringValue(nodeset[i]))).toNumber();
					}
					
					return new NumberType(sum);
				},
				
				args: [
					{t: 'node-set'}
				],
				
				ret: 'number'
			},
			
			floor: {
				/**
				 * The floor function returns the largest (closest to positive infinity)
				 * number that is not greater than the argument and that is an integer.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-floor
				 * @param {NumberType} 
				 * @return {NumberType}
				 */
				fn: function(number)
				{
					return new NumberType(Math.floor(number));
				},
				
				args: [
					{t: 'number'}
				],
				
				ret: 'number'
			},
			
			ceiling: {
				/**
				 * The ceiling function returns the smallest (closest to negative infinity)
				 * number that is not less than the argument and that is an integer.
				 *
				 * @see http://www.w3.org/TR/xpath/#function-ceiling
				 * @param {NumberType} 
				 * @return {NumberType}
				 */
				fn: function(number)
				{
					return new NumberType(Math.ceil(number));
				},
				
				args: [
					{t: 'number'}
				],
				
				ret: 'number'
			},
			
			//Native round() function is overwritten with a custom javarosa round()
			//round: {
			//	/**
			//	 * The round function returns the number that is closest
			//	 * to the argument and that is an integer.
			//	 *
			//	 * @see http://www.w3.org/TR/xpath/#function-round
			//	 * @param {NumberType} 
			//	 * @return {NumberType}
			//	 */
			//	fn: function(number)
			//	{
			//		return new NumberType(Math.round(number));
			//	},
			//	
			//	args: [
			//		{t: 'number'}
			//	],
			//	
			//	ret: 'number'
			//},

			/********************************************************************/	
			/**** JAVAROSA-specific XPath functions (or XPath 2.0 functions) ****/
			/********************************************************************/

			sum_jr: {
				/**
				 * The JavaRosa version of the sum function is the same as the XPath 1.0 function
				 * EXCEPT that it evaluates an empty node ('') to 0 instead of NaN.
				 * @obsolete
				 * @see 
				 * @param {NodeSetType} 
				 * @return {NumberType}
				 */
				fn: function(nodeset)
				{
					var i, value
						sum = 0;
					;
					
					nodeset = nodeset.toNodeSet();
					
					for(i = 0; i < nodeset.length; i++)
					{
						value = ( nodeStringValue(nodeset[i]) == '' ) ? '0' : nodeStringValue(nodeset[i]);
						sum += (new StringType(value)).toNumber();
					}
					
					return new NumberType(sum);
				},
				
				args: [
					{t: 'node-set'}
				],
				
				ret: 'number'
			},


			position: {
				/**
				 * Hacked OpenRosa function to return the position of a nodeset argument
				 * the native position function accepts no arguments and always returns one.
				 * 
				 * This should not break proper XPath functioning with /path/to/node[position() < 3],
				 * but this is not supported in JavaRosa anyway.
				 *
				 * Note that these are actually two different functions into one...
				 *
				 * @param {NodeSetType?} node
				 * @return {NumberType}
				 */
				fn: function(nodeset)
				{

					// this is the JavaRosa behaviour
					if (nodeset) {
						var node, nodeName, position;
					
						nodeset = nodeset.toNodeSet();

						if (nodeset.length === 1) {
							node = nodeset[0];
							position = 1;
							nodeName = node.tagName;
							
							while (node.previousElementSibling && node.previousElementSibling.tagName === nodeName) {
								node = node.previousElementSibling;
								position++;
							}

							return new NumberType(position);
						} else {
							throw new Error('nodeset provided to position() contained multiple nodes');
						}
					}
					// this is the native XPath behaviour
					return new NumberType(this.pos);
				},

				args: [
					{t: 'node-set', r: false}
				],
				
				ret: 'number'
			},

			concat: {
				/**
				 * The concat function returns the concatenation of its arguments. This function
				 * goes beyond the XPath Native function by also accepting only 1 argument as well
				 * as node-set arguments that contain multiple nodes
				 *
				 * @see https://bitbucket.org/m.sundt/javarosa/src/62409ae3b803/core/src/org/javarosa/xpath/expr/XPathFuncExpr.java#cl-129
				 * @param {Object} o1
				 * @return {StringType}
				 */
				fn: function(o1 /*, o2 ... */)
				{
					var i, add,
						value = '';
					
					for(i=0; i < arguments.length; i++)
					{
						if (arguments[i] instanceof NodeSetType)
						{
							add = arguments[i].stringValues().join('');
						}
						else
						{
							add = arguments[i].toString();
						}

						value += add;
					}
					
					return new StringType(value);
				},
				
				args: [
					{t: 'object', r:false, rep: true}
				],
				
				ret: 'string'
			},

			round: {
				/**
				 * The round function returns the number rounded to the amount of desired decimal places
				 * or nearest integer if the decimal places argument is not provided. The latter is the
				 * same behaviour of the native round().
				 *
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {NumberType} number
				 * @param {NumberType} decimals [description]
				 * @return {NumberType}
				 */
				fn: function(number, decimals)
				{
					decimals = Math.round(decimals) || 0;
					return new NumberType(Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals));
				},
				
				args: [
					{t: 'number'},
					{t: 'number', r: false}
				],
				
				ret: 'number'
			},

			selected: {
				/**
				 * The selected function returns true or false if the argument
				 * is included in the space-separated list of selected multiselect values
				 * 
				 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
				 * @param {Object} object
				 * @param {StringType} value
				 * @return {BooleanType}
				 * 
				 */
				fn: function(node, value)
				{
					var i, values;

					value = value.toString().trim();
					values = node.toString();
					
					return new BooleanType( (" "+values+" ").indexOf(" "+value+" ") != -1 );
				},

				args: [
					{t: 'object'},
					{t: 'string'}
				],
				
				ret: 'boolean'
			},

			"selected-at" : {

				fn: function(node, position)
				{
					var value, values, selectValue;

					position = Math.round(position.toNumber());
					value = node.toString();
					values = value.split(' ');
					selectValue = (position >= 0 && position < values.length) ? values[position] : '';

					return new StringType(selectValue);
				},

				args: [
					{t: 'object'},
					{t: 'number'}
				],

				ret: 'string'

			},

			'count-selected': {
				/**
				 * The count-selected function returns the number of multiselect values currently selected
				 * 
				 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
				 * @param {NodeSetType} nodeset
				 * @return {NumberType}
				 * 
				 */
				fn: function(nodeset)
				{
					var values = [];

					nodeset = nodeset.toNodeSet();

					if (nodeset.length > 0){
						
						//only value of first node
						values = nodeStringValue(nodeset[0]).trim().split(' ');
						//return new Number(1);
						return (values.length == 1 && values[0] === "") ? new NumberType(0) : new NumberType(values.length);
					}

					return new NumberType(0);
				},

				args: [
					{t: 'node-set'}
				],

				ret: 'number'
			},

			checklist: {
				/**
				 * The checklist function returns true if the amount of 'yes' answers (take as true())
				 * is between min and max inclusive. Min or max may be -1 to indicate 'not applicable'.
				 * 
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {NumberType} min
				 * @param {NumberType} max
				 * @param {BaseType} oA, oB, oC etc...
				 * @return {BooleanType}
				 * 
				 */

				fn: function(min, max, oA /*, oB .... */)
				{
					var i, j, 
						trues = 0
					;
					min = min.toNumber();
					max = max.toNumber();

					for (i=2 ; i<arguments.length ; i++)
					{
						if (arguments[i] instanceof NodeSetType)
						{
							for (j=0; j<arguments[i].stringValues().length ; j++)
							{
								if (arguments[i].stringValues()[j].toBoolean() === true)
								{
									trues++;
								}
							}
						}
						else if (arguments[i].toBoolean() === true)
						{
							trues++;
						}
					}

					return new BooleanType((min < 0 || trues >= min) && (max < 0 || trues <= max));
				},

				args: [
					{t: 'number'},
					{t: 'number'},
					{t: 'object'},
					{t: 'object', r: false, rep: true}
				],

				ret: 'boolean'
			},

			'weighted-checklist': {
				/**
				 * The weighted-checklist function returns true if the amount of 'yes' answers (take as true())
				 * multiplied by each weight, is between min and max inclusive. 
				 * Min or max may be -1 to indicate 'not applicable'.
				 * 
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {NumberType} min
				 * @param {NumberType} max
				 * @param {BaseType} vA, vB, vC etc...
				 * @return {BooleanType}
				 * 
				 */

				fn: function(min, max, vA, wA /*, vB , wB.... */)
				{
					var i, j, 
						values = [], 
						weights = [], 
						weightedTrues = 0;

					min = min.toNumber();
					max = max.toNumber();

					for (i=2 ; i < arguments.length ; i=i+2)
					{
						v = arguments[i];
						w = arguments[i+1];
						if (v && w)
						{
							if (v instanceof NodeSetType)
							{
								values = values.concat(v.stringValues());
							}
							else
							{
								values.push(v);
							}
							if (w instanceof NodeSetType)
							{	
								weights = weights.concat(w.stringValues());
							}
							else
							{
								weights.push(w);
							}
						}
					}

					for (i=0 ; i < values.length ; i++)
					{
						if (values[i].toBoolean() === true)
						{
							weightedTrues += weights[i].toNumber();
						}
					}

					return new BooleanType((min < 0 || weightedTrues >= min) && (max < 0 || weightedTrues <= max));
				},

				args: [
					{t: 'number'},
					{t: 'number'},
					{t: 'object'},
					{t: 'object'},
					{t: 'object', r: false, rep: true}
				],

				ret: 'boolean'
			},

			'boolean-from-string': {
				/**
				 * The boolean-from-string function returns true if the string is 'true' or '1'. 
				 * Note that a number is cast to a string.
				 * 
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {StrType} str
				 * @return {BooleanType}
				 * 
				 */
				fn: function(str)
				{
					return new BooleanType(str.toString().toLowerCase() === 'true' || String(str) === '1');
				},

				args: [
					{t: 'string'}
				],

				ret: 'boolean'
			},

			'if': {

				fn: function(cond, a, b)
				{
					//console.log('type: '+cond.type);
					//probably needs to be changed (bug?: emptyNode.toBoolean = true, but should be false)
					//if (cond instanceof NodeSetType){
						//cond = cond.toString();
					//	console.log('cond:');
					//	console.log(cond);
					//}
					return ( cond.toBoolean() ? a : b );
				},

				args: [
					{t: 'object'},
					{t: 'object'},
					{t: 'object'}
				],

				ret: 'object'

			},

			'date': {

				fn: function(obj)
				{
					//console.log('typeof object: '+typeof obj);
					//console.log(obj);
					//if (obj instanceOf NumberType){
					//	return new DateType(new Date(obj));
					//}
					//else 
					return new DateType(obj.toDate());
				},

				args: [
					{t: 'object'}
				],

				ret: 'string'
			},

			/**
			 * Alias of "date"
			 * Note: Javarosa makes a distinction between date and date-time() in that
			 * time is removed from date(). We have to do that too, but all date() tests pass.
			 */
			'date-time': {

				fn: function(obj)
				{
					return new DateType(obj.toDate());
				},

				args: [
					{t: 'object'}
				],

				ret: 'string'
			},

			today: {
				
				fn: function()
				{
					var today = new Date();
					return new DateType(new Date(today.getFullYear(), today.getMonth(), today.getDate()));
				},

				ret: 'string'
			},

			now: {
				/**
				 * The now function returns the date in seconds between now and the epoch.
				 * 
				 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
				 * @return {NumberType}
				 * 
				 */

				fn: function()
				{
					return new DateType(new Date());
				},

				ret: 'string'
			},

			regex: {
				/**
				 * The regex function evaluates a regular expression and returns true or false.
				 * 
				 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
				 * @return {BooleanType}
				 * 
				 */
				fn: function(obj, expr)
				{
					var value, patt;

					value = obj.toString();

					patt = new RegExp(expr);

					return new BooleanType(patt.test(value));
				},

				args: [
					{t: 'object'},
					{t: 'string'}
				],

				ret: 'boolean'

			}, 

			uuid: {
				/**
				 * The uuid function returns an RFC 1422 Version 4 UUID string.
				 * 
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @return {StringType}
				 * 
				 */
				fn: function()
				{
					//from broofa: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
					var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    					var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
    					return v.toString(16);
					});
					return new StringType(uuid);
				}, 

				ret: 'string'
			},

			'int': {
				/**
				 * The int function turns a parameter into a number and truncates the fractional part
				 * 
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @return {NumberType}
				 * 
				 */
				fn: function(number)
				{
					return new NumberType(parseInt(number));
				}, 
				args: [
					{t: 'number'}
				],

				ret: 'number'
			},

			substr: {
				/**
				 * The substr function returns the substring of the first argument
				 * starting at the position specified in the second argument
				 * with end character position specified in the third argument.
				 * 
				 * THE DIFFERENCE WITH THE XPATH 1.0 NATIVE FUNCTION IS THAT POSITIONS ARE 0-BASED HERE,
				 * THE LENGTH IS GIVEN AS A CHARACTER POSITION (END) AND NEGATIVE VALUES ARE DEALT WITH 
				 * DIFFERENTLY
				 *
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {StringType} str
				 * @param {NumberType} start
				 * @param {NumberType} end
				 * @return {StringType}
				 */
				fn: function(str, start, end)
				{
					str = str.toString();
					length = str.length;

					start = Math.round(start.toNumber());
					end = (end) ? Math.round(end.toNumber()) : length;
					
					return new StringType(
						isNaN(start)
							? ''
							: str.substring( start < 0 ? length + start : start, end < 0 ? length + end : end )
					);
				},
				
				args: [
					{t: 'string'},
					{t: 'number'},
					{t: 'number', r: false}
				],
				
				ret: 'string'
			},

			random: {
				/**
				 * The random function returns a random number between 0.0 (inclusive) and 1.0 (exclusive).
				 * 
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @return {NumberType}
				 */
				fn: function()
				{

					return new NumberType(Math.random().toFixed(15))
				
				},
				
				ret: 'number'
			}, 

			min: {
				/**
				 * The min function returns the smallest values in the argument node-sets,
				 * of the result of converting the string-values of the nodes to a number.
				 *
				 * A slight improvement over JavaRosa is that each argument can be a nodeset
				 *
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {BaseType} object1
				 * @param {BaseType} object2
				 * @return {NumberType}
				 */
				fn: function(object1, object2 /*, object3 ... */)
				{
					var i, min, val, nodeset;

					console.log('min args', arguments);
					for (i = 0; i < arguments.length; i++)
					{

						if (arguments[i] instanceof NodeSetType ){

							nodeset = arguments[i].toNodeSet();
						
							for(i = 0; i < nodeset.length; i++)
							{
								val = new StringType(nodeStringValue(nodeset[i]));
								if (val && val.toString() !== '')
								{
									min = (min) ? Math.min(min, val.toNumber()) : val.toNumber();
								}
							}
						} 
						else 
						{
							val = new StringType(arguments[i].toString());
							if (val && val.toString() !== '')
							{
								min = (min) ? Math.min(min, val.toNumber()) : val.toNumber();
							}
						}
					}
					
					return new NumberType(min);
				},
				
				args: [
					{t: 'object'}, 
					{t: 'object', r: false, rep: true}
				],
				
				ret: 'number'
			}, 

			max: {
				/**
				 * The max function returns the largest value in the argument node-sets,
				 * of the result of converting the string-values of the nodes to a number.
				 *
				 * A slight improvement over JavaRosa is that each argument can be a nodeset
				 *
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {BaseType}  object1
				 * @param {BaseType}  object2
				 * @return {NumberType}
				 */
				fn: function(object1, object2 /* object3 ... */)
				{
					var i, max, val, nodeset;
					
					for (i = 0; i < arguments.length; i++)
					{
						if (arguments[i] instanceof NodeSetType ){
							
							nodeset = arguments[i].toNodeSet();
						
							for(i = 0; i < nodeset.length; i++)
							{
								val = new StringType(nodeStringValue(nodeset[i]));
								if (val && val.toString() !== '')
								{
									max = (max) ? Math.max(max, val.toNumber()) : val.toNumber();
								}
							}
						}
						else {
							val = new StringType(arguments[i].toString());
							if (val && val.toString() !== '')
							{
								max = (max) ? Math.max(max, val.toNumber()) : val.toNumber();
							}
						}
						
					}
					
					return new NumberType(max);
				},
				
				args: [
					{t: 'object'}, 
					{t: 'object', r: false, rep: true}
				],
				
				ret: 'number'
			},

			join: {
				/**
				 * The join function returns the concatenation of arguments, separated by the
				 * first argument string.
				 *
				 * @see http://opendatakit.org/help/form-design/binding/
				 * @param {StringType} str1
				 * @param {Object} obj1
				 * @return {StringType}
				 */
				fn: function(str1, obj1 /*, obj2 ... */)
				{
					var i, 
						values = []
					;

					for (i=1; i < arguments.length; i++)
					{
						if (arguments[i] instanceof NodeSetType){
							values = values.concat(arguments[i].stringValues());
						}
						else{
							values.push(arguments[i].toString());
						} 
					}
					
					value = values[0] || ''; 

					for (i = 1; i < values.length; i++ )
					{
						value += str1.toString() + values[i];
					}

					return new StringType(value);
				},
				
				args: [
					{t: 'string'},
					{t: 'object', r: false, rep: true}
				],
				
				ret: 'string'
			},

			/**
			 * The coalesce function returns the first non-empty value for the two
			 * arguments provided.
			 *
			 * @see http://opendatakit.org/help/form-design/binding/
			 * @param {Object} a
			 * @param {Object} b
			 * @return {StringType}
			 */
			coalesce : {

				fn: function(a, b)
				{
					return ( a.toString().length > 0 ) ? a : b ;
				},

				args: [
					{t: 'object'},
					{t: 'object'}
				],

				ret: 'string'

			},

			/**
			 * The date-format function returns the first non-empty value for the two
			 * arguments provided. It returns date properties in the LOCAL timezone. 
			 * TODO: check how ODK Collect deals with timezones
			 *
			 * @see http://opendatakit.org/help/form-design/binding/
			 * @param {Object} a
			 * @param {Object} b
			 * @return {StringType}
			 */
			'format-date' : {

				fn: function(dateO, format)
				{
					var i,j, 
						dateO = new DateType(dateO), //not sure why this did not happen automatically
						date = dateO.toDate(),
						result = format.toString(),
						intPad = function(num, l)
						{
							var str = num.toString(),
								zeros = l - str.length;
							for (j=0 ; j < zeros ; j++)
							{
								str = '0'+str;
							}
							return str;
						};

					if (!dateO.toBoolean())
					{
						return new StringType(date.toString());
					}

					props = {
						'Y' : date.getFullYear(),
						'y'	: date.getFullYear().toString().substring(2,4),
						'm'	: intPad((date.getMonth()+1), 2),
						'n' : date.getMonth()+1,
						'b'	: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][date.getMonth()],
						'd'	: intPad(date.getDate(), 2),
						'e'	: date.getDate(),
						'H'	: intPad(date.getHours(), 2),
						'h'	: date.getHours(),
						'M'	: intPad(date.getMinutes(), 2),
						'S'	: intPad(date.getSeconds(), 2),
						'3'	: intPad(date.getMilliseconds(), 3),
						'a' : ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][date.getDay()]
					}

					for (prop in props)
					{
						result = result.replace('%'+prop, props[prop]);
					}

					return new StringType(result);
				},

				args: [
					{t: 'date'},
					{t: 'string'}
				],

				ret: 'string'

			},

			/**
			 * Alias of format-date
			 *
			 * @see http://opendatakit.org/help/form-design/binding/
			 * @param {Object} a
			 * @param {Object} b
			 * @return {StringType}
			 */
			'format-date-time' : {

				fn: function(dateO, format)
				{
					var i,j, 
						dateO = new DateType(dateO), //not sure why this did not happen automatically
						date = dateO.toDate(),
						result = format.toString(),
						intPad = function(num, l)
						{
							var str = num.toString(),
								zeros = l - str.length;
							for (j=0 ; j < zeros ; j++)
							{
								str = '0'+str;
							}
							return str;
						};

					if (!dateO.toBoolean())
					{
						return new StringType(date.toString());
					}

					props = {
						'Y' : date.getFullYear(),
						'y'	: date.getFullYear().toString().substring(2,4),
						'm'	: intPad((date.getMonth()+1), 2),
						'n' : date.getMonth()+1,
						'b'	: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][date.getMonth()],
						'd'	: intPad(date.getDate(), 2),
						'e'	: date.getDate(),
						'H'	: intPad(date.getHours(), 2),
						'h'	: date.getHours(),
						'M'	: intPad(date.getMinutes(), 2),
						'S'	: intPad(date.getSeconds(), 2),
						'3'	: intPad(date.getMilliseconds(), 3),
						'a' : ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][date.getDay()]
					}

					for (prop in props)
					{
						result = result.replace('%'+prop, props[prop]);
					}

					return new StringType(result);
				},

				args: [
					{t: 'date'},
					{t: 'string'}
				],

				ret: 'string'

			},

			/**
			 * The pow function returns exponentiated result
			 * arguments provided.
			 *
			 * @see temporary: https://bitbucket.org/m.sundt/javarosa/pull-request/2/adding-pow-support/diff
			 * @param {NumberType} a
			 * @param {NumberType} b
			 * @return {NumberType}
			 */
			pow : {

				fn: function(a, b)
				{
					return new NumberType( Math.pow(a, b) ) ;
				},

				args: [
					{t: 'number'},
					{t: 'number'}
				],

				ret: 'number'

			},


			/**
			 * The version function returns the value of the version attribute of the root element
			 *
			 * @return {StringType}
			 */
			version : {

				fn: function()
				{
					var root = (this.node.nodeName === '#document') ? this.node.documentElement : this.node.ownerDocument.firstElementChild,
					 	versionAttr = root.attributes['version'];

					if( versionAttr ) {
						return new StringType(versionAttr.textContent);
					}
					return new StringType('');
				},

				args: [],

				ret: 'string'

			},

			/**
			 * The indexed-repeat function... should be used as little as possible
			 * THIS FUNCTION DOESN'T WORK NICELY WITH POSITION-INJECTION INSIDE REPEATS
			 *
			 * @param { NodeSetType} nodeset 	 	Collection of nodes of which to select one
			 * @param { NodeSetType} r1,r2,r3,r4,r5 The repeat nodes 
			 * @param { NumberType}  p1,p2,p3,p4,p5 The position of the repeat that contains the node to return
			 * @return {NodeSetType}
			 */
			/*'indexed-repeat': {

				fn: function(nodeset, r1, p1, r2, p2, r3, p3, r4, p4, r5, p5) {
					var tagName, node, repeat, position, repeats, positions, i;

					nodeset = nodeset.toNodeSet();

					if (nodeset.length === 0) {
						throw new Error('indexed-repeat called with empty nodeset in first parameter');
						return;
					} 
					if (arguments.length % 2 !== 1) {
						throw new Error('indexed-repeat received invalid number of arguments');
						return;
					}

					for ( i = 1; i < arguments.length - 1; i += 2) {
						position = arguments[ i + 1 ].toNumber();
						repeats = arguments[ i ].toNodeSet();
						if (repeats.length === 0) {
							throw new Error('indexed-repeat called with empty nodeset as repeat parameter');
						}
						tagName = repeats[0].tagName;
						repeat = (repeat) ? repeat.getElementsByTagName(tagName)[position - 1] : repeats[position - 1];
					}

					tagName = nodeset[0].tagName;
					node = repeat.getElementsByTagName(tagName);

					return new NodeSetType(node, 'document-order');
				},

				args: [
					{ t: 'node-set' }, 
					{ t: 'node-set' }, 
					{ t: 'number' },
					{ t: 'node-set', r: false}, 
					{ t: 'number', r: false },
					{ t: 'node-set', r:false }, 
					{ t: 'number', r: false},
					{ t: 'node-set', r: false }, 
					{ t: 'number', r:false },
					{ t: 'node-set', r:false }, 
					{ t: 'number', r:false }
				],

				ret: 'node-set'

			}*/
		}
	}
	
	/**
	 * Evaluate parsed expression tree.
	 *
	 * @param {Object} context
	 * @param {Object} tree
	 * @return {Object}
	 */
	evaluateExpressionTree = function(context, tree)
	{
		if (typeof expressions[tree.type] != 'function')
		{
			throw new Error('Internal Error: Expression type does not exist: ' + tree.type);
		}
		
		return expressions[tree.type].apply(context, tree.args)
	}
	
	/**
	 * The XPathResult interface represents the result of the evaluation of a
	 * XPath 1.0 expression within the context of a particular node. Since
	 * evaluation of an XPath expression can result in various result types,
	 * this object makes it possible to discover and manipulate the type
	 * and value of the result.
	 *
	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult
	 *
	 * @param {Context} context
	 * @param {Number} type
	 * @param {BaseType} value
	 */
	XPathResult = function(context, type, value)
	{
		switch(type)
		{
			case XPathResult.NUMBER_TYPE:
				this.resultType = XPathResult.NUMBER_TYPE;
				this.numberValue = value.toNumber();
				break;
				
			case XPathResult.STRING_TYPE:
				this.resultType = XPathResult.STRING_TYPE;
				this.stringValue = value.toString();
				break;
			
			case XPathResult.BOOLEAN_TYPE:
				this.resultType = XPathResult.BOOLEAN_TYPE;
				this.booleanValue = value.toBoolean();
				break;
			
			case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
			case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
			case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			case XPathResult.ANY_UNORDERED_NODE_TYPE:
			case XPathResult.FIRST_ORDERED_NODE_TYPE:
				if (!value instanceof NodeSetType)
				{
					throw new Error('Expected result of type "node-set", got: "' + value.type + '"');
				}
				
				this.resultType = type;
				
				switch(type)
				{
					case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
					case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
						this._value = value.toNodeSet();
						this.snapshotLength = this._value.length;
						break;
					
					case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
					case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
						// ensure in document order
						value.sortDocumentOrder();
						
						this._value = value.toNodeSet();
						this.snapshotLength = this._value.length;
						break;
					
					case XPathResult.ANY_UNORDERED_NODE_TYPE:
						value = value.toNodeSet();
						this.singleNodeValue = (value.length) ? value[0] : null;
						break;
					
					case XPathResult.FIRST_ORDERED_NODE_TYPE:
						// ensure in document order
						value.sortDocumentOrder();
						value = value.toNodeSet();
						this.singleNodeValue = (value.length) ? value[0] : null;
						break;
					
					default:
						throw new XPathException(XPathException.TYPE_ERR, 'XPath result type not supported. (type: ' + type + ')');
						break;
				}
				
				break;
			
			default:
				throw new XPathException(XPathException.TYPE_ERR, 'XPath result type not supported. (type: ' + type + ')');
				break;
		};
	}
	
	XPathResult.factory = function(context, type, value)
	{
		var result;
		
		if (type !== XPathResult.ANY_TYPE)
		{
			return new XPathResult(context, type, value);
		}
		
		// handle any type result
		if (value instanceof NodeSetType)
		{
			result = new XPathResult(context, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, value);
		}
		else if (value instanceof NumberType)
		{
			result = new XPathResult(context, XPathResult.NUMBER_TYPE, value);
		}
		else if (value instanceof BooleanType)
		{
			result = new XPathResult(context, XPathResult.BOOLEAN_TYPE, value);
		}
		else if (value instanceof StringType)
		{
			result = new XPathResult(context, XPathResult.STRING_TYPE, value);
		}
		else
		{
			throw new XPathException(XPathException.TYPE_ERR, 'Internal Error: Unsupported value type: ' + typeof value);
		}
		
		return result;
	}
	
	XPathResult.prototype = {
		/**
		 * A code representing the type of this result, as defined by the type constants.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-resultType
		 * @type {number}
		 */
		resultType: null,
		
		/**
		 * The value of this number result.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-numberValue
		 * @type {number}
		 */
		numberValue: null,
		
		/**
		 * The value of this string result.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-stringValue
		 * @type {String}
		 */
		stringValue: null,
		
		/**
		 * The value of this boolean result.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-booleanValue
		 * @type {boolean}
		 */
		booleanValue: null,
		
		/**
		 * The value of this single node result, which may be null.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-singleNodeValue
		 * @type {Node}
		 */
		singleNodeValue: null,
		
		/**
		 * Signifies that the iterator has become invalid. True if resultType is
		 * UNORDERED_NODE_ITERATOR_TYPE or ORDERED_NODE_ITERATOR_TYPE and the
		 * document has been modified since this result was returned.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-invalid-iterator-state
		 * @type {boolean}
		 */
		invalidIteratorState: null,
		
		/**
		 * The number of nodes in the result snapshot.
		 *
		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-snapshot-length
		 * @type {number}
		 */
		snapshotLength: null,
		
		_iteratorIndex: 0,
		
		iterateNext: function()
		{
			if (
				this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE &&
				this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE
			) {
				throw new XPathException(XPathException.TYPE_ERR, 'iterateNext() method may only be used with results of type UNORDERED_NODE_ITERATOR_TYPE or ORDERED_NODE_ITERATOR_TYPE');
			}
			
			if (this._iteratorIndex < this._value.length)
			{
				return this._value[this._iteratorIndex++];
			}
			
			return null;
		},
		
		snapshotItem: function(index)
		{
			if (
				this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE &&
				this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
			) {
				throw new XPathException(XPathException.TYPE_ERR, 'snapshotItem() method may only be used with results of type UNORDERED_NODE_SNAPSHOT_TYPE or ORDERED_NODE_SNAPSHOT_TYPE');
			}
			
			return this._value[index];
		}
	}
	
	/**
	 * XPathResultType
	 *
	 * An integer indicating what type of result this is.
	 *
	 * If a specific type is specified, then the result will be returned as the corresponding
	 * type, using XPath type conversions where required and possible.
	 */
	
	XPathResult.ANY_TYPE = 0;
	XPathResult.NUMBER_TYPE = 1;
	XPathResult.STRING_TYPE = 2;
	XPathResult.BOOLEAN_TYPE = 3;
	XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
	XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
	XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
	XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
	XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
	XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
	
	/**
	 * The XPathNamespace interface is returned by XPathResult interfaces to
	 * represent the XPath namespace node type that DOM lacks. There is no public
	 * constructor for this node type. Attempts to place it into a hierarchy or a
	 * NamedNodeMap result in a DOMException with the code HIERARCHY_REQUEST_ERR.
	 * This node is read only, so methods or setting of attributes that would
	 * mutate the node result in a DOMException with the code NO_MODIFICATION_ALLOWED_ERR.
	 *
	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathNamespace
	 * @param {string} prefix Prefix of the namespace represented by the node.
	 * @param {string} namespaceURI Namespace URI of the namespace represented by the node.
	 * @param {Element} ownerElement The Element on which the namespace was in scope when it was requested.
	 */
	XPathNamespace = function(prefix, namespaceURI, ownerElement)
	{
		if(ownerElement.nodeType != 1)
		{
			throw new Error('Internal Error: XPathNamespace owner element must be an Element node.');
		}
		this.ownerElement = ownerElement;
		
		// ownerDocument matches the ownerDocument of the ownerElement even if the element is later adopted.
		// TODO-FUTURE: ownerDocument == ownerElement.ownerDocument when ownerElement changes ownerDocument
		this.ownerDocument = ownerElement.ownerDocument;
		
		// nodeName is always the string "#namespace".
		this.nodeName = '#namespace';
		
		// prefix is the prefix of the namespace represented by the node.
		this.prefix = prefix;
		
		// localName is the same as prefix.
		this.localName = prefix;
		
		// nodeType is equal to XPATH_NAMESPACE_NODE.
		this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE
		
		// namespaceURI is the namespace URI of the namespace represented by the node.
		this.namespaceURI = namespaceURI;
		
		// nodeValue is the same as namespaceURI.
		this.nodeValue = namespaceURI;
		
		// adoptNode, cloneNode, and importNode fail on this node type by raising a DOMException with the code NOT_SUPPORTED_ERR.
		// TODO-FUTURE: implement exceptions above, see: http://www.w3.org/TR/DOM-Level-3-Core/
		
		// TODO-FUTURE: find all other attributes of Node not set above, and set the to null or false
		// see: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1950641247
	}
	
	/**
	 * An integer indicating which type of node this is.
	 *
	 * Note: There is currently only one type of node which is specific to XPath. The numbers in this list must not collide with the values assigned to core node types.
	 * 
	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPATH_NAMESPACE_NODE
	 * @property {number} The node is a Namespace.
	 */
	XPathNamespace.XPATH_NAMESPACE_NODE = 13;
	
	module = {
		XPathException: XPathException,
		XPathEvaluator: XPathEvaluator,
		XPathNSResolver: XPathNSResolver,
		XPathExpression: XPathExpression,
		XPathResult: XPathResult,
		XPathNamespace: XPathNamespace,
		
		/**
		 * Get the current list of DOM Level 3 XPath window and document objects
		 * that are in use.
		 *
		 * @return {Object} List of DOM Level 3 XPath window and document objects
		 *         that are currently in use.
		 */
		getCurrentDomLevel3XPathBindings: function()
		{
			return {
				'window': {
					XPathException: window.XPathException,
					XPathExpression: window.XPathExpression,
					XPathNSResolver: window.XPathNSResolver,
					XPathResult: window.XPathResult,
					XPathNamespace: window.XPathNamespace
				},
				'document': {
					createExpression: document.createExpression,
					createNSResolver: document.createNSResolver,
					evaluate: document.evaluate
				}
			}
		},
		
		/**
		 * Get the list of DOM Level 3 XPath objects that are implemented by
		 * the XPathJS module.
		 *
		 * @return {Object} List of DOM Level 3 XPath objects implemented by
		 *         the XPathJS module.
		 */
		createDomLevel3XPathBindings: function(options)
		{
			var evaluator = new XPathEvaluator(options)
			;
			
			return {
				'window': {
					XPathException: XPathException,
					XPathExpression: XPathExpression,
					XPathNSResolver: XPathNSResolver,
					XPathResult: XPathResult,
					XPathNamespace: XPathNamespace
				},
				'document': {
					createExpression: function() {
						return evaluator.createExpression.apply(evaluator, arguments);
					},
					createNSResolver: function() {
						return evaluator.createNSResolver.apply(evaluator, arguments);
					},
					evaluate: function() {
						return evaluator.evaluate.apply(evaluator, arguments);
					}
				}
			}
		},
		
		/**
		 * Bind DOM Level 3 XPath interfaces to the DOM.
		 *
		 * @param {Object} doc the document or (Document.prototype!) to bind the evaluator etc. to
		 * @return List of original DOM Level 3 XPath objects that has been replaced
		 */
		bindDomLevel3XPath: function(doc, bindings)
		{
			var newBindings = (bindings || module.createDomLevel3XPathBindings()),
				currentBindings = module.getCurrentDomLevel3XPathBindings(),
				doc = doc || document,
				i
			;
			
			for(i in newBindings['window'])
			{
				window[i] = newBindings['window'][i];
			}
			
			for(i in newBindings['document'])
			{
				doc[i] = newBindings['document'][i];
			}
			
			return currentBindings;
		}
	}
	
	return module;
	
})();
XPathJS._parser = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { XPath: peg$parseXPath },
        peg$startRuleFunction  = peg$parseXPath,

        peg$c0 = peg$FAILED,
        peg$c1 = function(expr) {
        		return {
        			 tree: expr
        			,nsPrefixes: nsPrefixes
        		}
        	},
        peg$c2 = "/",
        peg$c3 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c4 = null,
        peg$c5 = function(path) {
        		return {
        			 type: '/'
        			,args: [
        				null,
        				(path) ? path[1] : null
        			]
        		};
        	},
        peg$c6 = [],
        peg$c7 = "//",
        peg$c8 = { type: "literal", value: "//", description: "\"//\"" },
        peg$c9 = function(expr, repeatedExpr) {
        		var i;
        		
        		for(i=0; i < repeatedExpr.length; i++)
        		{
        			expr = expandSlashAbbrev(repeatedExpr[i][1], expr, repeatedExpr[i][3]);
        		}
        		
        		return expr;
        	},
        peg$c10 = function(axis, node, predicate) {
        		return predicateExpression({
        			type: 'step',
        			args: [
        				axis,
        				node
        			]},
        			axis,
        			predicate,
        			1
        		);
        	},
        peg$c11 = "::",
        peg$c12 = { type: "literal", value: "::", description: "\"::\"" },
        peg$c13 = function(axis) {
        		return axis;
        	},
        peg$c14 = function(aas) {
        		return (aas.length) ? aas : 'child';
        	},
        peg$c15 = "ancestor-or-self",
        peg$c16 = { type: "literal", value: "ancestor-or-self", description: "\"ancestor-or-self\"" },
        peg$c17 = "ancestor",
        peg$c18 = { type: "literal", value: "ancestor", description: "\"ancestor\"" },
        peg$c19 = "attribute",
        peg$c20 = { type: "literal", value: "attribute", description: "\"attribute\"" },
        peg$c21 = "child",
        peg$c22 = { type: "literal", value: "child", description: "\"child\"" },
        peg$c23 = "descendant-or-self",
        peg$c24 = { type: "literal", value: "descendant-or-self", description: "\"descendant-or-self\"" },
        peg$c25 = "descendant",
        peg$c26 = { type: "literal", value: "descendant", description: "\"descendant\"" },
        peg$c27 = "following-sibling",
        peg$c28 = { type: "literal", value: "following-sibling", description: "\"following-sibling\"" },
        peg$c29 = "following",
        peg$c30 = { type: "literal", value: "following", description: "\"following\"" },
        peg$c31 = "namespace",
        peg$c32 = { type: "literal", value: "namespace", description: "\"namespace\"" },
        peg$c33 = "parent",
        peg$c34 = { type: "literal", value: "parent", description: "\"parent\"" },
        peg$c35 = "preceding-sibling",
        peg$c36 = { type: "literal", value: "preceding-sibling", description: "\"preceding-sibling\"" },
        peg$c37 = "preceding",
        peg$c38 = { type: "literal", value: "preceding", description: "\"preceding\"" },
        peg$c39 = "self",
        peg$c40 = { type: "literal", value: "self", description: "\"self\"" },
        peg$c41 = "(",
        peg$c42 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c43 = ")",
        peg$c44 = { type: "literal", value: ")", description: "\")\"" },
        peg$c45 = function(nodeType) {
        		return {
        			 type: 'nodeType'
        			,args: [
        				nodeType,
        				[]
        			]
        		};
        	},
        peg$c46 = "processing-instruction",
        peg$c47 = { type: "literal", value: "processing-instruction", description: "\"processing-instruction\"" },
        peg$c48 = function(pi, arg) {
        		return {
        			 type: 'nodeType'
        			,args: [
        				pi,
        				[arg]
        			]
        		};
        	},
        peg$c49 = function(nt) {
        		return nt;
        	},
        peg$c50 = "[",
        peg$c51 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c52 = "]",
        peg$c53 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c54 = function(expr) {
        		return expr;
        	},
        peg$c55 = function(path) {
        		return expandSlashAbbrev('//', null, path);
        	},
        peg$c56 = "..",
        peg$c57 = { type: "literal", value: "..", description: "\"..\"" },
        peg$c58 = ".",
        peg$c59 = { type: "literal", value: ".", description: "\".\"" },
        peg$c60 = function(abbrev) {
        		/*
        		 * @see http://www.w3.org/TR/xpath/#path-abbrev
        		 */
        		var result = {
        			type: 'step',
        			args: [
        				'self', // assume .
        				{
        					type: 'nodeType',
        					args: [
        						'node',
        						[]
        					]
        				}
        			]
        		}
        		
        		if (abbrev == '..')
        		{
        			result.args[0] = 'parent';
        		}
        		
        		return result;
        	},
        peg$c61 = "@",
        peg$c62 = { type: "literal", value: "@", description: "\"@\"" },
        peg$c63 = function(attribute) {
        		return (attribute) ? 'attribute' : '';
        	},
        peg$c64 = function(vr) {
        		return vr;
        	},
        peg$c65 = function(l) {
        		return l;
        	},
        peg$c66 = function(n) {
        		return n;
        	},
        peg$c67 = ",",
        peg$c68 = { type: "literal", value: ",", description: "\",\"" },
        peg$c69 = function(name, arg) {
        		var i, args = [];
        		if (arg)
        		{
        			args.push(arg[1]);
        			for (i=0; i < arg[2].length; i++)
        			{
        				args.push(arg[2][i][3]);
        			}
        		}
        		return {
        			 type: 'function'
        			,args: [
        				name,
        				args
        			]
        		};
        	},
        peg$c70 = "|",
        peg$c71 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c72 = function(expr, repeatedExpr) {
        		return expressionSimplifier(expr, repeatedExpr, 1, 3);
        	},
        peg$c73 = function(expr, path) {
        		if (!path)
        			return expr;
        		
        		return expandSlashAbbrev(path[1], expr, path[3]);
        	},
        peg$c74 = function(path) {
        		return path;
        	},
        peg$c75 = function(expr, repeatedExpr) {
        		return predicateExpression(expr, 'child', repeatedExpr, 1);
        	},
        peg$c76 = "or",
        peg$c77 = { type: "literal", value: "or", description: "\"or\"" },
        peg$c78 = "and",
        peg$c79 = { type: "literal", value: "and", description: "\"and\"" },
        peg$c80 = "=",
        peg$c81 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c82 = "!=",
        peg$c83 = { type: "literal", value: "!=", description: "\"!=\"" },
        peg$c84 = "<=",
        peg$c85 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c86 = "<",
        peg$c87 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c88 = ">=",
        peg$c89 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c90 = ">",
        peg$c91 = { type: "literal", value: ">", description: "\">\"" },
        peg$c92 = "+",
        peg$c93 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c94 = "-",
        peg$c95 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c96 = "div",
        peg$c97 = { type: "literal", value: "div", description: "\"div\"" },
        peg$c98 = "mod",
        peg$c99 = { type: "literal", value: "mod", description: "\"mod\"" },
        peg$c100 = function(expr) {
        		return {
        			 type: '*' // multiply
        			,args: [
        				{
        					type: 'number',
        					args: [
        						-1
        					]
        				},
        				expr
        			]
        		}
        	},
        peg$c101 = "\"",
        peg$c102 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c103 = /^[^"]/,
        peg$c104 = { type: "class", value: "[^\"]", description: "[^\"]" },
        peg$c105 = function(literals) {
        		return {
        			type: 'string',
        			args: [
        				literals.join('')
        			]
        		};
        	},
        peg$c106 = "'",
        peg$c107 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c108 = /^[^']/,
        peg$c109 = { type: "class", value: "[^']", description: "[^']" },
        peg$c110 = function(digits, decimals) {
        		return {
        			 type: 'number'
        			,args: [
        				(decimals) ? parseFloat(digits + '.' + decimals[1]) : parseInt(digits)
        			]
        		};
        	},
        peg$c111 = function(digits) {
        		return {
        			type: 'number',
        			args: [
        				parseFloat('.' + digits)
        			]
        		};
        	},
        peg$c112 = /^[0-9]/,
        peg$c113 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c114 = function(digits) {
        		return digits.join('');
        	},
        peg$c115 = "*",
        peg$c116 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c117 = function(name) { // - NodeType
        		var i;
        		
        		// exclude NodeType names
        		if (lastQNameParsed.args[0] === null) // no namespace
        		{
        			for(i=0; i<nodeTypeNames.length; i++)
        			{
        				if (lastQNameParsed.args[1] == nodeTypeNames[i]) // name
        				{
        					// Reserved NodeType name used, so don't allow this function name
        					return false;
        				}
        			}
        		}
        		
        		// function name ok
        		return true;
        	},
        peg$c118 = void 0,
        peg$c119 = function(name) {
        		(name.args[0] === '')
        			? name = {  // NOTE: apparently "name.args[0] = null" doesn't work well because NameTest get's screwed up...
        				 type: name.type
        				,args: [
        					null,
        					name.args[1]
        				]
        			}
        			: trackNsPrefix(name.args[0])
        		;
        		return name;
        	},
        peg$c120 = "$",
        peg$c121 = { type: "literal", value: "$", description: "\"$\"" },
        peg$c122 = function(name) {
        		trackNsPrefix(name.args[0]);
        		
        		return {
        			 type: '$'
        			,args: [
        				name
        			]
        		};
        	},
        peg$c123 = function() {
        		return {
        			 type: 'name'
        			,args: [
        				null,
        				null
        			]
        		};
        	},
        peg$c124 = ":",
        peg$c125 = { type: "literal", value: ":", description: "\":\"" },
        peg$c126 = function(ns) {
        		trackNsPrefix(ns);
        		return {
        			 type: 'name'
        			,args: [
        				ns,
        				null
        			]
        		};
        	},
        peg$c127 = function(name) {
        		trackNsPrefix(name.args[0]);
        		return name;
        	},
        peg$c128 = "comment",
        peg$c129 = { type: "literal", value: "comment", description: "\"comment\"" },
        peg$c130 = "text",
        peg$c131 = { type: "literal", value: "text", description: "\"text\"" },
        peg$c132 = "node",
        peg$c133 = { type: "literal", value: "node", description: "\"node\"" },
        peg$c134 = /^[ \t\r\n]/,
        peg$c135 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },
        peg$c136 = function(name) {
        		lastQNameParsed = name;
        		return name;
        	},
        peg$c137 = function(ns, name) {
        		return {
        			 type: 'name'
        			,args: [
        				ns,
        				name
        			]
        		};
        	},
        peg$c138 = function(name) {
        		return {
        			 type: 'name'
        			,args: [
        				null,
        				name
        			]
        		};
        	},
        peg$c139 = /^[A-Z]/,
        peg$c140 = { type: "class", value: "[A-Z]", description: "[A-Z]" },
        peg$c141 = "_",
        peg$c142 = { type: "literal", value: "_", description: "\"_\"" },
        peg$c143 = /^[a-z]/,
        peg$c144 = { type: "class", value: "[a-z]", description: "[a-z]" },
        peg$c145 = /^[\xC0-\xD6]/,
        peg$c146 = { type: "class", value: "[\\xC0-\\xD6]", description: "[\\xC0-\\xD6]" },
        peg$c147 = /^[\xD8-\xF6]/,
        peg$c148 = { type: "class", value: "[\\xD8-\\xF6]", description: "[\\xD8-\\xF6]" },
        peg$c149 = /^[\xF8-\u02FF]/,
        peg$c150 = { type: "class", value: "[\\xF8-\\u02FF]", description: "[\\xF8-\\u02FF]" },
        peg$c151 = /^[\u0370-\u037D]/,
        peg$c152 = { type: "class", value: "[\\u0370-\\u037D]", description: "[\\u0370-\\u037D]" },
        peg$c153 = /^[\u037F-\u1FFF]/,
        peg$c154 = { type: "class", value: "[\\u037F-\\u1FFF]", description: "[\\u037F-\\u1FFF]" },
        peg$c155 = /^[\u200C-\u200D]/,
        peg$c156 = { type: "class", value: "[\\u200C-\\u200D]", description: "[\\u200C-\\u200D]" },
        peg$c157 = /^[\u2070-\u218F]/,
        peg$c158 = { type: "class", value: "[\\u2070-\\u218F]", description: "[\\u2070-\\u218F]" },
        peg$c159 = /^[\u2C00-\u2FEF]/,
        peg$c160 = { type: "class", value: "[\\u2C00-\\u2FEF]", description: "[\\u2C00-\\u2FEF]" },
        peg$c161 = /^[\u3001-\uD7FF]/,
        peg$c162 = { type: "class", value: "[\\u3001-\\uD7FF]", description: "[\\u3001-\\uD7FF]" },
        peg$c163 = /^[\uF900-\uFDCF]/,
        peg$c164 = { type: "class", value: "[\\uF900-\\uFDCF]", description: "[\\uF900-\\uFDCF]" },
        peg$c165 = /^[\uFDF0-\uFFFD]/,
        peg$c166 = { type: "class", value: "[\\uFDF0-\\uFFFD]", description: "[\\uFDF0-\\uFFFD]" },
        peg$c167 = /^[\xB7]/,
        peg$c168 = { type: "class", value: "[\\xB7]", description: "[\\xB7]" },
        peg$c169 = /^[\u0300-\u036F]/,
        peg$c170 = { type: "class", value: "[\\u0300-\\u036F]", description: "[\\u0300-\\u036F]" },
        peg$c171 = /^[\u203F-\u2040]/,
        peg$c172 = { type: "class", value: "[\\u203F-\\u2040]", description: "[\\u203F-\\u2040]" },
        peg$c173 = function(startchar, chars) {
        		return startchar + chars.join('');
        	},

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parseXPath() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseExpr();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c1(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseLocationPath() {
      var s0;

      s0 = peg$parseRelativeLocationPath();
      if (s0 === peg$FAILED) {
        s0 = peg$parseAbsoluteLocationPath();
      }

      return s0;
    }

    function peg$parseAbsoluteLocationPath() {
      var s0, s1, s2, s3, s4;

      s0 = peg$parseAbbreviatedAbsoluteLocationPath();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c3); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseRelativeLocationPath();
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$c4;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c5(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseRelativeLocationPath() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseStep();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c7) {
            s5 = peg$c7;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s5 = peg$c2;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c3); }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseStep();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c7) {
              s5 = peg$c7;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s5 = peg$c2;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c3); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseStep();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c9(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseStep() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseAxisSpecifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseNodeTest();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsePredicate();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsePredicate();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c10(s1, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseAbbreviatedStep();
      }

      return s0;
    }

    function peg$parseAxisSpecifier() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseAxisName();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c11) {
            s3 = peg$c11;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c12); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseAbbreviatedAxisSpecifier();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c14(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseAxisName() {
      var s0;

      if (input.substr(peg$currPos, 16) === peg$c15) {
        s0 = peg$c15;
        peg$currPos += 16;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 8) === peg$c17) {
          s0 = peg$c17;
          peg$currPos += 8;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 9) === peg$c19) {
            s0 = peg$c19;
            peg$currPos += 9;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c20); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c21) {
              s0 = peg$c21;
              peg$currPos += 5;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c22); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 18) === peg$c23) {
                s0 = peg$c23;
                peg$currPos += 18;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c24); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c25) {
                  s0 = peg$c25;
                  peg$currPos += 10;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c26); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 17) === peg$c27) {
                    s0 = peg$c27;
                    peg$currPos += 17;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c28); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 9) === peg$c29) {
                      s0 = peg$c29;
                      peg$currPos += 9;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c30); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 9) === peg$c31) {
                        s0 = peg$c31;
                        peg$currPos += 9;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c32); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c33) {
                          s0 = peg$c33;
                          peg$currPos += 6;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c34); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 17) === peg$c35) {
                            s0 = peg$c35;
                            peg$currPos += 17;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c36); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 9) === peg$c37) {
                              s0 = peg$c37;
                              peg$currPos += 9;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c38); }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4) === peg$c39) {
                                s0 = peg$c39;
                                peg$currPos += 4;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c40); }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseNodeTest() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseNodeType();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c41;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c42); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c43;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c44); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c45(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 22) === peg$c46) {
          s1 = peg$c46;
          peg$currPos += 22;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c47); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s3 = peg$c41;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c42); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseLiteral();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s7 = peg$c43;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c44); }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c48(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseNameTest();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c49(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsePredicate() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c50;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseExpr();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c52;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c53); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c54(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAbbreviatedAbsoluteLocationPath() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c7) {
        s1 = peg$c7;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseRelativeLocationPath();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c55(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAbbreviatedStep() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c56) {
        s1 = peg$c56;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c57); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c58;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c59); }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c60(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseAbbreviatedAxisSpecifier() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c61;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c4;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c63(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseExpr() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseOrExpr();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c54(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsePrimaryExpr() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseVariableReference();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c64(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c42); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseExpr();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c43;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c44); }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c54(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseLiteral();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c65(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseNumber();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c66(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$parseFunctionCall();
            }
          }
        }
      }

      return s0;
    }

    function peg$parseFunctionCall() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

      s0 = peg$currPos;
      s1 = peg$parseFunctionName();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c41;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c42); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseExpr();
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$currPos;
                s9 = peg$parse_();
                if (s9 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s10 = peg$c67;
                    peg$currPos++;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c68); }
                  }
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parse_();
                    if (s11 !== peg$FAILED) {
                      s12 = peg$parseExpr();
                      if (s12 !== peg$FAILED) {
                        s9 = [s9, s10, s11, s12];
                        s8 = s9;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$c0;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$c0;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$c0;
                  }
                } else {
                  peg$currPos = s8;
                  s8 = peg$c0;
                }
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$currPos;
                  s9 = peg$parse_();
                  if (s9 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s10 = peg$c67;
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c68); }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parseExpr();
                        if (s12 !== peg$FAILED) {
                          s9 = [s9, s10, s11, s12];
                          s8 = s9;
                        } else {
                          peg$currPos = s8;
                          s8 = peg$c0;
                        }
                      } else {
                        peg$currPos = s8;
                        s8 = peg$c0;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$c0;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$c0;
                  }
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c4;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s6 = peg$c43;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c44); }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c69(s1, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseUnionExpr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parsePathExpr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 124) {
            s5 = peg$c70;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c71); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsePathExpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 124) {
              s5 = peg$c70;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c71); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsePathExpr();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsePathExpr() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseFilterExpr();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c7) {
            s4 = peg$c7;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s4 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s4 = peg$c2;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c3); }
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseRelativeLocationPath();
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c73(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseLocationPath();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseFilterExpr() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsePrimaryExpr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsePredicate();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsePredicate();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c75(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseOrExpr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseAndExpr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c76) {
            s5 = peg$c76;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c77); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseAndExpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c76) {
              s5 = peg$c76;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c77); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseAndExpr();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAndExpr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseEqualityExpr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c78) {
            s5 = peg$c78;
            peg$currPos += 3;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c79); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseEqualityExpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c78) {
              s5 = peg$c78;
              peg$currPos += 3;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c79); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseEqualityExpr();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseEqualityExpr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseRelationalExpr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s5 = peg$c80;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c81); }
          }
          if (s5 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c82) {
              s5 = peg$c82;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c83); }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseRelationalExpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c80;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c81); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c82) {
                s5 = peg$c82;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c83); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRelationalExpr();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseRelationalExpr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseAdditiveExpr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c84) {
            s5 = peg$c84;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c85); }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 60) {
              s5 = peg$c86;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c87); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c88) {
                s5 = peg$c88;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c89); }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                  s5 = peg$c90;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c91); }
                }
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseAdditiveExpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c84) {
              s5 = peg$c84;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c85); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 60) {
                s5 = peg$c86;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c87); }
              }
              if (s5 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c88) {
                  s5 = peg$c88;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c89); }
                }
                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 62) {
                    s5 = peg$c90;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c91); }
                  }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseAdditiveExpr();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAdditiveExpr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseMultiplicativeExpr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s5 = peg$c92;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c93); }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s5 = peg$c94;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c95); }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMultiplicativeExpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s5 = peg$c92;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c93); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s5 = peg$c94;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c95); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseMultiplicativeExpr();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseMultiplicativeExpr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseUnaryExpr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseMultiplyOperator();
          if (s5 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c96) {
              s5 = peg$c96;
              peg$currPos += 3;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c97); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c98) {
                s5 = peg$c98;
                peg$currPos += 3;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c99); }
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseUnaryExpr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseMultiplyOperator();
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c96) {
                s5 = peg$c96;
                peg$currPos += 3;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c97); }
              }
              if (s5 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c98) {
                  s5 = peg$c98;
                  peg$currPos += 3;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c99); }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseUnaryExpr();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseUnaryExpr() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseUnionExpr();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c54(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c94;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c95); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseUnaryExpr();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c100(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseLiteral() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c101;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c102); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c103.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c104); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c103.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c104); }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c101;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c102); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c105(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c106;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c107); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c108.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c109); }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c108.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c109); }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c106;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c107); }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c105(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseNumber() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseDigits();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c58;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c59); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDigits();
          if (s4 === peg$FAILED) {
            s4 = peg$c4;
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c110(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c58;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c59); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseDigits();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c111(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseDigits() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c112.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c113); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c112.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c113); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c114(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseMultiplyOperator() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 42) {
        s0 = peg$c115;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c116); }
      }

      return s0;
    }

    function peg$parseFunctionName() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseQName();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c117(s1);
        if (s2) {
          s2 = peg$c118;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c119(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseVariableReference() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 36) {
        s1 = peg$c120;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c121); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseQName();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c122(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseNameTest() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c115;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c116); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c123();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNCName();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c124;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c125); }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
              s3 = peg$c115;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c116); }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c126(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseQName();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c127(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseNodeType() {
      var s0;

      if (input.substr(peg$currPos, 7) === peg$c128) {
        s0 = peg$c128;
        peg$currPos += 7;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c129); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c130) {
          s0 = peg$c130;
          peg$currPos += 4;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c131); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 22) === peg$c46) {
            s0 = peg$c46;
            peg$currPos += 22;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c47); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c132) {
              s0 = peg$c132;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c133); }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseS() {
      var s0, s1;

      s0 = [];
      if (peg$c134.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c135); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c134.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c135); }
          }
        }
      } else {
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parse_() {
      var s0;

      s0 = peg$parseS();
      if (s0 === peg$FAILED) {
        s0 = peg$c4;
      }

      return s0;
    }

    function peg$parseQName() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parsePrefixedName();
      if (s1 === peg$FAILED) {
        s1 = peg$parseUnprefixedName();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c136(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsePrefixedName() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseNCName();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c124;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c125); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseNCName();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c137(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseUnprefixedName() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseNCName();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c138(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseNCName() {
      var s0;

      s0 = peg$parseName();

      return s0;
    }

    function peg$parseNameStartChar() {
      var s0;

      if (peg$c139.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c140); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 95) {
          s0 = peg$c141;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c142); }
        }
        if (s0 === peg$FAILED) {
          if (peg$c143.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c144); }
          }
          if (s0 === peg$FAILED) {
            if (peg$c145.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c146); }
            }
            if (s0 === peg$FAILED) {
              if (peg$c147.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c148); }
              }
              if (s0 === peg$FAILED) {
                if (peg$c149.test(input.charAt(peg$currPos))) {
                  s0 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c150); }
                }
                if (s0 === peg$FAILED) {
                  if (peg$c151.test(input.charAt(peg$currPos))) {
                    s0 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c152); }
                  }
                  if (s0 === peg$FAILED) {
                    if (peg$c153.test(input.charAt(peg$currPos))) {
                      s0 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c154); }
                    }
                    if (s0 === peg$FAILED) {
                      if (peg$c155.test(input.charAt(peg$currPos))) {
                        s0 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c156); }
                      }
                      if (s0 === peg$FAILED) {
                        if (peg$c157.test(input.charAt(peg$currPos))) {
                          s0 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c158); }
                        }
                        if (s0 === peg$FAILED) {
                          if (peg$c159.test(input.charAt(peg$currPos))) {
                            s0 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c160); }
                          }
                          if (s0 === peg$FAILED) {
                            if (peg$c161.test(input.charAt(peg$currPos))) {
                              s0 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c162); }
                            }
                            if (s0 === peg$FAILED) {
                              if (peg$c163.test(input.charAt(peg$currPos))) {
                                s0 = input.charAt(peg$currPos);
                                peg$currPos++;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c164); }
                              }
                              if (s0 === peg$FAILED) {
                                if (peg$c165.test(input.charAt(peg$currPos))) {
                                  s0 = input.charAt(peg$currPos);
                                  peg$currPos++;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c166); }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseNameChar() {
      var s0;

      s0 = peg$parseNameStartChar();
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s0 = peg$c94;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c95); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c58;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c59); }
          }
          if (s0 === peg$FAILED) {
            if (peg$c112.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c113); }
            }
            if (s0 === peg$FAILED) {
              if (peg$c167.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c168); }
              }
              if (s0 === peg$FAILED) {
                if (peg$c169.test(input.charAt(peg$currPos))) {
                  s0 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c170); }
                }
                if (s0 === peg$FAILED) {
                  if (peg$c171.test(input.charAt(peg$currPos))) {
                    s0 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c172); }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseName() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseNameStartChar();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseNameChar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseNameChar();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c173(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }


    	var expressionSimplifier = function(left, right, rightTypeIndex, rightPartIndex)
    	{
    		var  i, j
    			,result = {
    				type: '',
    				args: []
    			}
    		;

    		result.args.push(left);
    		for(i = 0; i < right.length; i++)
    		{
    			switch(typeof rightTypeIndex)
    			{
    				case 'string':
    					result.type = rightTypeIndex;
    					break;

    				case 'object':
    					result.type = right[i][rightTypeIndex[0]];
    					for(j=1; j < rightTypeIndex.length; j++)
    					{
    						result.type = result.type[rightTypeIndex[j]];
    					}
    					break;

    				default:
    					result.type = right[i][rightTypeIndex];
    					break;
    			}
    			result.args.push(
    				(typeof rightPartIndex == 'undefined') ? right[i] : right[i][rightPartIndex]
    			);
    			
    			result = {
    				type: '',
    				args:[
    					result
    				]
    			};
    		}
    		
    		return result.args[0];
    	}
    	
    	,predicateExpression = function(expr, axis, predicate, predicateIndex)
    	{
    		var predicates = [];
    		
    		if (predicate.length < 1)
    		{
    			return expr;
    		}
    		
    		for (i=0; i < predicate.length; i++)
    		{
    			predicates.push(predicate[i][predicateIndex]);
    		}
    		
    		return {
    			type: 'predicate',
    			args: [
    				axis,
    				expr,
    				predicates
    			]
    		}
    	}

    	// Track all namespace prefixes used in the expression
    	,nsPrefixes = []
    	
    	,trackNsPrefix = function(ns)
    	{
    		var  i
    			,nsPrefixExists = false
    		;
    		
    		if (ns === null) return;

    		// add namespace to the list of namespaces
    		for (i = 0; i < nsPrefixes.length; i++) {
    			if (nsPrefixes[i] === ns) {
    				nsPrefixExists = true;
    				break;
    			}
    		}

    		if (!nsPrefixExists)
    		{
    			nsPrefixes.push(ns);
    		}
    	}
    	
    	,lastQNameParsed
    	,nodeTypeNames = [
    		'comment',
    		'text',
    		'processing-instruction',
    		'node'
    	]
    	,expandSlashAbbrev = function(slash, left, right)
    	{
    		if (slash == '/')
    		{
    			return {
    				type: '/',
    				args: [
    					left,
    					right
    				]
    			};
    		}
    		
    		// slash == '//'
    		return {
    			type: '/',
    			args: [
    				{
    					type: '/',
    					args: [
    						left,
    						{
    							type: 'step',
    							args: [
    								'descendant-or-self',
    								{
    									type: 'nodeType',
    									args: [
    										'node',
    										[]
    									]
    								}
    							]
    						}
    					]
    				},
    				right
    			]
    		};
    	}
    	;


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

define("xpath", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.XPathJS;
    };
}(this)));

define( 'enketo-js/plugins',[ 'jquery' ], function( $ ) {

    /**
     * Update number of repeated elements (with class or-repeat)
     *
     * @return {jQuery} [description]
     */
    $.fn.numberRepeats = function() {

        return this.each( function() {

            $( this ).find( '.or-repeat' ).each( function() {
                var repSiblings, qtyRepeats, i;
                // if it is the first-of-type (not that ':first-of-type' does not have cross-browser support)
                if ( $( this ).prev( '.or-repeat' ).length === 0 ) {
                    repSiblings = $( this ).siblings( '.or-repeat' );
                    qtyRepeats = repSiblings.length + 1;
                    if ( qtyRepeats > 1 ) {
                        $( this ).find( '.repeat-number' ).text( '1' );
                        i = 2;
                        repSiblings.each( function() {
                            $( this ).find( '.repeat-number' ).text( i );
                            i++;
                        } );
                    } else {
                        $( this ).find( '.repeat-number' ).empty();
                    }
                }
            } );
        } );
    };

    /**
     * Clears form input fields and triggers events when doing this. If formelement is cloned but not yet added to DOM
     * (and not synchronized with data object), the desired event is probably 'edit' (default). If it is already added
     * to the DOM (and synchronized with data object) a regular change event should be fired
     *
     * @param  {string=} ev event to be triggered when a value is cleared
     * @return { jQuery} [description]
     */
    $.fn.clearInputs = function( ev ) {
        ev = ev || 'edit';
        return this.each( function() {
            //remove media previews
            $( this ).find( '.file-preview' ).remove();
            //remove input values
            $( this ).find( 'input, select, textarea' ).each( function() {
                var type = $( this ).attr( 'type' );
                if ( $( this ).prop( 'nodeName' ).toUpperCase() === 'SELECT' ) {
                    type = 'select';
                }
                if ( $( this ).prop( 'nodeName' ).toUpperCase() === 'TEXTAREA' ) {
                    type = 'textarea';
                }
                switch ( type ) {
                    case 'date':
                    case 'datetime':
                    case 'time':
                    case 'number':
                    case 'search':
                    case 'color':
                    case 'range':
                    case 'url':
                    case 'email':
                    case 'password':
                    case 'text':
                    case 'file':
                        $( this ).removeAttr( 'data-previous-file-name data-loaded-file-name' );
                        /* falls through */
                    case 'hidden':
                    case 'textarea':
                        if ( $( this ).val() !== '' ) {
                            $( this ).val( '' ).trigger( ev );
                        }
                        break;
                    case 'radio':
                    case 'checkbox':
                        if ( $( this ).prop( 'checked' ) ) {
                            $( this ).prop( 'checked', false );
                            $( this ).trigger( ev );
                        }
                        break;
                    case 'select':
                        if ( $( this )[ 0 ].selectedIndex >= 0 ) {
                            $( this )[ 0 ].selectedIndex = -1;
                            $( this ).trigger( ev );
                        }
                        break;
                    default:
                        console.error( 'Unrecognized input type found when trying to reset: ' + type );
                        console.error( $( this ) );
                }
            } );
        } );
    };

    /**
     * Supports a small subset of MarkDown and converts this to HTML: _, __, *, **, []()
     * Also converts newline characters
     *
     * Not supported: escaping and other MarkDown syntax
     */
    $.fn.markdownToHtml = function() {
        return this.each( function() {
            var html,
                $childStore = $( '<div/>' );
            $( this ).children( ':not(input, select, textarea)' ).each( function( index ) {
                var name = '$$$' + index;
                $( this ).clone().markdownToHtml().appendTo( $childStore );
                $( this ).replaceWith( name );
            } );
            html = $( this ).html();
            html = html.replace( /__([^\s][^_]*[^\s])__/gm, "<strong>$1</strong>" );
            html = html.replace( /\*\*([^\s][^\*]*[^\s])\*\*/gm, "<strong>$1</strong>" );
            html = html.replace( /_([^\s][^_]*[^\s])_/gm, '<em>$1</em>' );
            html = html.replace( /\*([^\s][^\*]*[^\s])\*/gm, '<em>$1</em>' );
            //only replaces if url is valid (worthwhile feature?)
            //html = html.replace( /\[(.*)\]\(((https?:\/\/)(([\da-z\.\-]+)\.([a-z\.]{2,6})|(([0-9]{1,3}\.){3}[0-9]{1,3}))([\/\w \.\-]*)*\/?[\/\w \.\-\=\&\?]*)\)/gm, '<a href="$2">$1</a>' );
            html = html.replace( /\[(.*)\]\(([^\)]+)\)/gm, '<a href="$2" target="_blank">$1</a>' );
            html = html.replace( /\n/gm, '<br />' );
            $childStore.children().each( function( i ) {
                var regex = new RegExp( '\\$\\$\\$' + i );
                html = html.replace( regex, $( this )[ 0 ].outerHTML );
            } );
            $( this ).text( '' ).append( html );
        } );
    };

    /**
     * Reverses a jQuery collection
     * @type {Array}
     */
    $.fn.reverse = [].reverse;

} );

//extend native objects, aka monkey patching ..... really I see no harm!

define( 'enketo-js/extend',['require'],function( window ) {
    /**
     * Pads a string with prefixed zeros until the requested string length is achieved.
     * @param  {number} digits [description]
     * @return {String|string}        [description]
     */
    String.prototype.pad = function( digits ) {
        var x = this;
        while ( x.length < digits ) {
            x = '0' + x;
        }
        return x;
    };

    /**
     * Converts a native Date UTC String to a RFC 3339-compliant date string with local offsets
     * used in JavaRosa, so it replaces the Z in the ISOstring with a local offset
     * @return {string} a datetime string formatted according to RC3339 with local offset
     */
    Date.prototype.toISOLocalString = function() {
        //2012-09-05T12:57:00.000-04:00 (ODK)
        var offset = {},
            plus,
            pad2 = function( x ) {
                return ( x < 10 ) ? '0' + x : x;
            };

        if ( this.toString() == 'Invalid Date' ) {
            return this.toString();
        }

        offset.minstotal = this.getTimezoneOffset();
        offset.direction = ( offset.minstotal < 0 ) ? '+' : '-';
        offset.hrspart = pad2( Math.abs( Math.floor( offset.minstotal / 60 ) ) );
        offset.minspart = pad2( Math.abs( Math.floor( offset.minstotal % 60 ) ) );

        return new Date( this.getTime() - ( offset.minstotal * 60 * 1000 ) ).toISOString()
            .replace( 'Z', offset.direction + offset.hrspart + ':' + offset.minspart );
    };
} );

/**
 * Bunch of XPath tools used in Enketo Smart Paper
 */

( function( factory ) {
    if ( typeof define === 'function' && define.amd ) {
        define( 'jquery.xpath',[ 'jquery' ], factory );
    } else {
        factory( jQuery );
    }
}( function( $ ) {

    /**
     * Creates an XPath from a node
     * @param  {string=} rootNodeName   if absent the root is #document
     * @param  {boolean=} includePosition whether or not to include the positions /path/to/repeat[2]/node
     * @return {string}                 XPath
     */
    $.fn.getXPath = function( rootNodeName, includePosition ) {
        //other nodes may have the same XPath but because this function is used to determine the corresponding input name of a data node, index is not included 
        var $sibSameNameAndSelf,
            steps = [],
            position = '',
            $node = this.first(),
            nodeName = $node.prop( 'nodeName' ),
            $parent = $node.parent(),
            parentName = $parent.prop( 'nodeName' );

        rootNodeName = rootNodeName || '#document';
        includePosition = includePosition || false;

        if ( includePosition ) {
            $sibSameNameAndSelf = $node.siblings( nodeName ).addBack();
            position = ( $sibSameNameAndSelf.length > 1 ) ? '[' + ( $sibSameNameAndSelf.index( $node ) + 1 ) + ']' : '';
        }

        steps.push( nodeName + position );

        while ( $parent.length == 1 && parentName !== rootNodeName && parentName !== '#document' ) {
            if ( includePosition ) {
                $sibSameNameAndSelf = $parent.siblings( parentName ).addBack();
                position = ( $sibSameNameAndSelf.length > 1 ) ? '[' + ( $sibSameNameAndSelf.index( $parent ) + 1 ) + ']' : '';
            }
            steps.push( parentName + position );
            $parent = $parent.parent();
            parentName = $parent.prop( 'nodeName' );
        }
        return '/' + steps.reverse().join( '/' );
    };

    /**
     * Simple XPath Compatibility Plugin for jQuery 1.1
     * By John Resig
     * Dual licensed under MIT and GPL.
     * Original plugin code here: http://code.google.com/p/jqueryjs/source/browse/trunk/plugins/xpath/jquery.xpath.js?spec=svn3167&r=3167
     * some changes made by Martijn van de Rijdt (not replacing $.find(), removed context, dot escaping)
     *
     * @param  {string} selector [description]
     * @return {?(Array.<(Element|null)>|Element)}          [description]
     */
    $.fn.xfind = function( selector ) {
        var parts, cur, i;

        // Convert // to " "
        selector = selector.replace( /\/\//g, " " );

        //added by Martijn
        selector = selector.replace( /^\//, "" );
        selector = selector.replace( /\/\.$/, "" );

        // Convert / to >
        selector = selector.replace( /\//g, ">" );

        // Naively convert [elem] into :has(elem)
        selector = selector.replace( /\[([^@].*?)\]/g, function( m, selector ) {
            return ":has(" + selector + ")";
        } );

        // Naively convert /.. into a new set of expressions
        // Martijn: I just don't see this except if this always occurs as nodea/../../parentofnodea/../../grandparentofnodea
        if ( selector.indexOf( ">.." ) >= 0 ) {
            parts = selector.split( />\.\.>?/g );
            //var cur = jQuery(parts[0], context);
            cur = jQuery( parts[ 0 ], this );
            for ( i = 1; i < parts.length; i++ )
                cur = cur.parent( parts[ i ] );
            return cur.get();
        }

        // any remaining dots inside node names need to be escaped (added by Martijn)
        selector = selector.replace( /\./gi, '\\.' );

        //if performance becomes an issue, it's worthwhile implementing this with native XPath instead.
        return this.find( selector );
    };

} ) );



define( 'enketo-js/FormModel',[ 'xpath', 'jquery', 'enketo-js/plugins', 'enketo-js/extend', 'jquery.xpath' ], function( XPathJS, $ ) {
    

    /**
     * Class dealing with the XML Instance (the data) of a form
     *
     * @constructor
     * @param {string} dataStr String of the default XML instance
     */

    function FormModel( dataStr ) {
        var $data,
            that = this;

        this.loadErrors = [];
        this.INSTANCE = /instance\([\'|\"]([^\/:\s]+)[\'|\"]\)/g;
        this.OPENROSA = /(decimal-date-time\(|pow\(|indexed-repeat\(|format-date\(|coalesce\(|join\(|max\(|min\(|random\(|substr\(|int\(|uuid\(|regex\(|now\(|today\(|date\(|if\(|boolean-from-string\(|checklist\(|selected\(|selected-at\(|round\()/;

        //TEMPORARY DUE TO FIREFOX ISSUE, REMOVE ALL NAMESPACES FROM STRING, 
        //BETTER TO LEARN HOW TO DEAL WITH DEFAULT NAMESPACES THOUGH
        dataStr = dataStr.replace( /xmlns\=\"[a-zA-Z0-9\:\/\.]*\"/g, '' );

        try {
            this.xml = $.parseXML( dataStr );
        } catch ( e ) {
            console.error( e );
            this.loadErrors.push( 'Error trying to parse XML model/instance.' );
        }

        $data = $( this.xml );

        this.$ = $data;

        /**
         * Initializes FormModel
         *
         */
        FormModel.prototype.init = function() {
            var /** @type {string} */ val;

            // trimming values
            this.node( null, null, {
                noEmpty: true,
                noTemplate: false
            } ).get().each( function() {
                val = $( this ).text();
                $( this ).text( $.trim( val ) );
            } );

            this.cloneAllTemplates();
            return this.loadErrors;
        };

        /**
         * Constructs a new Nodeset
         *
         * @param {(string|null)=} selector - [type/description]
         * @param {(string|number|null)=} index    - [type/description]
         * @param {(Object|null)=} filter   - [type/description]
         * @param filter.onlyTemplate
         * @param filter.noTemplate
         * @param filter.onlyLeaf
         * @param filter.noEmpty
         * @return {Nodeset}
         */
        this.node = function( selector, index, filter ) {
            return new Nodeset( selector, index, filter );
        };

        /**
         * Inner Class dealing with nodes and nodesets of the XML instance
         *
         * @constructor
         * @param {string=} selector simpleXPath or jQuery selector
         * @param {number=} index    the index of the target node with that selector
         * @param {?{onlyTemplate: boolean, noTemplate: boolean, onlyLeaf: boolean, noEmpty: boolean}=} filter   filter object for the result nodeset
         */

        function Nodeset( selector, index, filter ) {
            var defaultSelector = '*';
            this.originalSelector = selector;
            this.selector = ( typeof selector === 'string' && selector.length > 0 ) ? selector : defaultSelector;
            filter = ( typeof filter !== 'undefined' && filter !== null ) ? filter : {};
            this.filter = filter;
            this.filter.noTemplate = ( typeof filter.noTemplate !== 'undefined' ) ? filter.noTemplate : true;
            this.filter.onlyLeaf = ( typeof filter.onlyLeaf !== 'undefined' ) ? filter.onlyLeaf : false;
            this.filter.onlyTemplate = ( typeof filter.onlyTemplate !== 'undefined' ) ? filter.onlyTemplate : false;
            this.filter.noEmpty = ( typeof filter.noEmpty !== 'undefined' ) ? filter.noEmpty : false;
            this.index = index;

            if ( $data.find( 'model>instance' ).length > 0 ) {
                //to refer to non-first instance, the instance('id_literal')/path/to/node syntax can be used
                if ( this.selector !== defaultSelector && this.selector.indexOf( '/' ) !== 0 && that.INSTANCE.test( this.selector ) ) {
                    this.selector = this.selector.replace( that.INSTANCE, "model > instance#$1" );
                    return;
                }
                //default context is the first instance in the model            
                this.selector = "model > instance:eq(0) " + this.selector;
            }
        }

        /**
         * Privileged method to find data nodes filtered by a jQuery or XPath selector and additional filter properties
         * Without parameters it returns a collection of all data nodes excluding template nodes and their children. Therefore, most
         * queries will not require filter properties. This function handles all (?) data queries in the application.
         *
         * @return {jQuery} jQuery-wrapped filtered instance nodes that match the selector and index
         */
        Nodeset.prototype.get = function() {
            var p, $nodes, /** @type {string} */ val, context;

            // noTemplate is ignored if onlyTemplate === true
            if ( this.filter.onlyTemplate === true ) {
                $nodes = $data.xfind( this.selector ).filter( '[template]' );
            }
            // default
            else if ( this.filter.noTemplate === true ) {
                $nodes = $data.xfind( this.selector ).not( '[template], [template] *' );
            } else {
                $nodes = $data.xfind( this.selector );
            }
            //noEmpty automatically excludes non-leaf nodes
            if ( this.filter.noEmpty === true ) {
                $nodes = $nodes.filter( function() {
                    val = $( this ).text();
                    return $( this ).children().length === 0 && $.trim( val ).length > 0; //$.trim($this.text()).length > 0;
                } );
            }
            //this may still contain empty leaf nodes
            else if ( this.filter.onlyLeaf === true ) {
                $nodes = $nodes.filter( function() {
                    return $( this ).children().length === 0;
                } );
            }
            $nodes = ( typeof this.index !== 'undefined' && this.index !== null ) ? $nodes.eq( this.index ) : $nodes;
            return $nodes;
        };

        /**
         * Sets data node values.
         *
         * @param {(string|Array.<string>)=} newVals    The new value of the node.
         * @param {?string=} expr  XPath expression to validate the node.
         * @param {?string=} xmlDataType XML data type of the node
         *
         * @return {?boolean} null is returned when the node is not found or multiple nodes were selected
         */
        Nodeset.prototype.setVal = function( newVals, expr, xmlDataType ) {
            var $target, curVal, /**@type {string}*/ newVal, success, updated;

            curVal = this.getVal()[ 0 ];

            if ( typeof newVals !== 'undefined' && newVals !== null ) {
                newVal = ( $.isArray( newVals ) ) ? newVals.join( ' ' ) : newVals.toString();
            } else newVal = '';
            newVal = this.convert( newVal, xmlDataType );

            $target = this.get();

            if ( $target.length === 1 && $.trim( newVal.toString() ) !== $.trim( curVal.toString() ) ) { //|| (target.length > 1 && typeof this.index == 'undefined') ){
                //first change the value so that it can be evaluated in XPath (validated)
                $target.text( newVal );
                //then return validation result
                success = this.validate( expr, xmlDataType );
                updated = this.getClosestRepeat();
                updated.nodes = [ $target.prop( 'nodeName' ) ];
                $data.trigger( 'dataupdate', updated );
                //add type="file" attribute for file references
                if ( xmlDataType === 'binary' ) {
                    if ( newVal.length > 0 ) {
                        $target.attr( 'type', 'file' );
                    } else {
                        $target.removeAttr( 'type' );
                    }
                }
                return success;
            }
            if ( $target.length > 1 ) {
                console.error( 'nodeset.setVal expected nodeset with one node, but received multiple' );
                return null;
            }
            if ( $target.length === 0 ) {
                console.error( 'Data node: ' + this.selector + ' with null-based index: ' + this.index + ' not found!' );
                return null;
            }
            //always validate if the new value is not empty, even if value didn't change (see validateAll() function)
            //return (newVal.length > 0 && validateAll) ? this.validate(expr, xmlDataType) : true;
            return null;
        };


        /**
         * Obtains the data value if a JQuery or XPath selector for a single node is provided.
         *
         * @return {Array<string|number|boolean>} [description]
         */
        Nodeset.prototype.getVal = function() {
            var vals = [];
            this.get().each( function() {
                vals.push( $( this ).text() );
            } );
            return vals;
        };

        Nodeset.prototype.getIndex = function( $node ) {
            var nodeName, path, $this, $family;

            $node = $node || this.get();

            if ( $node.length === 1 ) {
                nodeName = $node.prop( 'nodeName' );
                path = $node.getXPath( 'instance' );
                $family = $data.find( nodeName ).filter( function() {
                    $this = $( this );
                    return !$this.is( '[template]' ) && $this.find( 'template' ).length === 0 && path === $this.getXPath( 'instance' );
                } );
                return ( $family.length === 1 ) ? null : $family.index( $node );
            } else {
                console.error( 'no node, or multiple nodes, provided to nodeset.getIndex' );
                return -1;
            }
        };

        // if repeats have not been cloned yet, they are not considered a repeat by this function
        Nodeset.prototype.getClosestRepeat = function() {
            var $node = this.get(),
                nodeName = $node.prop( 'nodeName' );

            while ( $node.siblings( nodeName + ':not([template])' ).length === 0 && nodeName !== 'instance' ) {
                $node = $node.parent();
                nodeName = $node.prop( 'nodeName' );
            }

            return ( nodeName === 'instance' ) ? {} : {
                repeatPath: $node.getXPath( 'instance' ),
                repeatIndex: this.getIndex( $node )
            };
        };

        /**
         * Clone repeat node after all templates have been cloned (after initialization)
         *
         * @param  {jQuery} $precedingTargetNode the node after which to append the clone
         */
        Nodeset.prototype.clone = function( $precedingTargetNode ) {
            var $dataNode, allClonedNodeNames, $this, $clone;

            $dataNode = this.get();
            $precedingTargetNode = $precedingTargetNode || $dataNode;

            if ( $dataNode.length === 1 && $precedingTargetNode.length === 1 ) {
                $clone = $dataNode.clone();

                $clone.insertAfter( $precedingTargetNode )
                    .find( '[template]' )
                    .addBack()
                    .removeAttr( 'template' );

                allClonedNodeNames = [ $dataNode.prop( 'nodeName' ) ];

                $dataNode.find( '*' ).each( function() {
                    $this = $( this );
                    allClonedNodeNames.push( $this.prop( 'nodeName' ) );
                } );

                $data.trigger( 'dataupdate', {
                    nodes: allClonedNodeNames,
                    repeatPath: $dataNode.getXPath( 'instance' ),
                    repeatIndex: this.getIndex( $clone )
                } );

            } else {
                console.error( 'node.clone() function did not receive origin and target nodes' );
            }
        };

        /**
         * Remove a repeat node
         */
        Nodeset.prototype.remove = function() {
            var $dataNode, allRemovedNodeNames, $this, repeatPath, repeatIndex;

            $dataNode = this.get();

            if ( $dataNode.length > 0 ) {

                allRemovedNodeNames = [ $dataNode.prop( 'nodeName' ) ];

                $dataNode.find( '*' ).each( function() {
                    $this = $( this );
                    allRemovedNodeNames.push( $this.prop( 'nodeName' ) );
                } );

                repeatPath = $dataNode.getXPath( 'instance' );
                repeatIndex = this.getIndex( $dataNode );

                $dataNode.remove();

                $data.trigger( 'dataupdate', {
                    updatedNodes: allRemovedNodeNames,
                    repeatPath: repeatPath,
                    repeatIndex: repeatIndex
                } );
            } else {
                console.error( 'could not find node ' + this.selector + ' with index ' + this.index + ' to remove ' );
            }
        };

        /**
         * Convert a value to a specified data type( though always stringified )
         * @param  {?string=} x           value to convert
         * @param  {?string=} xmlDataType XML data type
         * @return {string}               string representation of converted value
         */
        Nodeset.prototype.convert = function( x, xmlDataType ) {
            if ( x.toString() === '' ) {
                return x;
            }
            if ( typeof xmlDataType !== 'undefined' && xmlDataType !== null &&
                typeof this.types[ xmlDataType.toLowerCase() ] !== 'undefined' &&
                typeof this.types[ xmlDataType.toLowerCase() ].convert !== 'undefined' ) {
                return this.types[ xmlDataType.toLowerCase() ].convert( x );
            }
            return x;
        };

        /**
         * Validate a value with an XPath Expression and /or xml data type
         * @param  {?string=} expr        XPath expression
         * @param  {?string=} xmlDataType XML datatype
         * @return {boolean}
         */
        Nodeset.prototype.validate = function( expr, xmlDataType ) {
            var typeValid, exprValid,
                value = this.getVal()[ 0 ];

            if ( value.toString() === '' ) {
                return true;
            }

            if ( typeof xmlDataType == 'undefined' || xmlDataType === null || typeof this.types[ xmlDataType.toLowerCase() ] == 'undefined' ) {
                xmlDataType = 'string';
            }
            typeValid = this.types[ xmlDataType.toLowerCase() ].validate( value );

            exprValid = ( typeof expr !== 'undefined' && expr !== null && expr.length > 0 ) ? that.evaluate( expr, 'boolean', this.originalSelector, this.index ) : true;

            return ( typeValid && exprValid );
        };

        /**
         * @namespace types
         * @type {Object}
         */
        Nodeset.prototype.types = {
            'string': {
                //max length of type string is 255 chars.Convert( truncate ) silently ?
                validate: function( x ) {
                    return true;
                }
            },
            'select': {
                validate: function( x ) {
                    return true;
                }
            },
            'select1': {
                validate: function( x ) {
                    return true;
                }
            },
            'decimal': {
                validate: function( x ) {
                    return ( !isNaN( x - 0 ) && x !== null ) ? true : false;
                }
            },
            'int': {
                validate: function( x ) {
                    return ( !isNaN( x - 0 ) && x !== null && Math.round( x ) == x ) ? true : false; //x.toString() == parseInt(x, 10).toString();
                }
            },
            'date': {
                validate: function( x ) {
                    var pattern = ( /([0-9]{4})([\-]|[\/])([0-9]{2})([\-]|[\/])([0-9]{2})/ ),
                        segments = pattern.exec( x );

                    return ( segments && segments.length === 6 ) ? ( new Date( Number( segments[ 1 ] ), Number( segments[ 3 ] ) - 1, Number( segments[ 5 ] ) ).toString() !== 'Invalid Date' ) : false;
                },
                convert: function( x ) {
                    var pattern = /([0-9]{4})([\-]|[\/])([0-9]{2})([\-]|[\/])([0-9]{2})/,
                        segments = pattern.exec( x ),
                        date = new Date( x );
                    if ( new Date( x ).toString() == 'Invalid Date' ) {
                        //this code is really only meant for the Rhino and PhantomJS engines, in browsers it may never be reached
                        if ( segments && Number( segments[ 1 ] ) > 0 && Number( segments[ 3 ] ) >= 0 && Number( segments[ 3 ] ) < 12 && Number( segments[ 5 ] ) < 32 ) {
                            date = new Date( Number( segments[ 1 ] ), ( Number( segments[ 3 ] ) - 1 ), Number( segments[ 5 ] ) );
                        }
                    }
                    //date.setUTCHours(0,0,0,0);
                    //return date.toUTCString();//.getUTCFullYear(), datetime.getUTCMonth(), datetime.getUTCDate());
                    return date.getUTCFullYear().toString().pad( 4 ) + '-' + ( date.getUTCMonth() + 1 ).toString().pad( 2 ) + '-' + date.getUTCDate().toString().pad( 2 );
                }
            },
            'datetime': {
                validate: function( x ) {
                    //the second part builds in some tolerance for slightly-off dates provides as defaults (e.g.: 2013-05-31T07:00-02)
                    return ( new Date( x.toString() ).toString() !== 'Invalid Date' || new Date( this.convert( x.toString() ) ).toString() !== 'Invalid Date' );
                },
                convert: function( x ) {
                    var date, // timezone, segments, dateS, timeS,
                        patternCorrect = /([0-9]{4}\-[0-9]{2}\-[0-9]{2})([T]|[\s])([0-9]){2}:([0-9]){2}([0-9:.]*)(\+|\-)([0-9]{2}):([0-9]{2})$/,
                        patternAlmostCorrect = /([0-9]{4}\-[0-9]{2}\-[0-9]{2})([T]|[\s])([0-9]){2}:([0-9]){2}([0-9:.]*)(\+|\-)([0-9]{2})$/;
                    /* 
                     * if the pattern is right, or almost right but needs a small correction for JavaScript to handle it,
                     * do not risk changing the time zone by calling toISOLocalString()
                     */
                    if ( new Date( x ).toString() !== 'Invalid Date' && patternCorrect.test( x ) ) {
                        return x;
                    }
                    if ( new Date( x ).toString() == 'Invalid Date' && patternAlmostCorrect.test( x ) ) {
                        return x + ':00';
                    }
                    date = new Date( x );
                    return ( date.toString() !== 'Invalid Date' ) ? date.toISOLocalString() : date.toString();
                }
            },
            'time': {
                validate: function( x ) {
                    var date = new Date(),
                        segments = x.toString().split( ':' );
                    if ( segments.length < 2 ) {
                        return false;
                    }
                    segments[ 2 ] = ( segments[ 2 ] ) ? Number( segments[ 2 ].toString().split( '.' )[ 0 ] ) : 0;

                    return ( segments[ 0 ] < 24 && segments[ 0 ] >= 0 && segments[ 1 ] < 60 && segments[ 1 ] >= 0 && segments[ 2 ] < 60 && segments[ 2 ] >= 0 && date.toString() !== 'Invalid Date' );
                },
                convert: function( x ) {
                    var segments = x.toString().split( ':' );
                    $.each( segments, function( i, val ) {
                        segments[ i ] = val.toString().pad( 2 );
                    } );
                    return segments.join( ':' );
                }
            },
            'barcode': {
                validate: function( x ) {
                    return true;
                }
            },
            'geopoint': {
                validate: function( x ) {
                    var coords = x.toString().trim().split( ' ' );
                    return ( coords[ 0 ] !== '' && coords[ 0 ] >= -90 && coords[ 0 ] <= 90 ) &&
                        ( coords[ 1 ] !== '' && coords[ 1 ] >= -180 && coords[ 1 ] <= 180 ) &&
                        ( typeof coords[ 2 ] == 'undefined' || !isNaN( coords[ 2 ] ) ) &&
                        ( typeof coords[ 3 ] == 'undefined' || ( !isNaN( coords[ 3 ] ) && coords[ 3 ] >= 0 ) );
                },
                convert: function( x ) {
                    return $.trim( x.toString() );
                }
            },
            'geotrace': {
                validate: function( x ) {
                    var geopoints = x.toString().split( ';' );
                    return geopoints.length >= 2 && geopoints.every( function( geopoint ) {
                        return new Nodeset().types.geopoint.validate( geopoint );
                    } );
                },
                convert: function( x ) {
                    return x.toString().trim();
                }
            },
            'geoshape': {
                validate: function( x ) {
                    var geopoints = x.toString().split( ';' );
                    return geopoints.length >= 4 && ( geopoints[ 0 ] === geopoints[ geopoints.length - 1 ] ) && geopoints.every( function( geopoint ) {
                        return new Nodeset().types.geopoint.validate( geopoint );
                    } );
                },
                convert: function( x ) {
                    return x.toString().trim();
                }
            },
            'binary': {
                validate: function( x ) {
                    return true;
                }
            }
        };
    }


    /**
     * Gets the instance ID
     *
     * @return {string} instanceID
     */
    FormModel.prototype.getInstanceID = function() {
        return this.node( ':first>meta>instanceID' ).getVal()[ 0 ];
    };


    //index is the index of the node (defined in Nodeset), that the clone should be added immediately after
    //if a node with that name and that index+1 already exists the node will NOT be cloned
    //almost same as clone() but adds targetIndex and removes template attributes and if no template node exists it will copy a normal node
    //nodeset (givein in node() should include filter noTemplate:false) so it will provide all nodes that that name
    FormModel.prototype.cloneTemplate = function( selector, index ) {
        //console.log('trying to locate data node with path: '+path+' to clone and insert after node with same xpath and index: '+index);
        var $insertAfterNode, name,
            template = this.node( selector, 0, {
                onlyTemplate: true
            } );
        //console.log( 'cloning model template' );
        //if form does not use jr:template="" but the node-to-clone does exist
        template = ( template.get().length === 0 ) ? this.node( selector, 0 ) : template;
        name = template.get().prop( 'nodeName' );
        //console.log( 'going to find node to insert after', selector, index );
        $insertAfterNode = this.node( selector, index ).get();
        //console.log( 'found it', $insertAfterNode.length );

        //if templatenodes and insertafternode(s) have been identified AND the node following insertafternode doesn't already exist(! important for nested repeats!)
        if ( template.get().length === 1 && $insertAfterNode.length === 1 && $insertAfterNode.next().prop( 'nodeName' ) !== name ) { //this.node(selector, index+1).get().length === 0){
            template.clone( $insertAfterNode );
        } else {
            //console.error ('Could locate node: '+path+' with index '+index+' in data instance.There could be multiple template node (a BUG) or none.');
            if ( $insertAfterNode.next().prop( 'nodeName' ) !== name ) {
                console.error( 'Could not find template node and/or node to insert the clone after' );
            }
        }
    };

    /**
     * Initialization function that creates <repeat>able data nodes with the defaults from the template if no repeats have been created yet.
     * Strictly speaking this is not "according to the spec" as the user should be asked first whether it has any data for this question
     * but seems usually always better to assume at least one 'repeat' (= 1 question). It doesn't make use of the Nodeset subclass (CHANGE?)
     *
     * See also: In JavaRosa, the documentation on the jr:template attribute.
     *
     */
    FormModel.prototype.cloneAllTemplates = function() {
        // in reverse document order to properly deal with nested repeat templates
        this.$.find( 'model > instance:eq(0) [template]' ).reverse().each( function() {
            if ( $( this ).parent().closest( '[template]' ).length === 0 && $( this ).siblings( $( this ).prop( 'nodeName' ) ).not( '[template]' ).length === 0 ) {
                $( this ).clone().insertAfter( $( this ) ).find( '*' ).addBack().removeAttr( 'template' );
            }
        } );
    };

    /**
     * See Also:
     * Returns jQuery Data Object (obsolete?)
     * See also: <nodes.get()>, which is always (?) preferred except for debugging.
     *
     * @return {jQuery} JQuery Data Object
     */
    FormModel.prototype.get = function() {
        return this.$ || null;
    };

    /**
     *
     * @return {Element} data XML object (not sure if type is element actually)
     */
    FormModel.prototype.getXML = function() {
        return this.xml || null;
    };

    /**
     * Obtains a cleaned up string of the data instance(s)
     *
     * @param  {boolean=} incTempl indicates whether repeat templates should be included in the return value (default: false)
     * @param  {boolean=} incNs    indicates whether namespaces should be included in return value (default: true)
     * @param  {boolean=} all     indicates whether all instances should be included in the return value (default: false)
     * @return {string}           XML string
     */
    FormModel.prototype.getStr = function( incTempl, incNs, all ) {
        var $docRoot, $dataClone, dataStr;
        dataStr = ( new XMLSerializer() ).serializeToString( this.getInstanceClone( incTempl, incNs, all )[ 0 ] );
        //remove tabs
        dataStr = dataStr.replace( /\t/g, '' );
        return dataStr;
    };

    FormModel.prototype.getInstanceClone = function( incTempl, incNs, all ) {
        var $clone = ( all ) ? this.$.find( ':first' ).clone() : this.node( '> *:first' ).get().clone();
        return ( incTempl ) ? $clone : $clone.find( '[template]' ).remove().end();
    };

    /**
     * There is a bug in JavaRosa that has resulted in the usage of incorrect formulae on nodes inside repeat nodes.
     * Those formulae use absolute paths when relative paths should have been used. See more here:
     * https://bitbucket.org/javarosa/javarosa/wiki/XFormDeviations (point 3).
     * Tools such as pyxform also build forms in this incorrect manner. See https://github.com/modilabs/pyxform/issues/91
     * It will take time to correct this so makeBugCompliant() aims to mimic the incorrect
     * behaviour by injecting the 1-based [position] of repeats into the XPath expressions. The resulting expression
     * will then be evaluated in a way users expect (as if the paths were relative) without having to mess up
     * the XPath Evaluator.
     * E.g. '/data/rep_a/node_a' could become '/data/rep_a[2]/node_a' if the context is inside
     * the second rep_a repeat.
     *
     * This function should be removed as soon as JavaRosa (or maybe just pyxform) fixes the way those formulae
     * are created (or evaluated).
     *
     * @param  {string} expr        the XPath expression
     * @param  {string} selector    of the (context) node on which expression is evaluated
     * @param  {number} index       of the instance node with that selector
     * @return {string} modified    expression with injected positions (1-based!)
     */
    FormModel.prototype.makeBugCompliant = function( expr, selector, index ) {
        var i, parentSelector, parentIndex, $target, $node, nodeName, $siblings, $parents;
        $target = this.node( selector, index ).get();
        // add() sorts the resulting collection in document order
        $parents = $target.parents().add( $target );
        // traverse collection in reverse document order
        for ( i = $parents.length - 1; i >= 0; i-- ) {
            $node = $parents.eq( i );
            // escape any dots in the node name
            nodeName = $node.prop( 'nodeName' ).replace( /\./g, '\\.' );
            $siblings = $node.siblings( nodeName ).not( '[template]' );
            // if the node is a repeat node that has been cloned at least once (i.e. if it has siblings with the same nodeName)
            if ( nodeName.toLowerCase() !== 'instance' && nodeName.toLowerCase() !== 'model' && $siblings.length > 0 ) {
                parentSelector = $node.getXPath( 'instance' );
                parentIndex = $siblings.add( $node ).index( $node );
                // console.log('calculated repeat 0-based index: '+parentIndex+' for repeat node with path: '+parentSelector);
                expr = expr.replace( new RegExp( parentSelector, 'g' ), parentSelector + '[' + ( parentIndex + 1 ) + ']' );
                // console.log( 'new expression: ' + expr );
            }
        }
        return expr;
    };

    /**
     * Evaluates an XPath Expression using XPathJS_javarosa (not native XPath 1.0 evaluator)
     *
     * This function does not seem to work properly for nodeset resulttypes otherwise:
     * muliple nodes can be accessed by returned node.snapshotItem(i)(.textContent)
     * a single node can be accessed by returned node(.textContent)
     *
     * @param  { string }     expr        the expression to evaluate
     * @param  { string= }    resTypeStr  boolean, string, number, nodes (best to always supply this)
     * @param  { string= }    selector    jQuery selector which will be use to provide the context to the evaluator
     * @param  { number= }    index       index of selector in document
     * @param  { boolean= }   tryNative   whether an attempt to try the Native Evaluator is safe (ie. whether it is
     *                                    certain that there are no date comparisons)
     * @return { ?(number|string|boolean|Array<element>) } the result
     */
    FormModel.prototype.evaluate = function( expr, resTypeStr, selector, index, tryNative ) {
        var i, j, error, context, $instanceDoc, instanceDoc, instances, id, resTypeNum, resultTypes, result, $result, attr,
            $collection, $contextWrapNodes, $repParents, response, openrosa;

        //console.time( 'eval in Model' );
        //console.debug( 'evaluating expr: ' + expr + ' with context selector: ' + selector + ', 0-based index: ' +
        //    index + ' and result type: ' + resTypeStr );
        tryNative = tryNative || false;
        resTypeStr = resTypeStr || 'any';
        index = index || 0;

        expr = expr.trim();

        /* 
            creating a new instanceDoc is necessary for 3 reasons:
            - the primary instance needs to be the root (and it isn't as the root is <model> and there can be multiple <instance>s)
            - the templates need to be removed (though this could be worked around by adding the templates as data)
            - the hack described below with multiple instances.
        */
        $instanceDoc = new FormModel( this.getStr( false, false ) ).$;
        instanceDoc = $instanceDoc[ 0 ];

        /* 
            If the expression contains the instance('id') syntax, a different context instance is required.
            However, the same expression may also contain absolute reference to the main data instance, 
            which means 2 different contexts would have to be supplied to the XPath Evaluator which is not
            possible. Alternatively, the XPath Evaluator becomes able to use a default instance and direct 
            the instance(id) references to a sibling instance context. The latter proved to be too hard for 
            this developer, so as a workaround, the following is used instead:
            The instance referred to in instance(id) is detached and appended to the main instance. The 
            instance(id) syntax is subsequently converted to /node()/instance[@id=id] XPath syntax.
        */

        if ( this.INSTANCE.test( expr ) ) {
            instances = expr.match( this.INSTANCE );
            for ( i = 0; i < instances.length; i++ ) {
                id = instances[ i ].match( /[\'|\"]([^\'']+)[\'|\"]/ )[ 1 ];
                expr = expr.replace( instances[ i ], '/node()/instance[@id="' + id + '"]' );
                this.$.find( ':first>instance#' + id ).clone().appendTo( $instanceDoc.find( ':first' ) );
            }
        }

        if ( typeof selector !== 'undefined' && selector !== null ) {
            context = $instanceDoc.xfind( selector ).eq( index )[ 0 ];
            /*
             * If the context for the expression is a node that is inside a repeat.... see makeBugCompliant()
             */
            $collection = this.node( selector ).get();
            if ( $collection.length > 1 ) {
                //console.log('going to inject position into: '+expr+' for context: '+selector+' and index: '+index);
                expr = this.makeBugCompliant( expr, selector, index );
            }
        } else {
            context = instanceDoc;
        }

        resultTypes = {
            0: [ 'any', 'ANY_TYPE' ],
            1: [ 'number', 'NUMBER_TYPE', 'numberValue' ],
            2: [ 'string', 'STRING_TYPE', 'stringValue' ],
            3: [ 'boolean', 'BOOLEAN_TYPE', 'booleanValue' ],
            7: [ 'nodes', 'ORDERED_NODE_SNAPSHOT_TYPE' ],
            9: [ 'node', 'FIRST_ORDERED_NODE_TYPE' ]
        };

        // translate typeStr to number according to DOM level 3 XPath constants
        for ( resTypeNum in resultTypes ) {

            resTypeNum = Number( resTypeNum );

            if ( resultTypes[ resTypeNum ][ 0 ] == resTypeStr ) {
                break;
            } else {
                resTypeNum = 0;
            }
        }

        expr = expr.replace( /&lt;/g, '<' );
        expr = expr.replace( /&gt;/g, '>' );
        expr = expr.replace( /&quot;/g, '"' );

        // try native to see if that works... (will not work if the expr contains custom OpenRosa functions)
        if ( tryNative && typeof instanceDoc.evaluate !== 'undefined' && !this.OPENROSA.test( expr ) ) {
            try {
                // console.log( 'trying the blazing fast native XPath Evaluator for', expr, index );
                result = instanceDoc.evaluate( expr, context, null, resTypeNum, null );
            } catch ( e ) {
                console.log( '%cWell native XPath evaluation that did not work... No worries, worth a shot, the expression probably ' +
                    'contained unknown OpenRosa functions or errors:', 'color:orange', expr );
            }
        }

        // if that didn't work, try the slow XPathJS evaluator 
        if ( !result ) {
            try {
                // console.log( 'trying the super slow XPathJS_javarosa evaluator for', expr, index );
                // bind the replacement evaluator to the instance of XMLDocument
                XPathJS.bindDomLevel3XPath( instanceDoc );
                result = instanceDoc.evaluate( expr, context, null, resTypeNum, null );
            } catch ( e ) {
                error = 'Error occurred trying to evaluate: ' + expr + ', message: ' + e.message;
                console.error( error );
                $( document ).trigger( 'xpatherror', error );
                this.loadErrors.push( error );
                //console.timeEnd( 'eval in Model' );
                return null;
            }
        }

        // get desired value from result object
        if ( result ) {
            // for type = any, see if a valid string, number or boolean is returned
            if ( resTypeNum === 0 ) {
                for ( resTypeNum in resultTypes ) {
                    resTypeNum = Number( resTypeNum );
                    if ( resTypeNum == Number( result.resultType ) && resTypeNum > 0 && resTypeNum < 4 ) {
                        response = result[ resultTypes[ resTypeNum ][ 2 ] ];
                        break;
                    }
                }
                console.error( 'Expression: ' + expr + ' did not return any boolean, string or number value as expected' );
            } else if ( resTypeNum === 7 ) {
                // response is an array of Elements
                response = [];
                for ( j = 0; j < result.snapshotLength; j++ ) {
                    response.push( result.snapshotItem( j ) );
                }
            } else {
                response = result[ resultTypes[ resTypeNum ][ 2 ] ];
            }
            //console.timeEnd( 'eval in Model' );
            return response;
        }
    };

    return FormModel;
} );

/**
 * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text',['module'], function (module) {
    

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.10',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file.indexOf('\uFEFF') === 0) {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                errback(e);
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes,
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});


define('text!enketo-config',[],function () { return '{\n    "widgets": [\n        "enketo-widget/note/notewidget",\n        "enketo-widget/select-desktop/selectpicker",\n        "enketo-widget/select-mobile/selectpicker",\n        "enketo-widget/geo/geopicker",\n        "enketo-widget/table/tablewidget",\n        "enketo-widget/radio/radiopicker",\n        "enketo-widget/date/datepicker-extended",\n        "enketo-widget/time/timepicker-extended",\n        "enketo-widget/datetime/datetimepicker-extended",\n        "enketo-widget/mediagrid/mediagridpicker",\n        "enketo-widget/file-offline/offline-filepicker",\n        "enketo-widget/select-likert/likertitem",\n        "enketo-widget/distress/distresspicker"\n    ],\n    "tile": {\n        "source": "https://{s}.tiles.mapbox.com/v3/examples.map-vyofok3q/{z}/{x}/{y}.png",\n        "attribution": "Map data &copy; <a target=\\"_blank\\" href=\\"http://openstreetmap.org\\">OpenStreetMap</a> contributors"\n    },\n    "google_api_key": ""\n}\n';});

define( 'enketo-js/widgets',[ 'text!enketo-config', 'Modernizr', 'jquery' ], function( configStr, Modernizr, $ ) {
    

    var $form,
        widgetConfig = [],
        loaded = false,
        globalConfig = JSON.parse( configStr );

    /**
     * Initializes widgets
     *
     * @param  {jQuery} $group The element inside which the widgets have to be initialized.
     */

    function init( $group ) {
        $form = $( 'form.or' );
        $group = $group || $form;

        if ( !loaded ) {
            load( function() {
                create( $group );
            } );
        } else {
            create( $group );
        }
    }

    /**
     * load the widget modules (asynchronously)
     *
     * @param  {Function} callback
     */

    function load( callback ) {
        require( globalConfig.widgets, function() {
            var id,
                widgetConfigFiles = [];

            //console.log( 'widget modules loaded', arguments.length );

            //add widget configuration to config object
            for ( var i = 0; i < globalConfig.widgets.length; i++ ) {
                id = 'text!' + globalConfig.widgets[ i ].substr( 0, globalConfig.widgets[ i ].lastIndexOf( '/' ) + 1 ) + 'config.json';
                widgetConfigFiles.push( id );
            }

            //load widget config files
            require( widgetConfigFiles, function() {
                for ( var i = 0; i < arguments.length; i++ ) {
                    widgetConfig.push( JSON.parse( arguments[ i ] ) );
                }
                //console.log( 'widget config files loaded', widgetConfig.length );
                loaded = true;
                callback();
            } );
        } );
    }

    /**
     * Returns the elements on which to apply the widget
     *
     * @param  {jQuery} $group   a jQuery-wrapped element
     * @param  {string} selector if the selector is null, the form element will be returned
     * @return {jQuery}          a jQuery collection
     */

    function getElements( $group, selector ) {
        return ( selector ) ? $group.find( selector ) : $form;
    }

    /**
     * Enables widgets if they weren't enabled already when the branch was enabled by the controller.
     * In most widgets, this function will do nothing because the disabled attribute was automatically removed from all
     * fieldsets, inputs, textareas and selects inside the branch element provided as parameter.
     * Note that this function can be called before the widgets have been initialized and will in that case do nothing. This is
     * actually preferable than waiting for create() to complete, because enable() will never do anything that isn't
     * done during create().
     *
     * @param  {jQuery} $group [description]
     */

    function enable( $group ) {
        var widget, $els;

        //console.debug( 'enabling widgets in ', $group );

        for ( var i = 0; i < widgetConfig.length; i++ ) {
            widget = widgetConfig[ i ];
            if ( widget.name ) {
                $els = getElements( $group, widget.selector );
                $els[ widget.name ]( 'enable' );
            }
        }
    }

    /**
     * Disables  widgets, if they aren't disabled already when the branch was disabled by the controller.
     * In most widgets, this function will do nothing because all fieldsets, inputs, textareas and selects will get
     * the disabled attribute automatically when the branch element provided as parameter becomes irrelevant.
     *
     * @param  { jQuery } $group The element inside which all widgets need to be disabled.
     */

    function disable( $group ) {
        var widget, $els;

        //console.debug( 'disabling widgets in ', $group );

        for ( var i = 0; i < widgetConfig.length; i++ ) {

            widget = widgetConfig[ i ];
            if ( widget.name ) {
                $els = getElements( $group, widget.selector );
                $els[ widget.name ]( 'disable' );
            }

        }
    }

    /**
     * Fixes deeply cloned widgets, if necessary. This function is only called with the repeat clone as a parameter.
     * Many eventhandlers inside widgets get messed up when they are cloned. If so this function will have to fix
     * that. The init function is called programmatically immediately afterwards.
     *
     * @param  {jQuery} $group The element inside which all widgets need to be fixed.
     */

    function destroy( $group ) {
        var widget, $els;

        for ( var i = 0; i < widgetConfig.length; i++ ) {
            widget = widgetConfig[ i ];
            if ( widget.name ) {
                $els = getElements( $group, widget.selector );
                $els[ widget.name ]( 'destroy' );
            }
        }
    }

    /**
     * Creates widgets upon initialization of the form or on a cloned element after having called 'destroy' first
     *
     * @param  {jQuery} $group The elements inside which widgets need to be created.
     */

    function create( $group ) {
        var widget, $els;

        //console.log( 'widgets', widgetConfig );
        for ( var i = 0; i < widgetConfig.length; i++ ) {
            widget = widgetConfig[ i ];
            widget.options = widget.options || {};
            widget.options.touch = Modernizr.touch;

            // if the widget is a css-only widget
            if ( !widget.name ) {
                //console.log( 'CSS-only widget', widgetConfig[ i ] );
            } else if ( !widget.selector && widget.selector !== null ) {
                console.error( 'widget configuration has no acceptable selector property', widget );
            } else {
                $els = getElements( $group, widget.selector );

                $els[ widget.name ]( widget.options );

                setLangChangeHandler( widget, $els );
                setOptionChangeHandler( widget, $els );
            }
        }
    }

    /**
     * Calls widget('update') when the language changes. This function is called upon initialization,
     * and whenever a new repeat is created. In the latter case, since the widget('update') is called upon
     * the elements of the repeat, there should be no duplicate eventhandlers.
     *
     * @param {{name: string}} widget The widget configuration object
     * @param {jQuery}         $els   The jQuery collection of elements that the widget has been instantiated on.
     */

    function setLangChangeHandler( widget, $els ) {
        //call update for all widgets when language changes 
        if ( $els.length > 0 ) {
            $form.on( 'changelanguage', function() {
                //console.debug( 'change language event detected, going to update', widget.name );
                $els[ widget.name ]( 'update' );
            } );
        }
    }

    /**
     * Calls widget('update') on select-type widgets when the options change.This function is called upon initialization,
     * and whenever a new repeat is created. In the latter case, since the widget('update') is called upon
     * the elements of the repeat, there should be no duplicate eventhandlers.
     *
     * @param {{name: string}} widget The widget configuration object
     * @param {jQuery}         $els   The jQuery collection of elements that the widget has been instantiated on.
     */

    function setOptionChangeHandler( widget, $els ) {
        if ( $els.length > 0 && $els.prop( 'nodeName' ).toLowerCase() === 'select' ) {
            $form.on( 'changeoption', 'select', function() {
                //console.debug( 'option change detected, going to update', widget.name, 'for', $( this ) );
                //update (itemselect) picker on which event was triggered because the options changed
                $( this )[ widget.name ]( 'update' );
            } );
        }
    }

    return {
        init: init,
        enable: enable,
        disable: disable,
        destroy: destroy
    };

} );

/*!
 * Bootstrap v3.1.1 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

if ( typeof jQuery === 'undefined' ) {
    throw new Error( 'Bootstrap\'s JavaScript requires jQuery' )
}

/* ========================================================================
 * Bootstrap: transition.js v3.1.1
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
    // ============================================================

    function transitionEnd() {
        var el = document.createElement( 'bootstrap' )

        var transEndEventNames = {
            'WebkitTransition': 'webkitTransitionEnd',
            'MozTransition': 'transitionend',
            'OTransition': 'oTransitionEnd otransitionend',
            'transition': 'transitionend'
        }

        for ( var name in transEndEventNames ) {
            if ( el.style[ name ] !== undefined ) {
                return {
                    end: transEndEventNames[ name ]
                }
            }
        }

        return false // explicit for ie8 (  ._.)
    }

    // http://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function( duration ) {
        var called = false,
            $el = this
            $( this ).one( $.support.transition.end, function() {
                called = true
            } )
            var callback = function() {
                if ( !called ) $( $el ).trigger( $.support.transition.end )
        }
        setTimeout( callback, duration )
        return this
    }

    $( function() {
        $.support.transition = transitionEnd()
    } )

}( jQuery );

/* ========================================================================
 * Bootstrap: alert.js v3.1.1
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // ALERT CLASS DEFINITION
    // ======================

    var dismiss = '[data-dismiss="alert"]'
    var Alert = function( el ) {
        $( el ).on( 'click', dismiss, this.close )
    }

    Alert.prototype.close = function( e ) {
        var $this = $( this )
        var selector = $this.attr( 'data-target' )

        if ( !selector ) {
            selector = $this.attr( 'href' )
            selector = selector && selector.replace( /.*(?=#[^\s]*$)/, '' ) // strip for ie7
        }

        var $parent = $( selector )

        if ( e ) e.preventDefault()

        if ( !$parent.length ) {
            $parent = $this.hasClass( 'alert' ) ? $this : $this.parent()
        }

        $parent.trigger( e = $.Event( 'close.bs.alert' ) )

        if ( e.isDefaultPrevented() ) return

        $parent.removeClass( 'in' )

        function removeElement() {
            $parent.trigger( 'closed.bs.alert' ).remove()
        }

        $.support.transition && $parent.hasClass( 'fade' ) ?
            $parent
            .one( $.support.transition.end, removeElement )
            .emulateTransitionEnd( 150 ) :
            removeElement()
    }


    // ALERT PLUGIN DEFINITION
    // =======================

    var old = $.fn.alert

    $.fn.alert = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.alert' )

            if ( !data ) $this.data( 'bs.alert', ( data = new Alert( this ) ) )
            if ( typeof option == 'string' ) data[ option ].call( $this )
        } )
    }

    $.fn.alert.Constructor = Alert


    // ALERT NO CONFLICT
    // =================

    $.fn.alert.noConflict = function() {
        $.fn.alert = old
        return this
    }


    // ALERT DATA-API
    // ==============

    $( document ).on( 'click.bs.alert.data-api', dismiss, Alert.prototype.close )

}( jQuery );

/* ========================================================================
 * Bootstrap: button.js v3.1.1
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // BUTTON PUBLIC CLASS DEFINITION
    // ==============================

    var Button = function( element, options ) {
        this.$element = $( element )
        this.options = $.extend( {}, Button.DEFAULTS, options )
        this.isLoading = false
    }

    Button.DEFAULTS = {
        loadingText: 'loading...'
    }

    Button.prototype.setState = function( state ) {
        var d = 'disabled'
        var $el = this.$element
        var val = $el.is( 'input' ) ? 'val' : 'html'
        var data = $el.data()

        state = state + 'Text'

        if ( !data.resetText ) $el.data( 'resetText', $el[ val ]() )

        $el[ val ]( data[ state ] || this.options[ state ] )

        // push to event loop to allow forms to submit
        setTimeout( $.proxy( function() {
            if ( state == 'loadingText' ) {
                this.isLoading = true
                $el.addClass( d ).attr( d, d )
            } else if ( this.isLoading ) {
                this.isLoading = false
                $el.removeClass( d ).removeAttr( d )
            }
        }, this ), 0 )
    }

    Button.prototype.toggle = function() {
        var changed = true
        var $parent = this.$element.closest( '[data-toggle="buttons"]' )

        if ( $parent.length ) {
            var $input = this.$element.find( 'input' )
            if ( $input.prop( 'type' ) == 'radio' ) {
                if ( $input.prop( 'checked' ) && this.$element.hasClass( 'active' ) ) changed = false
                else $parent.find( '.active' ).removeClass( 'active' )
            }
            if ( changed ) $input.prop( 'checked', !this.$element.hasClass( 'active' ) ).trigger( 'change' )
        }

        if ( changed ) this.$element.toggleClass( 'active' )
    }


    // BUTTON PLUGIN DEFINITION
    // ========================

    var old = $.fn.button

    $.fn.button = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.button' )
            var options = typeof option == 'object' && option

            if ( !data ) $this.data( 'bs.button', ( data = new Button( this, options ) ) )

            if ( option == 'toggle' ) data.toggle()
            else if ( option ) data.setState( option )
        } )
    }

    $.fn.button.Constructor = Button


    // BUTTON NO CONFLICT
    // ==================

    $.fn.button.noConflict = function() {
        $.fn.button = old
        return this
    }


    // BUTTON DATA-API
    // ===============

    $( document ).on( 'click.bs.button.data-api', '[data-toggle^=button]', function( e ) {
        var $btn = $( e.target )
        if ( !$btn.hasClass( 'btn' ) ) $btn = $btn.closest( '.btn' )
        $btn.button( 'toggle' )
        e.preventDefault()
    } )

}( jQuery );

/* ========================================================================
 * Bootstrap: carousel.js v3.1.1
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // CAROUSEL CLASS DEFINITION
    // =========================

    var Carousel = function( element, options ) {
        this.$element = $( element )
        this.$indicators = this.$element.find( '.carousel-indicators' )
        this.options = options
        this.paused =
            this.sliding =
            this.interval =
            this.$active =
            this.$items = null

        this.options.pause == 'hover' && this.$element
            .on( 'mouseenter', $.proxy( this.pause, this ) )
            .on( 'mouseleave', $.proxy( this.cycle, this ) )
    }

    Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true
    }

    Carousel.prototype.cycle = function( e ) {
        e || ( this.paused = false )

        this.interval && clearInterval( this.interval )

        this.options.interval && !this.paused && ( this.interval = setInterval( $.proxy( this.next, this ), this.options.interval ) )

        return this
    }

    Carousel.prototype.getActiveIndex = function() {
        this.$active = this.$element.find( '.item.active' )
        this.$items = this.$active.parent().children()

        return this.$items.index( this.$active )
    }

    Carousel.prototype.to = function( pos ) {
        var that = this
        var activeIndex = this.getActiveIndex()

        if ( pos > ( this.$items.length - 1 ) || pos < 0 ) return

        if ( this.sliding ) return this.$element.one( 'slid.bs.carousel', function() {
            that.to( pos )
        } )
        if ( activeIndex == pos ) return this.pause().cycle()

        return this.slide( pos > activeIndex ? 'next' : 'prev', $( this.$items[ pos ] ) )
    }

    Carousel.prototype.pause = function( e ) {
        e || ( this.paused = true )

        if ( this.$element.find( '.next, .prev' ).length && $.support.transition ) {
            this.$element.trigger( $.support.transition.end )
            this.cycle( true )
        }

        this.interval = clearInterval( this.interval )

        return this
    }

    Carousel.prototype.next = function() {
        if ( this.sliding ) return
        return this.slide( 'next' )
    }

    Carousel.prototype.prev = function() {
        if ( this.sliding ) return
        return this.slide( 'prev' )
    }

    Carousel.prototype.slide = function( type, next ) {
        var $active = this.$element.find( '.item.active' )
        var $next = next || $active[ type ]()
        var isCycling = this.interval
        var direction = type == 'next' ? 'left' : 'right'
        var fallback = type == 'next' ? 'first' : 'last'
        var that = this

        if ( !$next.length ) {
            if ( !this.options.wrap ) return
            $next = this.$element.find( '.item' )[ fallback ]()
        }

        if ( $next.hasClass( 'active' ) ) return this.sliding = false

        var e = $.Event( 'slide.bs.carousel', {
            relatedTarget: $next[ 0 ],
            direction: direction
        } )
        this.$element.trigger( e )
        if ( e.isDefaultPrevented() ) return

        this.sliding = true

        isCycling && this.pause()

        if ( this.$indicators.length ) {
            this.$indicators.find( '.active' ).removeClass( 'active' )
            this.$element.one( 'slid.bs.carousel', function() {
                var $nextIndicator = $( that.$indicators.children()[ that.getActiveIndex() ] )
                $nextIndicator && $nextIndicator.addClass( 'active' )
            } )
        }

        if ( $.support.transition && this.$element.hasClass( 'slide' ) ) {
            $next.addClass( type )
            $next[ 0 ].offsetWidth // force reflow
            $active.addClass( direction )
            $next.addClass( direction )
            $active
                .one( $.support.transition.end, function() {
                    $next.removeClass( [ type, direction ].join( ' ' ) ).addClass( 'active' )
                    $active.removeClass( [ 'active', direction ].join( ' ' ) )
                    that.sliding = false
                    setTimeout( function() {
                        that.$element.trigger( 'slid.bs.carousel' )
                    }, 0 )
                } )
                .emulateTransitionEnd( $active.css( 'transition-duration' ).slice( 0, -1 ) * 1000 )
        } else {
            $active.removeClass( 'active' )
            $next.addClass( 'active' )
            this.sliding = false
            this.$element.trigger( 'slid.bs.carousel' )
        }

        isCycling && this.cycle()

        return this
    }


    // CAROUSEL PLUGIN DEFINITION
    // ==========================

    var old = $.fn.carousel

    $.fn.carousel = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.carousel' )
            var options = $.extend( {}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option )
            var action = typeof option == 'string' ? option : options.slide

            if ( !data ) $this.data( 'bs.carousel', ( data = new Carousel( this, options ) ) )
            if ( typeof option == 'number' ) data.to( option )
            else if ( action ) data[ action ]()
            else if ( options.interval ) data.pause().cycle()
        } )
    }

    $.fn.carousel.Constructor = Carousel


    // CAROUSEL NO CONFLICT
    // ====================

    $.fn.carousel.noConflict = function() {
        $.fn.carousel = old
        return this
    }


    // CAROUSEL DATA-API
    // =================

    $( document ).on( 'click.bs.carousel.data-api', '[data-slide], [data-slide-to]', function( e ) {
        var $this = $( this ),
            href
        var $target = $( $this.attr( 'data-target' ) || ( href = $this.attr( 'href' ) ) && href.replace( /.*(?=#[^\s]+$)/, '' ) ) //strip for ie7
        var options = $.extend( {}, $target.data(), $this.data() )
        var slideIndex = $this.attr( 'data-slide-to' )
        if ( slideIndex ) options.interval = false

        $target.carousel( options )

        if ( slideIndex = $this.attr( 'data-slide-to' ) ) {
            $target.data( 'bs.carousel' ).to( slideIndex )
        }

        e.preventDefault()
    } )

    $( window ).on( 'load', function() {
        $( '[data-ride="carousel"]' ).each( function() {
            var $carousel = $( this )
            $carousel.carousel( $carousel.data() )
        } )
    } )

}( jQuery );

/* ========================================================================
 * Bootstrap: collapse.js v3.1.1
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // COLLAPSE PUBLIC CLASS DEFINITION
    // ================================

    var Collapse = function( element, options ) {
        this.$element = $( element )
        this.options = $.extend( {}, Collapse.DEFAULTS, options )
        this.transitioning = null

        if ( this.options.parent ) this.$parent = $( this.options.parent )
        if ( this.options.toggle ) this.toggle()
    }

    Collapse.DEFAULTS = {
        toggle: true
    }

    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass( 'width' )
        return hasWidth ? 'width' : 'height'
    }

    Collapse.prototype.show = function() {
        if ( this.transitioning || this.$element.hasClass( 'in' ) ) return

        var startEvent = $.Event( 'show.bs.collapse' )
        this.$element.trigger( startEvent )
        if ( startEvent.isDefaultPrevented() ) return

        var actives = this.$parent && this.$parent.find( '> .panel > .in' )

        if ( actives && actives.length ) {
            var hasData = actives.data( 'bs.collapse' )
            if ( hasData && hasData.transitioning ) return
            actives.collapse( 'hide' )
            hasData || actives.data( 'bs.collapse', null )
        }

        var dimension = this.dimension()

        this.$element
            .removeClass( 'collapse' )
            .addClass( 'collapsing' )[ dimension ]( 0 )

        this.transitioning = 1

        var complete = function() {
            this.$element
                .removeClass( 'collapsing' )
                .addClass( 'collapse in' )[ dimension ]( 'auto' )
            this.transitioning = 0
            this.$element.trigger( 'shown.bs.collapse' )
        }

        if ( !$.support.transition ) return complete.call( this )

        var scrollSize = $.camelCase( [ 'scroll', dimension ].join( '-' ) )

        this.$element
            .one( $.support.transition.end, $.proxy( complete, this ) )
            .emulateTransitionEnd( 350 )[ dimension ]( this.$element[ 0 ][ scrollSize ] )
    }

    Collapse.prototype.hide = function() {
        if ( this.transitioning || !this.$element.hasClass( 'in' ) ) return

        var startEvent = $.Event( 'hide.bs.collapse' )
        this.$element.trigger( startEvent )
        if ( startEvent.isDefaultPrevented() ) return

        var dimension = this.dimension()

        this.$element[ dimension ]( this.$element[ dimension ]() )[ 0 ].offsetHeight

        this.$element
            .addClass( 'collapsing' )
            .removeClass( 'collapse' )
            .removeClass( 'in' )

        this.transitioning = 1

        var complete = function() {
            this.transitioning = 0
            this.$element
                .trigger( 'hidden.bs.collapse' )
                .removeClass( 'collapsing' )
                .addClass( 'collapse' )
        }

        if ( !$.support.transition ) return complete.call( this )

        this.$element[ dimension ]( 0 )
            .one( $.support.transition.end, $.proxy( complete, this ) )
            .emulateTransitionEnd( 350 )
    }

    Collapse.prototype.toggle = function() {
        this[ this.$element.hasClass( 'in' ) ? 'hide' : 'show' ]()
    }


    // COLLAPSE PLUGIN DEFINITION
    // ==========================

    var old = $.fn.collapse

    $.fn.collapse = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.collapse' )
            var options = $.extend( {}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option )

            if ( !data && options.toggle && option == 'show' ) option = !option
            if ( !data ) $this.data( 'bs.collapse', ( data = new Collapse( this, options ) ) )
            if ( typeof option == 'string' ) data[ option ]()
        } )
    }

    $.fn.collapse.Constructor = Collapse


    // COLLAPSE NO CONFLICT
    // ====================

    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old
        return this
    }


    // COLLAPSE DATA-API
    // =================

    $( document ).on( 'click.bs.collapse.data-api', '[data-toggle=collapse]', function( e ) {
        var $this = $( this ),
            href
        var target = $this.attr( 'data-target' ) || e.preventDefault() || ( href = $this.attr( 'href' ) ) && href.replace( /.*(?=#[^\s]+$)/, '' ) //strip for ie7
        var $target = $( target )
        var data = $target.data( 'bs.collapse' )
        var option = data ? 'toggle' : $this.data()
        var parent = $this.attr( 'data-parent' )
        var $parent = parent && $( parent )

        if ( !data || !data.transitioning ) {
            if ( $parent ) $parent.find( '[data-toggle=collapse][data-parent="' + parent + '"]' ).not( $this ).addClass( 'collapsed' )
            $this[ $target.hasClass( 'in' ) ? 'addClass' : 'removeClass' ]( 'collapsed' )
        }

        $target.collapse( option )
    } )

}( jQuery );

/* ========================================================================
 * Bootstrap: dropdown.js v3.1.1
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // DROPDOWN CLASS DEFINITION
    // =========================

    var backdrop = '.dropdown-backdrop'
    var toggle = '[data-toggle=dropdown]'
    var Dropdown = function( element ) {
        $( element ).on( 'click.bs.dropdown', this.toggle )
    }

    Dropdown.prototype.toggle = function( e ) {
        var $this = $( this )

        if ( $this.is( '.disabled, :disabled' ) ) return

        var $parent = getParent( $this )
        var isActive = $parent.hasClass( 'open' )

        clearMenus()

        if ( !isActive ) {
            if ( 'ontouchstart' in document.documentElement && !$parent.closest( '.navbar-nav' ).length ) {
                // if mobile we use a backdrop because click events don't delegate
                $( '<div class="dropdown-backdrop"/>' ).insertAfter( $( this ) ).on( 'click', clearMenus )
            }

            var relatedTarget = {
                relatedTarget: this
            }
            $parent.trigger( e = $.Event( 'show.bs.dropdown', relatedTarget ) )

            if ( e.isDefaultPrevented() ) return

            $parent
                .toggleClass( 'open' )
                .trigger( 'shown.bs.dropdown', relatedTarget )

            $this.focus()
        }

        return false
    }

    Dropdown.prototype.keydown = function( e ) {
        if ( !/(38|40|27)/.test( e.keyCode ) ) return

        var $this = $( this )

        e.preventDefault()
        e.stopPropagation()

        if ( $this.is( '.disabled, :disabled' ) ) return

        var $parent = getParent( $this )
        var isActive = $parent.hasClass( 'open' )

        if ( !isActive || ( isActive && e.keyCode == 27 ) ) {
            if ( e.which == 27 ) $parent.find( toggle ).focus()
            return $this.click()
        }

        var desc = ' li:not(.divider):visible a'
        var $items = $parent.find( '[role=menu]' + desc + ', [role=listbox]' + desc )

        if ( !$items.length ) return

        var index = $items.index( $items.filter( ':focus' ) )

        if ( e.keyCode == 38 && index > 0 ) index-- // up
        if ( e.keyCode == 40 && index < $items.length - 1 ) index++ // down
        if ( !~index ) index = 0

        $items.eq( index ).focus()
    }

    function clearMenus( e ) {
        $( backdrop ).remove()
        $( toggle ).each( function() {
            var $parent = getParent( $( this ) )
            var relatedTarget = {
                relatedTarget: this
            }
            if ( !$parent.hasClass( 'open' ) ) return
            $parent.trigger( e = $.Event( 'hide.bs.dropdown', relatedTarget ) )
            if ( e.isDefaultPrevented() ) return
            $parent.removeClass( 'open' ).trigger( 'hidden.bs.dropdown', relatedTarget )
        } )
    }

    function getParent( $this ) {
        var selector = $this.attr( 'data-target' )

        if ( !selector ) {
            selector = $this.attr( 'href' )
            selector = selector && /#[A-Za-z]/.test( selector ) && selector.replace( /.*(?=#[^\s]*$)/, '' ) //strip for ie7
        }

        var $parent = selector && $( selector )

        return $parent && $parent.length ? $parent : $this.parent()
    }


    // DROPDOWN PLUGIN DEFINITION
    // ==========================

    var old = $.fn.dropdown

    $.fn.dropdown = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.dropdown' )

            if ( !data ) $this.data( 'bs.dropdown', ( data = new Dropdown( this ) ) )
            if ( typeof option == 'string' ) data[ option ].call( $this )
        } )
    }

    $.fn.dropdown.Constructor = Dropdown


    // DROPDOWN NO CONFLICT
    // ====================

    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old
        return this
    }


    // APPLY TO STANDARD DROPDOWN ELEMENTS
    // ===================================

    $( document )
        .on( 'click.bs.dropdown.data-api', clearMenus )
        .on( 'click.bs.dropdown.data-api', '.dropdown form', function( e ) {
            e.stopPropagation()
        } )
        .on( 'click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle )
        .on( 'keydown.bs.dropdown.data-api', toggle + ', [role=menu], [role=listbox]', Dropdown.prototype.keydown )

}( jQuery );

/* ========================================================================
 * Bootstrap: modal.js v3.1.1
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // MODAL CLASS DEFINITION
    // ======================

    var Modal = function( element, options ) {
        this.options = options
        this.$element = $( element )
        this.$backdrop =
            this.isShown = null

        if ( this.options.remote ) {
            this.$element
                .find( '.modal-content' )
                .load( this.options.remote, $.proxy( function() {
                    this.$element.trigger( 'loaded.bs.modal' )
                }, this ) )
        }
    }

    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    }

    Modal.prototype.toggle = function( _relatedTarget ) {
        return this[ !this.isShown ? 'show' : 'hide' ]( _relatedTarget )
    }

    Modal.prototype.show = function( _relatedTarget ) {
        var that = this
        var e = $.Event( 'show.bs.modal', {
            relatedTarget: _relatedTarget
        } )

        this.$element.trigger( e )

        if ( this.isShown || e.isDefaultPrevented() ) return

        this.isShown = true

        this.escape()

        this.$element.on( 'click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy( this.hide, this ) )

        this.backdrop( function() {
            var transition = $.support.transition && that.$element.hasClass( 'fade' )

            if ( !that.$element.parent().length ) {
                that.$element.appendTo( document.body ) // don't move modals dom position
            }

            that.$element
                .show()
                .scrollTop( 0 )

            if ( transition ) {
                that.$element[ 0 ].offsetWidth // force reflow
            }

            that.$element
                .addClass( 'in' )
                .attr( 'aria-hidden', false )

            that.enforceFocus()

            var e = $.Event( 'shown.bs.modal', {
                relatedTarget: _relatedTarget
            } )

            transition ?
                that.$element.find( '.modal-dialog' ) // wait for modal to slide in
            .one( $.support.transition.end, function() {
                that.$element.focus().trigger( e )
            } )
                .emulateTransitionEnd( 300 ) :
                that.$element.focus().trigger( e )
        } )
    }

    Modal.prototype.hide = function( e ) {
        if ( e ) e.preventDefault()

        e = $.Event( 'hide.bs.modal' )

        this.$element.trigger( e )

        if ( !this.isShown || e.isDefaultPrevented() ) return

        this.isShown = false

        this.escape()

        $( document ).off( 'focusin.bs.modal' )

        this.$element
            .removeClass( 'in' )
            .attr( 'aria-hidden', true )
            .off( 'click.dismiss.bs.modal' )

        $.support.transition && this.$element.hasClass( 'fade' ) ?
            this.$element
            .one( $.support.transition.end, $.proxy( this.hideModal, this ) )
            .emulateTransitionEnd( 300 ) :
            this.hideModal()
    }

    Modal.prototype.enforceFocus = function() {
        $( document )
            .off( 'focusin.bs.modal' ) // guard against infinite focus loop
        .on( 'focusin.bs.modal', $.proxy( function( e ) {
            if ( this.$element[ 0 ] !== e.target && !this.$element.has( e.target ).length ) {
                this.$element.focus()
            }
        }, this ) )
    }

    Modal.prototype.escape = function() {
        if ( this.isShown && this.options.keyboard ) {
            this.$element.on( 'keyup.dismiss.bs.modal', $.proxy( function( e ) {
                e.which == 27 && this.hide()
            }, this ) )
        } else if ( !this.isShown ) {
            this.$element.off( 'keyup.dismiss.bs.modal' )
        }
    }

    Modal.prototype.hideModal = function() {
        var that = this
        this.$element.hide()
        this.backdrop( function() {
            that.removeBackdrop()
            that.$element.trigger( 'hidden.bs.modal' )
        } )
    }

    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
    }

    Modal.prototype.backdrop = function( callback ) {
        var animate = this.$element.hasClass( 'fade' ) ? 'fade' : ''

        if ( this.isShown && this.options.backdrop ) {
            var doAnimate = $.support.transition && animate

            this.$backdrop = $( '<div class="modal-backdrop ' + animate + '" />' )
                .appendTo( document.body )

            this.$element.on( 'click.dismiss.bs.modal', $.proxy( function( e ) {
                if ( e.target !== e.currentTarget ) return
                this.options.backdrop == 'static' ? this.$element[ 0 ].focus.call( this.$element[ 0 ] ) : this.hide.call( this )
            }, this ) )

            if ( doAnimate ) this.$backdrop[ 0 ].offsetWidth // force reflow

            this.$backdrop.addClass( 'in' )

            if ( !callback ) return

            doAnimate ?
                this.$backdrop
                .one( $.support.transition.end, callback )
                .emulateTransitionEnd( 150 ) :
                callback()

        } else if ( !this.isShown && this.$backdrop ) {
            this.$backdrop.removeClass( 'in' )

            $.support.transition && this.$element.hasClass( 'fade' ) ?
                this.$backdrop
                .one( $.support.transition.end, callback )
                .emulateTransitionEnd( 150 ) :
                callback()

        } else if ( callback ) {
            callback()
        }
    }


    // MODAL PLUGIN DEFINITION
    // =======================

    var old = $.fn.modal

    $.fn.modal = function( option, _relatedTarget ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.modal' )
            var options = $.extend( {}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option )

            if ( !data ) $this.data( 'bs.modal', ( data = new Modal( this, options ) ) )
            if ( typeof option == 'string' ) data[ option ]( _relatedTarget )
            else if ( options.show ) data.show( _relatedTarget )
        } )
    }

    $.fn.modal.Constructor = Modal


    // MODAL NO CONFLICT
    // =================

    $.fn.modal.noConflict = function() {
        $.fn.modal = old
        return this
    }


    // MODAL DATA-API
    // ==============

    $( document ).on( 'click.bs.modal.data-api', '[data-toggle="modal"]', function( e ) {
        var $this = $( this )
        var href = $this.attr( 'href' )
        var $target = $( $this.attr( 'data-target' ) || ( href && href.replace( /.*(?=#[^\s]+$)/, '' ) ) ) //strip for ie7
        var option = $target.data( 'bs.modal' ) ? 'toggle' : $.extend( {
            remote: !/#/.test( href ) && href
        }, $target.data(), $this.data() )

        if ( $this.is( 'a' ) ) e.preventDefault()

        $target
            .modal( option, this )
            .one( 'hide', function() {
                $this.is( ':visible' ) && $this.focus()
            } )
    } )

    $( document )
        .on( 'show.bs.modal', '.modal', function() {
            $( document.body ).addClass( 'modal-open' )
        } )
        .on( 'hidden.bs.modal', '.modal', function() {
            $( document.body ).removeClass( 'modal-open' )
        } )

}( jQuery );

/* ========================================================================
 * Bootstrap: tooltip.js v3.1.1
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // TOOLTIP PUBLIC CLASS DEFINITION
    // ===============================

    var Tooltip = function( element, options ) {
        this.type =
            this.options =
            this.enabled =
            this.timeout =
            this.hoverState =
            this.$element = null

        this.init( 'tooltip', element, options )
    }

    Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false
    }

    Tooltip.prototype.init = function( type, element, options ) {
        this.enabled = true
        this.type = type
        this.$element = $( element )
        this.options = this.getOptions( options )

        var triggers = this.options.trigger.split( ' ' )

        for ( var i = triggers.length; i--; ) {
            var trigger = triggers[ i ]

            if ( trigger == 'click' ) {
                this.$element.on( 'click.' + this.type, this.options.selector, $.proxy( this.toggle, this ) )
            } else if ( trigger != 'manual' ) {
                var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin'
                var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

                this.$element.on( eventIn + '.' + this.type, this.options.selector, $.proxy( this.enter, this ) )
                this.$element.on( eventOut + '.' + this.type, this.options.selector, $.proxy( this.leave, this ) )
            }
        }

        this.options.selector ?
            ( this._options = $.extend( {}, this.options, {
            trigger: 'manual',
            selector: ''
        } ) ) :
            this.fixTitle()
    }

    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS
    }

    Tooltip.prototype.getOptions = function( options ) {
        options = $.extend( {}, this.getDefaults(), this.$element.data(), options )

        if ( options.delay && typeof options.delay == 'number' ) {
            options.delay = {
                show: options.delay,
                hide: options.delay
            }
        }

        return options
    }

    Tooltip.prototype.getDelegateOptions = function() {
        var options = {}
        var defaults = this.getDefaults()

        this._options && $.each( this._options, function( key, value ) {
            if ( defaults[ key ] != value ) options[ key ] = value
        } )

        return options
    }

    Tooltip.prototype.enter = function( obj ) {
        var self = obj instanceof this.constructor ?
            obj : $( obj.currentTarget )[ this.type ]( this.getDelegateOptions() ).data( 'bs.' + this.type )

        clearTimeout( self.timeout )

        self.hoverState = 'in'

        if ( !self.options.delay || !self.options.delay.show ) return self.show()

        self.timeout = setTimeout( function() {
            if ( self.hoverState == 'in' ) self.show()
        }, self.options.delay.show )
    }

    Tooltip.prototype.leave = function( obj ) {
        var self = obj instanceof this.constructor ?
            obj : $( obj.currentTarget )[ this.type ]( this.getDelegateOptions() ).data( 'bs.' + this.type )

        clearTimeout( self.timeout )

        self.hoverState = 'out'

        if ( !self.options.delay || !self.options.delay.hide ) return self.hide()

        self.timeout = setTimeout( function() {
            if ( self.hoverState == 'out' ) self.hide()
        }, self.options.delay.hide )
    }

    Tooltip.prototype.show = function() {
        var e = $.Event( 'show.bs.' + this.type )

        if ( this.hasContent() && this.enabled ) {
            this.$element.trigger( e )

            if ( e.isDefaultPrevented() ) return
            var that = this;

            var $tip = this.tip()

            this.setContent()

            if ( this.options.animation ) $tip.addClass( 'fade' )

            var placement = typeof this.options.placement == 'function' ?
                this.options.placement.call( this, $tip[ 0 ], this.$element[ 0 ] ) :
                this.options.placement

            var autoToken = /\s?auto?\s?/i
            var autoPlace = autoToken.test( placement )
            if ( autoPlace ) placement = placement.replace( autoToken, '' ) || 'top'

            $tip
                .detach()
                .css( {
                    top: 0,
                    left: 0,
                    display: 'block'
                } )
                .addClass( placement )

            this.options.container ? $tip.appendTo( this.options.container ) : $tip.insertAfter( this.$element )

            var pos = this.getPosition()
            var actualWidth = $tip[ 0 ].offsetWidth
            var actualHeight = $tip[ 0 ].offsetHeight

            if ( autoPlace ) {
                var $parent = this.$element.parent()

                var orgPlacement = placement
                var docScroll = document.documentElement.scrollTop || document.body.scrollTop
                var parentWidth = this.options.container == 'body' ? window.innerWidth : $parent.outerWidth()
                var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
                var parentLeft = this.options.container == 'body' ? 0 : $parent.offset().left

                placement = placement == 'bottom' && pos.top + pos.height + actualHeight - docScroll > parentHeight ? 'top' :
                    placement == 'top' && pos.top - docScroll - actualHeight < 0 ? 'bottom' :
                    placement == 'right' && pos.right + actualWidth > parentWidth ? 'left' :
                    placement == 'left' && pos.left - actualWidth < parentLeft ? 'right' :
                    placement

                $tip
                    .removeClass( orgPlacement )
                    .addClass( placement )
            }

            var calculatedOffset = this.getCalculatedOffset( placement, pos, actualWidth, actualHeight )

            this.applyPlacement( calculatedOffset, placement )
            this.hoverState = null

            var complete = function() {
                that.$element.trigger( 'shown.bs.' + that.type )
            }

            $.support.transition && this.$tip.hasClass( 'fade' ) ?
                $tip
                .one( $.support.transition.end, complete )
                .emulateTransitionEnd( 150 ) :
                complete()
        }
    }

    Tooltip.prototype.applyPlacement = function( offset, placement ) {
        var replace
        var $tip = this.tip()
        var width = $tip[ 0 ].offsetWidth
        var height = $tip[ 0 ].offsetHeight

        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt( $tip.css( 'margin-top' ), 10 )
        var marginLeft = parseInt( $tip.css( 'margin-left' ), 10 )

        // we must check for NaN for ie 8/9
        if ( isNaN( marginTop ) ) marginTop = 0
        if ( isNaN( marginLeft ) ) marginLeft = 0

        offset.top = offset.top + marginTop
        offset.left = offset.left + marginLeft

        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset( $tip[ 0 ], $.extend( {
            using: function( props ) {
                $tip.css( {
                    top: Math.round( props.top ),
                    left: Math.round( props.left )
                } )
            }
        }, offset ), 0 )

        $tip.addClass( 'in' )

        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth = $tip[ 0 ].offsetWidth
        var actualHeight = $tip[ 0 ].offsetHeight

        if ( placement == 'top' && actualHeight != height ) {
            replace = true
            offset.top = offset.top + height - actualHeight
        }

        if ( /bottom|top/.test( placement ) ) {
            var delta = 0

            if ( offset.left < 0 ) {
                delta = offset.left * -2
                offset.left = 0

                $tip.offset( offset )

                actualWidth = $tip[ 0 ].offsetWidth
                actualHeight = $tip[ 0 ].offsetHeight
            }

            this.replaceArrow( delta - width + actualWidth, actualWidth, 'left' )
        } else {
            this.replaceArrow( actualHeight - height, actualHeight, 'top' )
        }

        if ( replace ) $tip.offset( offset )
    }

    Tooltip.prototype.replaceArrow = function( delta, dimension, position ) {
        this.arrow().css( position, delta ? ( 50 * ( 1 - delta / dimension ) + '%' ) : '' )
    }

    Tooltip.prototype.setContent = function() {
        var $tip = this.tip()
        var title = this.getTitle()

        $tip.find( '.tooltip-inner' )[ this.options.html ? 'html' : 'text' ]( title )
        $tip.removeClass( 'fade in top bottom left right' )
    }

    Tooltip.prototype.hide = function() {
        var that = this
        var $tip = this.tip()
        var e = $.Event( 'hide.bs.' + this.type )

            function complete() {
                if ( that.hoverState != 'in' ) $tip.detach()
                that.$element.trigger( 'hidden.bs.' + that.type )
            }

        this.$element.trigger( e )

        if ( e.isDefaultPrevented() ) return

        $tip.removeClass( 'in' )

        $.support.transition && this.$tip.hasClass( 'fade' ) ?
            $tip
            .one( $.support.transition.end, complete )
            .emulateTransitionEnd( 150 ) :
            complete()

        this.hoverState = null

        return this
    }

    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element
        if ( $e.attr( 'title' ) || typeof( $e.attr( 'data-original-title' ) ) != 'string' ) {
            $e.attr( 'data-original-title', $e.attr( 'title' ) || '' ).attr( 'title', '' )
        }
    }

    Tooltip.prototype.hasContent = function() {
        return this.getTitle()
    }

    Tooltip.prototype.getPosition = function() {
        var el = this.$element[ 0 ]
        return $.extend( {}, ( typeof el.getBoundingClientRect == 'function' ) ? el.getBoundingClientRect() : {
            width: el.offsetWidth,
            height: el.offsetHeight
        }, this.$element.offset() )
    }

    Tooltip.prototype.getCalculatedOffset = function( placement, pos, actualWidth, actualHeight ) {
        return placement == 'bottom' ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } :
            placement == 'top' ? {
                top: pos.top - actualHeight,
                left: pos.left + pos.width / 2 - actualWidth / 2
        } :
            placement == 'left' ? {
                top: pos.top + pos.height / 2 - actualHeight / 2,
                left: pos.left - actualWidth
        } :
        /* placement == 'right' */
        {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        }
    }

    Tooltip.prototype.getTitle = function() {
        var title
        var $e = this.$element
        var o = this.options

        title = $e.attr( 'data-original-title' ) || ( typeof o.title == 'function' ? o.title.call( $e[ 0 ] ) : o.title )

        return title
    }

    Tooltip.prototype.tip = function() {
        return this.$tip = this.$tip || $( this.options.template )
    }

    Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find( '.tooltip-arrow' )
    }

    Tooltip.prototype.validate = function() {
        if ( !this.$element[ 0 ].parentNode ) {
            this.hide()
            this.$element = null
            this.options = null
        }
    }

    Tooltip.prototype.enable = function() {
        this.enabled = true
    }

    Tooltip.prototype.disable = function() {
        this.enabled = false
    }

    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled
    }

    Tooltip.prototype.toggle = function( e ) {
        var self = e ? $( e.currentTarget )[ this.type ]( this.getDelegateOptions() ).data( 'bs.' + this.type ) : this
        self.tip().hasClass( 'in' ) ? self.leave( self ) : self.enter( self )
    }

    Tooltip.prototype.destroy = function() {
        clearTimeout( this.timeout )
        this.hide().$element.off( '.' + this.type ).removeData( 'bs.' + this.type )
    }


    // TOOLTIP PLUGIN DEFINITION
    // =========================

    var old = $.fn.tooltip

    $.fn.tooltip = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.tooltip' )
            var options = typeof option == 'object' && option

            if ( !data && option == 'destroy' ) return
            if ( !data ) $this.data( 'bs.tooltip', ( data = new Tooltip( this, options ) ) )
            if ( typeof option == 'string' ) data[ option ]()
        } )
    }

    $.fn.tooltip.Constructor = Tooltip


    // TOOLTIP NO CONFLICT
    // ===================

    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old
        return this
    }

}( jQuery );

/* ========================================================================
 * Bootstrap: popover.js v3.1.1
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // POPOVER PUBLIC CLASS DEFINITION
    // ===============================

    var Popover = function( element, options ) {
        this.init( 'popover', element, options )
    }

    if ( !$.fn.tooltip ) throw new Error( 'Popover requires tooltip.js' )

    Popover.DEFAULTS = $.extend( {}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    } )


    // NOTE: POPOVER EXTENDS tooltip.js
    // ================================

    Popover.prototype = $.extend( {}, $.fn.tooltip.Constructor.prototype )

    Popover.prototype.constructor = Popover

    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS
    }

    Popover.prototype.setContent = function() {
        var $tip = this.tip()
        var title = this.getTitle()
        var content = this.getContent()

        $tip.find( '.popover-title' )[ this.options.html ? 'html' : 'text' ]( title )
        $tip.find( '.popover-content' )[ // we use append for html objects to maintain js events
            this.options.html ? ( typeof content == 'string' ? 'html' : 'append' ) : 'text'
        ]( content )

        $tip.removeClass( 'fade top bottom left right in' )

        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if ( !$tip.find( '.popover-title' ).html() ) $tip.find( '.popover-title' ).hide()
    }

    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent()
    }

    Popover.prototype.getContent = function() {
        var $e = this.$element
        var o = this.options

        return $e.attr( 'data-content' ) || ( typeof o.content == 'function' ?
            o.content.call( $e[ 0 ] ) :
            o.content )
    }

    Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find( '.arrow' )
    }

    Popover.prototype.tip = function() {
        if ( !this.$tip ) this.$tip = $( this.options.template )
        return this.$tip
    }


    // POPOVER PLUGIN DEFINITION
    // =========================

    var old = $.fn.popover

    $.fn.popover = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.popover' )
            var options = typeof option == 'object' && option

            if ( !data && option == 'destroy' ) return
            if ( !data ) $this.data( 'bs.popover', ( data = new Popover( this, options ) ) )
            if ( typeof option == 'string' ) data[ option ]()
        } )
    }

    $.fn.popover.Constructor = Popover


    // POPOVER NO CONFLICT
    // ===================

    $.fn.popover.noConflict = function() {
        $.fn.popover = old
        return this
    }

}( jQuery );

/* ========================================================================
 * Bootstrap: scrollspy.js v3.1.1
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // SCROLLSPY CLASS DEFINITION
    // ==========================

    function ScrollSpy( element, options ) {
        var href
        var process = $.proxy( this.process, this )

        this.$element = $( element ).is( 'body' ) ? $( window ) : $( element )
        this.$body = $( 'body' )
        this.$scrollElement = this.$element.on( 'scroll.bs.scroll-spy.data-api', process )
        this.options = $.extend( {}, ScrollSpy.DEFAULTS, options )
        this.selector = ( this.options.target || ( ( href = $( element ).attr( 'href' ) ) && href.replace( /.*(?=#[^\s]+$)/, '' ) ) //strip for ie7
            || '' ) + ' .nav li > a'
        this.offsets = $( [] )
        this.targets = $( [] )
        this.activeTarget = null

        this.refresh()
        this.process()
    }

    ScrollSpy.DEFAULTS = {
        offset: 10
    }

    ScrollSpy.prototype.refresh = function() {
        var offsetMethod = this.$element[ 0 ] == window ? 'offset' : 'position'

        this.offsets = $( [] )
        this.targets = $( [] )

        var self = this
        var $targets = this.$body
            .find( this.selector )
            .map( function() {
                var $el = $( this )
                var href = $el.data( 'target' ) || $el.attr( 'href' )
                var $href = /^#./.test( href ) && $( href )

                return ( $href && $href.length && $href.is( ':visible' ) && [
                    [ $href[ offsetMethod ]().top + ( !$.isWindow( self.$scrollElement.get( 0 ) ) && self.$scrollElement.scrollTop() ), href ]
                ] ) || null
            } )
            .sort( function( a, b ) {
                return a[ 0 ] - b[ 0 ]
            } )
            .each( function() {
                self.offsets.push( this[ 0 ] )
                self.targets.push( this[ 1 ] )
            } )
    }

    ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
        var scrollHeight = this.$scrollElement[ 0 ].scrollHeight || this.$body[ 0 ].scrollHeight
        var maxScroll = scrollHeight - this.$scrollElement.height()
        var offsets = this.offsets
        var targets = this.targets
        var activeTarget = this.activeTarget
        var i

        if ( scrollTop >= maxScroll ) {
            return activeTarget != ( i = targets.last()[ 0 ] ) && this.activate( i )
        }

        if ( activeTarget && scrollTop <= offsets[ 0 ] ) {
            return activeTarget != ( i = targets[ 0 ] ) && this.activate( i )
        }

        for ( i = offsets.length; i--; ) {
            activeTarget != targets[ i ] && scrollTop >= offsets[ i ] && ( !offsets[ i + 1 ] || scrollTop <= offsets[ i + 1 ] ) && this.activate( targets[ i ] )
        }
    }

    ScrollSpy.prototype.activate = function( target ) {
        this.activeTarget = target

        $( this.selector )
            .parentsUntil( this.options.target, '.active' )
            .removeClass( 'active' )

        var selector = this.selector +
            '[data-target="' + target + '"],' +
            this.selector + '[href="' + target + '"]'

        var active = $( selector )
            .parents( 'li' )
            .addClass( 'active' )

        if ( active.parent( '.dropdown-menu' ).length ) {
            active = active
                .closest( 'li.dropdown' )
                .addClass( 'active' )
        }

        active.trigger( 'activate.bs.scrollspy' )
    }


    // SCROLLSPY PLUGIN DEFINITION
    // ===========================

    var old = $.fn.scrollspy

    $.fn.scrollspy = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.scrollspy' )
            var options = typeof option == 'object' && option

            if ( !data ) $this.data( 'bs.scrollspy', ( data = new ScrollSpy( this, options ) ) )
            if ( typeof option == 'string' ) data[ option ]()
        } )
    }

    $.fn.scrollspy.Constructor = ScrollSpy


    // SCROLLSPY NO CONFLICT
    // =====================

    $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old
        return this
    }


    // SCROLLSPY DATA-API
    // ==================

    $( window ).on( 'load', function() {
        $( '[data-spy="scroll"]' ).each( function() {
            var $spy = $( this )
            $spy.scrollspy( $spy.data() )
        } )
    } )

}( jQuery );

/* ========================================================================
 * Bootstrap: tab.js v3.1.1
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // TAB CLASS DEFINITION
    // ====================

    var Tab = function( element ) {
        this.element = $( element )
    }

    Tab.prototype.show = function() {
        var $this = this.element
        var $ul = $this.closest( 'ul:not(.dropdown-menu)' )
        var selector = $this.data( 'target' )

        if ( !selector ) {
            selector = $this.attr( 'href' )
            selector = selector && selector.replace( /.*(?=#[^\s]*$)/, '' ) //strip for ie7
        }

        if ( $this.parent( 'li' ).hasClass( 'active' ) ) return

        var previous = $ul.find( '.active:last a' )[ 0 ]
        var e = $.Event( 'show.bs.tab', {
            relatedTarget: previous
        } )

        $this.trigger( e )

        if ( e.isDefaultPrevented() ) return

        var $target = $( selector )

        this.activate( $this.parent( 'li' ), $ul )
        this.activate( $target, $target.parent(), function() {
            $this.trigger( {
                type: 'shown.bs.tab',
                relatedTarget: previous
            } )
        } )
    }

    Tab.prototype.activate = function( element, container, callback ) {
        var $active = container.find( '> .active' )
        var transition = callback && $.support.transition && $active.hasClass( 'fade' )

            function next() {
                $active
                    .removeClass( 'active' )
                    .find( '> .dropdown-menu > .active' )
                    .removeClass( 'active' )

                element.addClass( 'active' )

                if ( transition ) {
                    element[ 0 ].offsetWidth // reflow for transition
                    element.addClass( 'in' )
                } else {
                    element.removeClass( 'fade' )
                }

                if ( element.parent( '.dropdown-menu' ) ) {
                    element.closest( 'li.dropdown' ).addClass( 'active' )
                }

                callback && callback()
            }

        transition ?
            $active
            .one( $.support.transition.end, next )
            .emulateTransitionEnd( 150 ) :
            next()

        $active.removeClass( 'in' )
    }


    // TAB PLUGIN DEFINITION
    // =====================

    var old = $.fn.tab

    $.fn.tab = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.tab' )

            if ( !data ) $this.data( 'bs.tab', ( data = new Tab( this ) ) )
            if ( typeof option == 'string' ) data[ option ]()
        } )
    }

    $.fn.tab.Constructor = Tab


    // TAB NO CONFLICT
    // ===============

    $.fn.tab.noConflict = function() {
        $.fn.tab = old
        return this
    }


    // TAB DATA-API
    // ============

    $( document ).on( 'click.bs.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function( e ) {
        e.preventDefault()
        $( this ).tab( 'show' )
    } )

}( jQuery );

/* ========================================================================
 * Bootstrap: affix.js v3.1.1
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+ function( $ ) {
    

    // AFFIX CLASS DEFINITION
    // ======================

    var Affix = function( element, options ) {
        this.options = $.extend( {}, Affix.DEFAULTS, options )
        this.$window = $( window )
            .on( 'scroll.bs.affix.data-api', $.proxy( this.checkPosition, this ) )
            .on( 'click.bs.affix.data-api', $.proxy( this.checkPositionWithEventLoop, this ) )

        this.$element = $( element )
        this.affixed =
            this.unpin =
            this.pinnedOffset = null

        this.checkPosition()
    }

    Affix.RESET = 'affix affix-top affix-bottom'

    Affix.DEFAULTS = {
        offset: 0
    }

    Affix.prototype.getPinnedOffset = function() {
        if ( this.pinnedOffset ) return this.pinnedOffset
        this.$element.removeClass( Affix.RESET ).addClass( 'affix' )
        var scrollTop = this.$window.scrollTop()
        var position = this.$element.offset()
        return ( this.pinnedOffset = position.top - scrollTop )
    }

    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout( $.proxy( this.checkPosition, this ), 1 )
    }

    Affix.prototype.checkPosition = function() {
        if ( !this.$element.is( ':visible' ) ) return

        var scrollHeight = $( document ).height()
        var scrollTop = this.$window.scrollTop()
        var position = this.$element.offset()
        var offset = this.options.offset
        var offsetTop = offset.top
        var offsetBottom = offset.bottom

        if ( this.affixed == 'top' ) position.top += scrollTop

        if ( typeof offset != 'object' ) offsetBottom = offsetTop = offset
        if ( typeof offsetTop == 'function' ) offsetTop = offset.top( this.$element )
        if ( typeof offsetBottom == 'function' ) offsetBottom = offset.bottom( this.$element )

        var affix = this.unpin != null && ( scrollTop + this.unpin <= position.top ) ? false :
            offsetBottom != null && ( position.top + this.$element.height() >= scrollHeight - offsetBottom ) ? 'bottom' :
            offsetTop != null && ( scrollTop <= offsetTop ) ? 'top' : false

        if ( this.affixed === affix ) return
        if ( this.unpin ) this.$element.css( 'top', '' )

        var affixType = 'affix' + ( affix ? '-' + affix : '' )
        var e = $.Event( affixType + '.bs.affix' )

        this.$element.trigger( e )

        if ( e.isDefaultPrevented() ) return

        this.affixed = affix
        this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

        this.$element
            .removeClass( Affix.RESET )
            .addClass( affixType )
            .trigger( $.Event( affixType.replace( 'affix', 'affixed' ) ) )

        if ( affix == 'bottom' ) {
            this.$element.offset( {
                top: scrollHeight - offsetBottom - this.$element.height()
            } )
        }
    }


    // AFFIX PLUGIN DEFINITION
    // =======================

    var old = $.fn.affix

    $.fn.affix = function( option ) {
        return this.each( function() {
            var $this = $( this )
            var data = $this.data( 'bs.affix' )
            var options = typeof option == 'object' && option

            if ( !data ) $this.data( 'bs.affix', ( data = new Affix( this, options ) ) )
            if ( typeof option == 'string' ) data[ option ]()
        } )
    }

    $.fn.affix.Constructor = Affix


    // AFFIX NO CONFLICT
    // =================

    $.fn.affix.noConflict = function() {
        $.fn.affix = old
        return this
    }


    // AFFIX DATA-API
    // ==============

    $( window ).on( 'load', function() {
        $( '[data-spy="affix"]' ).each( function() {
            var $spy = $( this )
            var data = $spy.data()

            data.offset = data.offset || {}

            if ( data.offsetBottom ) data.offset.bottom = data.offsetBottom
            if ( data.offsetTop ) data.offset.top = data.offsetTop

            $spy.affix( data )
        } )
    } )

}( jQuery );

define("bootstrap", ["jquery"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.jQuery.fn.popover;
    };
}(this)));

/*
* @fileOverview TouchSwipe - jQuery Plugin
* @version 1.6.5
*
* @author Matt Bryson http://www.github.com/mattbryson
* @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
* @see http://labs.skinkers.com/touchSwipe/
* @see http://plugins.jquery.com/project/touchSwipe
*
* Copyright (c) 2010 Matt Bryson
* Dual licensed under the MIT or GPL Version 2 licenses.
*
*
* Changelog
* $Date: 2010-12-12 (Wed, 12 Dec 2010) $
* $version: 1.0.0
* $version: 1.0.1 - removed multibyte comments
*
* $Date: 2011-21-02 (Mon, 21 Feb 2011) $
* $version: 1.1.0 	- added allowPageScroll property to allow swiping and scrolling of page
*					- changed handler signatures so one handler can be used for multiple events
* $Date: 2011-23-02 (Wed, 23 Feb 2011) $
* $version: 1.2.0 	- added click handler. This is fired if the user simply clicks and does not swipe. The event object and click target are passed to handler.
*					- If you use the http://code.google.com/p/jquery-ui-for-ipad-and-iphone/ plugin, you can also assign jQuery mouse events to children of a touchSwipe object.
* $version: 1.2.1 	- removed console log!
*
* $version: 1.2.2 	- Fixed bug where scope was not preserved in callback methods.
*
* $Date: 2011-28-04 (Thurs, 28 April 2011) $
* $version: 1.2.4 	- Changed licence terms to be MIT or GPL inline with jQuery. Added check for support of touch events to stop non compatible browsers erroring.
*
* $Date: 2011-27-09 (Tues, 27 September 2011) $
* $version: 1.2.5 	- Added support for testing swipes with mouse on desktop browser (thanks to https://github.com/joelhy)
*
* $Date: 2012-14-05 (Mon, 14 May 2012) $
* $version: 1.2.6 	- Added timeThreshold between start and end touch, so user can ignore slow swipes (thanks to Mark Chase). Default is null, all swipes are detected
*
* $Date: 2012-05-06 (Tues, 05 June 2012) $
* $version: 1.2.7 	- Changed time threshold to have null default for backwards compatibility. Added duration param passed back in events, and refactored how time is handled.
*
* $Date: 2012-05-06 (Tues, 05 June 2012) $
* $version: 1.2.8 	- Added the possibility to return a value like null or false in the trigger callback. In that way we can control when the touch start/move should take effect or not (simply by returning in some cases return null; or return false;) This effects the ontouchstart/ontouchmove event.
*
* $Date: 2012-06-06 (Wed, 06 June 2012) $
* $version: 1.3.0 	- Refactored whole plugin to allow for methods to be executed, as well as exposed defaults for user override. Added 'enable', 'disable', and 'destroy' methods
*
* $Date: 2012-05-06 (Fri, 05 June 2012) $
* $version: 1.3.1 	- Bug fixes  - bind() with false as last argument is no longer supported in jQuery 1.6, also, if you just click, the duration is now returned correctly.
*
* $Date: 2012-29-07 (Sun, 29 July 2012) $
* $version: 1.3.2	- Added fallbackToMouseEvents option to NOT capture mouse events on non touch devices.
* 			- Added "all" fingers value to the fingers property, so any combination of fingers triggers the swipe, allowing event handlers to check the finger count
*
* $Date: 2012-09-08 (Thurs, 9 Aug 2012) $
* $version: 1.3.3	- Code tidy prep for minefied version
*
* $Date: 2012-04-10 (wed, 4 Oct 2012) $
* $version: 1.4.0	- Added pinch support, pinchIn and pinchOut
*
* $Date: 2012-11-10 (Thurs, 11 Oct 2012) $
* $version: 1.5.0	- Added excludedElements, a jquery selector that specifies child elements that do NOT trigger swipes. By default, this is one select that removes all form, input select, button and anchor elements.
*
* $Date: 2012-22-10 (Mon, 22 Oct 2012) $
* $version: 1.5.1	- Fixed bug with jQuery 1.8 and trailing comma in excludedElements
*					- Fixed bug with IE and eventPreventDefault()
* $Date: 2013-01-12 (Fri, 12 Jan 2013) $
* $version: 1.6.0	- Fixed bugs with pinching, mainly when both pinch and swipe enabled, as well as adding time threshold for multifinger gestures, so releasing one finger beofre the other doesnt trigger as single finger gesture.
*					- made the demo site all static local HTML pages so they can be run locally by a developer
*					- added jsDoc comments and added documentation for the plugin	
*					- code tidy
*					- added triggerOnTouchLeave property that will end the event when the user swipes off the element.
* $Date: 2013-03-23 (Sat, 23 Mar 2013) $
* $version: 1.6.1	- Added support for ie8 touch events
* $version: 1.6.2	- Added support for events binding with on / off / bind in jQ for all callback names.
*                   - Deprecated the 'click' handler in favour of tap.
*                   - added cancelThreshold property
*                   - added option method to update init options at runtime
*
* $version 1.6.3    - added doubletap, longtap events and longTapThreshold, doubleTapThreshold property
* $Date: 2013-04-04 (Thurs, 04 April 2013) $
* $version 1.6.4    - Fixed bug with cancelThreshold introduced in 1.6.3, where swipe status no longer fired start event, and stopped once swiping back.
*
* $Date: 2013-08-24 (Sat, 24 Aug 2013) $
* $version 1.6.5    - Merged a few pull requests fixing various bugs, added AMD support.

*/

/**
 * See (http://jquery.com/).
 * @name $
 * @class 
 * See the jQuery Library  (http://jquery.com/) for full details.  This just
 * documents the function and classes that are added to jQuery by this plug-in.
 */
 
/**
 * See (http://jquery.com/)
 * @name fn
 * @class 
 * See the jQuery Library  (http://jquery.com/) for full details.  This just
 * documents the function and classes that are added to jQuery by this plug-in.
 * @memberOf $
 */



(function (factory) {
    if (typeof define === 'function' && define.amd && define.amd.jQuery) {
        // AMD. Register as anonymous module.
        define('jquery.touchswipe',['jquery'], factory);
    } else {
        // Browser globals.
        factory(jQuery);
    }
}(function ($) {
	

	//Constants
	var LEFT = "left",
		RIGHT = "right",
		UP = "up",
		DOWN = "down",
		IN = "in",
		OUT = "out",

		NONE = "none",
		AUTO = "auto",
		
		SWIPE = "swipe",
		PINCH = "pinch",
		TAP = "tap",
		DOUBLE_TAP = "doubletap",
		LONG_TAP = "longtap",
		
		HORIZONTAL = "horizontal",
		VERTICAL = "vertical",

		ALL_FINGERS = "all",
		
		DOUBLE_TAP_THRESHOLD = 10,

		PHASE_START = "start",
		PHASE_MOVE = "move",
		PHASE_END = "end",
		PHASE_CANCEL = "cancel",

		SUPPORTS_TOUCH = 'ontouchstart' in window,

		PLUGIN_NS = 'TouchSwipe';



	/**
	* The default configuration, and available options to configure touch swipe with.
	* You can set the default values by updating any of the properties prior to instantiation.
	* @name $.fn.swipe.defaults
	* @namespace
	* @property {int} [fingers=1] The number of fingers to detect in a swipe. Any swipes that do not meet this requirement will NOT trigger swipe handlers.
	* @property {int} [threshold=75] The number of pixels that the user must move their finger by before it is considered a swipe. 
	* @property {int} [cancelThreshold=null] The number of pixels that the user must move their finger back from the original swipe direction to cancel the gesture.
	* @property {int} [pinchThreshold=20] The number of pixels that the user must pinch their finger by before it is considered a pinch. 
	* @property {int} [maxTimeThreshold=null] Time, in milliseconds, between touchStart and touchEnd must NOT exceed in order to be considered a swipe. 
	* @property {int} [fingerReleaseThreshold=250] Time in milliseconds between releasing multiple fingers.  If 2 fingers are down, and are released one after the other, if they are within this threshold, it counts as a simultaneous release. 
	* @property {int} [longTapThreshold=500] Time in milliseconds between tap and release for a long tap
    * @property {int} [doubleTapThreshold=200] Time in milliseconds between 2 taps to count as a double tap
	* @property {function} [swipe=null] A handler to catch all swipes. See {@link $.fn.swipe#event:swipe}
	* @property {function} [swipeLeft=null] A handler that is triggered for "left" swipes. See {@link $.fn.swipe#event:swipeLeft}
	* @property {function} [swipeRight=null] A handler that is triggered for "right" swipes. See {@link $.fn.swipe#event:swipeRight}
	* @property {function} [swipeUp=null] A handler that is triggered for "up" swipes. See {@link $.fn.swipe#event:swipeUp}
	* @property {function} [swipeDown=null] A handler that is triggered for "down" swipes. See {@link $.fn.swipe#event:swipeDown}
	* @property {function} [swipeStatus=null] A handler triggered for every phase of the swipe. See {@link $.fn.swipe#event:swipeStatus}
	* @property {function} [pinchIn=null] A handler triggered for pinch in events. See {@link $.fn.swipe#event:pinchIn}
	* @property {function} [pinchOut=null] A handler triggered for pinch out events. See {@link $.fn.swipe#event:pinchOut}
	* @property {function} [pinchStatus=null] A handler triggered for every phase of a pinch. See {@link $.fn.swipe#event:pinchStatus}
	* @property {function} [tap=null] A handler triggered when a user just taps on the item, rather than swipes it. If they do not move, tap is triggered, if they do move, it is not. 
	* @property {function} [doubleTap=null] A handler triggered when a user double taps on the item. The delay between taps can be set with the doubleTapThreshold property. See {@link $.fn.swipe.defaults#doubleTapThreshold}
	* @property {function} [longTap=null] A handler triggered when a user long taps on the item. The delay between start and end can be set with the longTapThreshold property. See {@link $.fn.swipe.defaults#doubleTapThreshold}
	* @property {boolean} [triggerOnTouchEnd=true] If true, the swipe events are triggered when the touch end event is received (user releases finger).  If false, it will be triggered on reaching the threshold, and then cancel the touch event automatically. 
	* @property {boolean} [triggerOnTouchLeave=false] If true, then when the user leaves the swipe object, the swipe will end and trigger appropriate handlers. 
	* @property {string|undefined} [allowPageScroll='auto'] How the browser handles page scrolls when the user is swiping on a touchSwipe object. See {@link $.fn.swipe.pageScroll}.  <br/><br/>
										<code>"auto"</code> : all undefined swipes will cause the page to scroll in that direction. <br/>
										<code>"none"</code> : the page will not scroll when user swipes. <br/>
										<code>"horizontal"</code> : will force page to scroll on horizontal swipes. <br/>
										<code>"vertical"</code> : will force page to scroll on vertical swipes. <br/>
	* @property {boolean} [fallbackToMouseEvents=true] If true mouse events are used when run on a non touch device, false will stop swipes being triggered by mouse events on non tocuh devices. 
	* @property {string} [excludedElements="button, input, select, textarea, a, .noSwipe"] A jquery selector that specifies child elements that do NOT trigger swipes. By default this excludes all form, input, select, button, anchor and .noSwipe elements. 
	
	*/
	var defaults = {
		fingers: 1, 		
		threshold: 75, 	
		cancelThreshold:null,	
		pinchThreshold:20,
		maxTimeThreshold: null, 
		fingerReleaseThreshold:250, 
		longTapThreshold:500,
		doubleTapThreshold:200,
		swipe: null, 		
		swipeLeft: null, 	
		swipeRight: null, 	
		swipeUp: null, 		
		swipeDown: null, 	
		swipeStatus: null, 	
		pinchIn:null,		
		pinchOut:null,		
		pinchStatus:null,	
		click:null, //Deprecated since 1.6.2
		tap:null,
		doubleTap:null,
		longTap:null, 		
		triggerOnTouchEnd: true, 
		triggerOnTouchLeave:false, 
		allowPageScroll: "auto", 
		fallbackToMouseEvents: true,	
		excludedElements:"label, button, input, select, textarea, a, .noSwipe"
	};



	/**
	* Applies TouchSwipe behaviour to one or more jQuery objects.
	* The TouchSwipe plugin can be instantiated via this method, or methods within 
	* TouchSwipe can be executed via this method as per jQuery plugin architecture.
	* @see TouchSwipe
	* @class
	* @param {Mixed} method If the current DOMNode is a TouchSwipe object, and <code>method</code> is a TouchSwipe method, then
	* the <code>method</code> is executed, and any following arguments are passed to the TouchSwipe method.
	* If <code>method</code> is an object, then the TouchSwipe class is instantiated on the current DOMNode, passing the 
	* configuration properties defined in the object. See TouchSwipe
	*
	*/
	$.fn.swipe = function (method) {
		var $this = $(this),
			plugin = $this.data(PLUGIN_NS);

		//Check if we are already instantiated and trying to execute a method	
		if (plugin && typeof method === 'string') {
			if (plugin[method]) {
				return plugin[method].apply(this, Array.prototype.slice.call(arguments, 1));
			} else {
				$.error('Method ' + method + ' does not exist on jQuery.swipe');
			}
		}
		//Else not instantiated and trying to pass init object (or nothing)
		else if (!plugin && (typeof method === 'object' || !method)) {
			return init.apply(this, arguments);
		}

		return $this;
	};

	//Expose our defaults so a user could override the plugin defaults
	$.fn.swipe.defaults = defaults;

	/**
	* The phases that a touch event goes through.  The <code>phase</code> is passed to the event handlers. 
	* These properties are read only, attempting to change them will not alter the values passed to the event handlers.
	* @namespace
	* @readonly
	* @property {string} PHASE_START Constant indicating the start phase of the touch event. Value is <code>"start"</code>.
	* @property {string} PHASE_MOVE Constant indicating the move phase of the touch event. Value is <code>"move"</code>.
	* @property {string} PHASE_END Constant indicating the end phase of the touch event. Value is <code>"end"</code>.
	* @property {string} PHASE_CANCEL Constant indicating the cancel phase of the touch event. Value is <code>"cancel"</code>.
	*/
	$.fn.swipe.phases = {
		PHASE_START: PHASE_START,
		PHASE_MOVE: PHASE_MOVE,
		PHASE_END: PHASE_END,
		PHASE_CANCEL: PHASE_CANCEL
	};

	/**
	* The direction constants that are passed to the event handlers. 
	* These properties are read only, attempting to change them will not alter the values passed to the event handlers.
	* @namespace
	* @readonly
	* @property {string} LEFT Constant indicating the left direction. Value is <code>"left"</code>.
	* @property {string} RIGHT Constant indicating the right direction. Value is <code>"right"</code>.
	* @property {string} UP Constant indicating the up direction. Value is <code>"up"</code>.
	* @property {string} DOWN Constant indicating the down direction. Value is <code>"cancel"</code>.
	* @property {string} IN Constant indicating the in direction. Value is <code>"in"</code>.
	* @property {string} OUT Constant indicating the out direction. Value is <code>"out"</code>.
	*/
	$.fn.swipe.directions = {
		LEFT: LEFT,
		RIGHT: RIGHT,
		UP: UP,
		DOWN: DOWN,
		IN : IN,
		OUT: OUT
	};
	
	/**
	* The page scroll constants that can be used to set the value of <code>allowPageScroll</code> option
	* These properties are read only
	* @namespace
	* @readonly
	* @see $.fn.swipe.defaults#allowPageScroll
	* @property {string} NONE Constant indicating no page scrolling is allowed. Value is <code>"none"</code>.
	* @property {string} HORIZONTAL Constant indicating horizontal page scrolling is allowed. Value is <code>"horizontal"</code>.
	* @property {string} VERTICAL Constant indicating vertical page scrolling is allowed. Value is <code>"vertical"</code>.
	* @property {string} AUTO Constant indicating either horizontal or vertical will be allowed, depending on the swipe handlers registered. Value is <code>"auto"</code>.
	*/
	$.fn.swipe.pageScroll = {
		NONE: NONE,
		HORIZONTAL: HORIZONTAL,
		VERTICAL: VERTICAL,
		AUTO: AUTO
	};

	/**
	* Constants representing the number of fingers used in a swipe.  These are used to set both the value of <code>fingers</code> in the 
	* options object, as well as the value of the <code>fingers</code> event property.
	* These properties are read only, attempting to change them will not alter the values passed to the event handlers.
	* @namespace
	* @readonly
	* @see $.fn.swipe.defaults#fingers
	* @property {string} ONE Constant indicating 1 finger is to be detected / was detected. Value is <code>1</code>.
	* @property {string} TWO Constant indicating 2 fingers are to be detected / were detected. Value is <code>1</code>.
	* @property {string} THREE Constant indicating 3 finger are to be detected / were detected. Value is <code>1</code>.
	* @property {string} ALL Constant indicating any combination of finger are to be detected.  Value is <code>"all"</code>.
	*/
	$.fn.swipe.fingers = {
		ONE: 1,
		TWO: 2,
		THREE: 3,
		ALL: ALL_FINGERS
	};

	/**
	* Initialise the plugin for each DOM element matched
	* This creates a new instance of the main TouchSwipe class for each DOM element, and then
	* saves a reference to that instance in the elements data property.
	* @internal
	*/
	function init(options) {
		//Prep and extend the options
		if (options && (options.allowPageScroll === undefined && (options.swipe !== undefined || options.swipeStatus !== undefined))) {
			options.allowPageScroll = NONE;
		}
		
        //Check for deprecated options
		//Ensure that any old click handlers are assigned to the new tap, unless we have a tap
		if(options.click!==undefined && options.tap===undefined) {
		    options.tap = options.click;
		}

		if (!options) {
			options = {};
		}
		
        //pass empty object so we dont modify the defaults
		options = $.extend({}, $.fn.swipe.defaults, options);

		//For each element instantiate the plugin
		return this.each(function () {
			var $this = $(this);

			//Check we havent already initialised the plugin
			var plugin = $this.data(PLUGIN_NS);

			if (!plugin) {
				plugin = new TouchSwipe(this, options);
				$this.data(PLUGIN_NS, plugin);
			}
		});
	}

	/**
	* Main TouchSwipe Plugin Class.
	* Do not use this to construct your TouchSwipe object, use the jQuery plugin method $.fn.swipe(); {@link $.fn.swipe}
	* @private
	* @name TouchSwipe
	* @param {DOMNode} element The HTML DOM object to apply to plugin to
	* @param {Object} options The options to configure the plugin with.  @link {$.fn.swipe.defaults}
	* @see $.fh.swipe.defaults
	* @see $.fh.swipe
    * @class
	*/
	function TouchSwipe(element, options) {
		var useTouchEvents = (SUPPORTS_TOUCH || !options.fallbackToMouseEvents),
			START_EV = useTouchEvents ? 'touchstart' : 'mousedown',
			MOVE_EV = useTouchEvents ? 'touchmove' : 'mousemove',
			END_EV = useTouchEvents ? 'touchend' : 'mouseup',
			LEAVE_EV = useTouchEvents ? null : 'mouseleave', //we manually detect leave on touch devices, so null event here
			CANCEL_EV = 'touchcancel';



		//touch properties
		var distance = 0,
			direction = null,
			duration = 0,
			startTouchesDistance = 0,
			endTouchesDistance = 0,
			pinchZoom = 1,
			pinchDistance = 0,
			pinchDirection = 0,
			maximumsMap=null;

		
		
		//jQuery wrapped element for this instance
		var $element = $(element);
		
		//Current phase of th touch cycle
		var phase = "start";

		// the current number of fingers being used.
		var fingerCount = 0; 			

		//track mouse points / delta
		var fingerData=null;

		//track times
		var startTime = 0,
			endTime = 0,
			previousTouchEndTime=0,
			previousTouchFingerCount=0,
			doubleTapStartTime=0;

        //Timeouts
        var singleTapTimeout=null;
        
		// Add gestures to all swipable areas if supported
		try {
			$element.bind(START_EV, touchStart);
			$element.bind(CANCEL_EV, touchCancel);
		}
		catch (e) {
			$.error('events not supported ' + START_EV + ',' + CANCEL_EV + ' on jQuery.swipe');
		}

		//
		//Public methods
		//
		
		/**
		* re-enables the swipe plugin with the previous configuration
		* @function
		* @name $.fn.swipe#enable
		* @return {DOMNode} The Dom element that was registered with TouchSwipe 
		* @example $("#element").swipe("enable");
		*/
		this.enable = function () {
			$element.bind(START_EV, touchStart);
			$element.bind(CANCEL_EV, touchCancel);
			return $element;
		};

		/**
		* disables the swipe plugin
		* @function
		* @name $.fn.swipe#disable
		* @return {DOMNode} The Dom element that is now registered with TouchSwipe
	    * @example $("#element").swipe("disable");
		*/
		this.disable = function () {
			removeListeners();
			return $element;
		};

		/**
		* Destroy the swipe plugin completely. To use any swipe methods, you must re initialise the plugin.
		* @function
		* @name $.fn.swipe#destroy
		* @return {DOMNode} The Dom element that was registered with TouchSwipe 
		* @example $("#element").swipe("destroy");
		*/
		this.destroy = function () {
			removeListeners();
			$element.data(PLUGIN_NS, null);
			return $element;
		};


        /**
         * Allows run time updating of the swipe configuration options.
         * @function
    	 * @name $.fn.swipe#option
    	 * @param {String} property The option property to get or set
         * @param {Object} [value] The value to set the property to
		 * @return {Object} If only a property name is passed, then that property value is returned.
		 * @example $("#element").swipe("option", "threshold"); // return the threshold
         * @example $("#element").swipe("option", "threshold", 100); // set the threshold after init
         * @see $.fn.swipe.defaults
         *
         */
        this.option = function (property, value) {
            if(options[property]!==undefined) {
                if(value===undefined) {
                    return options[property];
                } else {
                    options[property] = value;
                }
            } else {
                $.error('Option ' + property + ' does not exist on jQuery.swipe.options');
            }

            return null;
        }

		//
		// Private methods
		//
		
		//
		// EVENTS
		//
		/**
		* Event handler for a touch start event.
		* Stops the default click event from triggering and stores where we touched
		* @inner
		* @param {object} jqEvent The normalised jQuery event object.
		*/
		function touchStart(jqEvent) {
			//If we already in a touch event (a finger already in use) then ignore subsequent ones..
			if( getTouchInProgress() )
				return;
			
			//Check if this element matches any in the excluded elements selectors,  or its parent is excluded, if so, DON'T swipe
			if( $(jqEvent.target).closest( options.excludedElements, $element ).length>0 ) 
				return;
				
			//As we use Jquery bind for events, we need to target the original event object
			//If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
			var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
			
			var ret,
				evt = SUPPORTS_TOUCH ? event.touches[0] : event;

			phase = PHASE_START;

			//If we support touches, get the finger count
			if (SUPPORTS_TOUCH) {
				// get the total number of fingers touching the screen
				fingerCount = event.touches.length;
			}
			//Else this is the desktop, so stop the browser from dragging the image
			else {
				jqEvent.preventDefault(); //call this on jq event so we are cross browser
			}

			//clear vars..
			distance = 0;
			direction = null;
			pinchDirection=null;
			duration = 0;
			startTouchesDistance=0;
			endTouchesDistance=0;
			pinchZoom = 1;
			pinchDistance = 0;
			fingerData=createAllFingerData();
			maximumsMap=createMaximumsData();
			cancelMultiFingerRelease();

			
			// check the number of fingers is what we are looking for, or we are capturing pinches
			if (!SUPPORTS_TOUCH || (fingerCount === options.fingers || options.fingers === ALL_FINGERS) || hasPinches()) {
				// get the coordinates of the touch
				createFingerData( 0, evt );
				startTime = getTimeStamp();
				
				if(fingerCount==2) {
					//Keep track of the initial pinch distance, so we can calculate the diff later
					//Store second finger data as start
					createFingerData( 1, event.touches[1] );
					startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
				}
				
				if (options.swipeStatus || options.pinchStatus) {
					ret = triggerHandler(event, phase);
				}
			}
			else {
				//A touch with more or less than the fingers we are looking for, so cancel
				ret = false; 
			}

			//If we have a return value from the users handler, then return and cancel
			if (ret === false) {
				phase = PHASE_CANCEL;
				triggerHandler(event, phase);
				return ret;
			}
			else {
				setTouchInProgress(true);
			}

            return null;
		};
		
		
		
		/**
		* Event handler for a touch move event. 
		* If we change fingers during move, then cancel the event
		* @inner
		* @param {object} jqEvent The normalised jQuery event object.
		*/
		function touchMove(jqEvent) {
			
			//As we use Jquery bind for events, we need to target the original event object
			//If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
			var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
			
			//If we are ending, cancelling, or within the threshold of 2 fingers being released, don't track anything..
			if (phase === PHASE_END || phase === PHASE_CANCEL || inMultiFingerRelease())
				return;

			var ret,
				evt = SUPPORTS_TOUCH ? event.touches[0] : event;
			

			//Update the  finger data 
			var currentFinger = updateFingerData(evt);
			endTime = getTimeStamp();
			
			if (SUPPORTS_TOUCH) {
				fingerCount = event.touches.length;
			}

			phase = PHASE_MOVE;

			//If we have 2 fingers get Touches distance as well
			if(fingerCount==2) {
				
				//Keep track of the initial pinch distance, so we can calculate the diff later
				//We do this here as well as the start event, in case they start with 1 finger, and the press 2 fingers
				if(startTouchesDistance==0) {
					//Create second finger if this is the first time...
					createFingerData( 1, event.touches[1] );
					
					startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
				} else {
					//Else just update the second finger
					updateFingerData(event.touches[1]);
				
					endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end);
					pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end);
				}
				
				
				pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance);
				pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance);
			}
			
			
			if ( (fingerCount === options.fingers || options.fingers === ALL_FINGERS) || !SUPPORTS_TOUCH || hasPinches() ) {
				
				direction = calculateDirection(currentFinger.start, currentFinger.end);
				
				//Check if we need to prevent default event (page scroll / pinch zoom) or not
				validateDefaultEvent(jqEvent, direction);

				//Distance and duration are all off the main finger
				distance = calculateDistance(currentFinger.start, currentFinger.end);
				duration = calculateDuration();

                //Cache the maximum distance we made in this direction
                setMaxDistance(direction, distance);


				if (options.swipeStatus || options.pinchStatus) {
					ret = triggerHandler(event, phase);
				}
				
				
				//If we trigger end events when threshold are met, or trigger events when touch leaves element
				if(!options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
					
					var inBounds = true;
					
					//If checking if we leave the element, run the bounds check (we can use touchleave as its not supported on webkit)
					if(options.triggerOnTouchLeave) {
						var bounds = getbounds( this );
						inBounds = isInBounds( currentFinger.end, bounds );
					}
					
					//Trigger end handles as we swipe if thresholds met or if we have left the element if the user has asked to check these..
					if(!options.triggerOnTouchEnd && inBounds) {
						phase = getNextPhase( PHASE_MOVE );
					} 
					//We end if out of bounds here, so set current phase to END, and check if its modified 
					else if(options.triggerOnTouchLeave && !inBounds ) {
						phase = getNextPhase( PHASE_END );
					}
						
					if(phase==PHASE_CANCEL || phase==PHASE_END)	{
						triggerHandler(event, phase);
					}				
				}
			}
			else {
				phase = PHASE_CANCEL;
				triggerHandler(event, phase);
			}

			if (ret === false) {
				phase = PHASE_CANCEL;
				triggerHandler(event, phase);
			}
		}



		/**
		* Event handler for a touch end event. 
		* Calculate the direction and trigger events
		* @inner
		* @param {object} jqEvent The normalised jQuery event object.
		*/
		function touchEnd(jqEvent) {
			//As we use Jquery bind for events, we need to target the original event object
			var event = jqEvent.originalEvent;
				

			//If we are still in a touch with another finger return
			//This allows us to wait a fraction and see if the other finger comes up, if it does within the threshold, then we treat it as a multi release, not a single release.
			if (SUPPORTS_TOUCH) {
				if(event.touches.length>0) {
					startMultiFingerRelease();
					return true;
				}
			}
			
			//If a previous finger has been released, check how long ago, if within the threshold, then assume it was a multifinger release.
			//This is used to allow 2 fingers to release fractionally after each other, whilst maintainig the event as containg 2 fingers, not 1
			if(inMultiFingerRelease()) {	
				fingerCount=previousTouchFingerCount;
			}	
				 
			//call this on jq event so we are cross browser 
			jqEvent.preventDefault(); 
			
			//Set end of swipe
			endTime = getTimeStamp();
			
			//Get duration incase move was never fired
			duration = calculateDuration();
			
			//If we trigger handlers at end of swipe OR, we trigger during, but they didnt trigger and we are still in the move phase
			if(didSwipeBackToCancel()) {
			    phase = PHASE_CANCEL;
                triggerHandler(event, phase);
			} else if (options.triggerOnTouchEnd || (options.triggerOnTouchEnd == false && phase === PHASE_MOVE)) {
				phase = PHASE_END;
                triggerHandler(event, phase);
			}
			//Special cases - A tap should always fire on touch end regardless,
			//So here we manually trigger the tap end handler by itself
			//We dont run trigger handler as it will re-trigger events that may have fired already
			else if (!options.triggerOnTouchEnd && hasTap()) {
                //Trigger the pinch events...
			    phase = PHASE_END;
			    triggerHandlerForGesture(event, phase, TAP);
			}
			else if (phase === PHASE_MOVE) {
				phase = PHASE_CANCEL;
				triggerHandler(event, phase);
			}

			setTouchInProgress(false);

            return null;
		}



		/**
		* Event handler for a touch cancel event. 
		* Clears current vars
		* @inner
		*/
		function touchCancel() {
			// reset the variables back to default values
			fingerCount = 0;
			endTime = 0;
			startTime = 0;
			startTouchesDistance=0;
			endTouchesDistance=0;
			pinchZoom=1;
			
			//If we were in progress of tracking a possible multi touch end, then re set it.
			cancelMultiFingerRelease();
			
			setTouchInProgress(false);
		}
		
		
		/**
		* Event handler for a touch leave event. 
		* This is only triggered on desktops, in touch we work this out manually
		* as the touchleave event is not supported in webkit
		* @inner
		*/
		function touchLeave(jqEvent) {
			var event = jqEvent.originalEvent;
			
			//If we have the trigger on leave property set....
			if(options.triggerOnTouchLeave) {
				phase = getNextPhase( PHASE_END );
				triggerHandler(event, phase);
			}
		}
		
		/**
		* Removes all listeners that were associated with the plugin
		* @inner
		*/
		function removeListeners() {
			$element.unbind(START_EV, touchStart);
			$element.unbind(CANCEL_EV, touchCancel);
			$element.unbind(MOVE_EV, touchMove);
			$element.unbind(END_EV, touchEnd);
			
			//we only have leave events on desktop, we manually calculate leave on touch as its not supported in webkit
			if(LEAVE_EV) { 
				$element.unbind(LEAVE_EV, touchLeave);
			}
			
			setTouchInProgress(false);
		}

		
		/**
		 * Checks if the time and distance thresholds have been met, and if so then the appropriate handlers are fired.
		 */
		function getNextPhase(currentPhase) {
			
			var nextPhase = currentPhase;
			
			// Ensure we have valid swipe (under time and over distance  and check if we are out of bound...)
			var validTime = validateSwipeTime();
			var validDistance = validateSwipeDistance();
			var didCancel = didSwipeBackToCancel();
						
			//If we have exceeded our time, then cancel	
			if(!validTime || didCancel) {
				nextPhase = PHASE_CANCEL;
			}
			//Else if we are moving, and have reached distance then end
			else if (validDistance && currentPhase == PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave) ) {
				nextPhase = PHASE_END;
			} 
			//Else if we have ended by leaving and didn't reach distance, then cancel
			else if (!validDistance && currentPhase==PHASE_END && options.triggerOnTouchLeave) {
				nextPhase = PHASE_CANCEL;
			}
			
			return nextPhase;
		}
		
		
		/**
		* Trigger the relevant event handler
		* The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
		* @param {object} event the original event object
		* @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
		* @inner
		*/
		function triggerHandler(event, phase) {
			
			var ret = undefined;
			
			// SWIPE GESTURES
			if(didSwipe() || hasSwipes()) { //hasSwipes as status needs to fire even if swipe is invalid
				//Trigger the swipe events...
				ret = triggerHandlerForGesture(event, phase, SWIPE);
			} 
			
			// PINCH GESTURES (if the above didn't cancel)
			else if((didPinch() || hasPinches()) && ret!==false) {
				//Trigger the pinch events...
				ret = triggerHandlerForGesture(event, phase, PINCH);
			}
			
			// CLICK / TAP (if the above didn't cancel)
			if(didDoubleTap() && ret!==false) {
				//Trigger the tap events...
				ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP);
			}
			
			// CLICK / TAP (if the above didn't cancel)
			else if(didLongTap() && ret!==false) {
				//Trigger the tap events...
				ret = triggerHandlerForGesture(event, phase, LONG_TAP);
			}

			// CLICK / TAP (if the above didn't cancel)
			else if(didTap() && ret!==false) {
				//Trigger the tap event..
				ret = triggerHandlerForGesture(event, phase, TAP);
	    	}
			
			
			
			// If we are cancelling the gesture, then manually trigger the reset handler
			if (phase === PHASE_CANCEL) {
				touchCancel(event);
			}
			
			// If we are ending the gesture, then manually trigger the reset handler IF all fingers are off
			if(phase === PHASE_END) {
				//If we support touch, then check that all fingers are off before we cancel
				if (SUPPORTS_TOUCH) {
					if(event.touches.length==0) {
						touchCancel(event);	
					}
				} 
				else {
					touchCancel(event);
				}
			}
					
			return ret;
		}
		
		
		
		/**
		* Trigger the relevant event handler
		* The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
		* @param {object} event the original event object
		* @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
		* @param {string} gesture the gesture to trigger a handler for : PINCH or SWIPE {@link $.fn.swipe.gestures}
		* @return Boolean False, to indicate that the event should stop propagation, or void.
		* @inner
		*/
		function triggerHandlerForGesture(event, phase, gesture) {	
			
			var ret=undefined;
			
			//SWIPES....
			if(gesture==SWIPE) {
				//Trigger status every time..
				
				//Trigger the event...
				$element.trigger('swipeStatus', [phase, direction || null, distance || 0, duration || 0, fingerCount]);
				
				//Fire the callback
				if (options.swipeStatus) {
					ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount);
					//If the status cancels, then dont run the subsequent event handlers..
					if(ret===false) return false;
				}
				
				
				
				
				if (phase == PHASE_END && validateSwipe()) {
					//Fire the catch all event
					$element.trigger('swipe', [direction, distance, duration, fingerCount]);
					
					//Fire catch all callback
					if (options.swipe) {
						ret = options.swipe.call($element, event, direction, distance, duration, fingerCount);
						//If the status cancels, then dont run the subsequent event handlers..
						if(ret===false) return false;
					}
					
					//trigger direction specific event handlers	
					switch (direction) {
						case LEFT:
							//Trigger the event
							$element.trigger('swipeLeft', [direction, distance, duration, fingerCount]);
					
					        //Fire the callback
							if (options.swipeLeft) {
								ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount);
							}
							break;
	
						case RIGHT:
							//Trigger the event
					        $element.trigger('swipeRight', [direction, distance, duration, fingerCount]);
					
					        //Fire the callback
							if (options.swipeRight) {
								ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount);
							}
							break;
	
						case UP:
							//Trigger the event
					        $element.trigger('swipeUp', [direction, distance, duration, fingerCount]);
					
					        //Fire the callback
							if (options.swipeUp) {
								ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount);
							}
							break;
	
						case DOWN:
							//Trigger the event
					        $element.trigger('swipeDown', [direction, distance, duration, fingerCount]);
					
					        //Fire the callback
							if (options.swipeDown) {
								ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount);
							}
							break;
					}
				}
			}
			
			
			//PINCHES....
			if(gesture==PINCH) {
				//Trigger the event
			     $element.trigger('pinchStatus', [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);
					
                //Fire the callback
				if (options.pinchStatus) {
					ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
					//If the status cancels, then dont run the subsequent event handlers..
					if(ret===false) return false;
				}
				
				if(phase==PHASE_END && validatePinch()) {
					
					switch (pinchDirection) {
						case IN:
							//Trigger the event
                            $element.trigger('pinchIn', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);
                    
                            //Fire the callback
                            if (options.pinchIn) {
								ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
							}
							break;
						
						case OUT:
							//Trigger the event
                            $element.trigger('pinchOut', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);
                    
                            //Fire the callback
                            if (options.pinchOut) {
								ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
							}
							break;	
					}
				}
			}
			


                
	    		
			if(gesture==TAP) {
				if(phase === PHASE_CANCEL || phase === PHASE_END) {
					
    			    
    			    //Cancel any existing double tap
				    clearTimeout(singleTapTimeout);
				           
					//If we are also looking for doubelTaps, wait incase this is one...
				    if(hasDoubleTap() && !inDoubleTap()) {
				        //Cache the time of this tap
                        doubleTapStartTime = getTimeStamp();
                       
				        //Now wait for the double tap timeout, and trigger this single tap
				        //if its not cancelled by a double tap
				        singleTapTimeout = setTimeout($.proxy(function() {
        			        doubleTapStartTime=null;
        			        //Trigger the event
                            $element.trigger('tap', [event.target]);

                        
                            //Fire the callback
                            if(options.tap) {
                                ret = options.tap.call($element, event, event.target);
                            }
    			        }, this), options.doubleTapThreshold );
    			    	
    			    } else {
                        doubleTapStartTime=null;
                        
                        //Trigger the event
                        $element.trigger('tap', [event.target]);

                        
                        //Fire the callback
                        if(options.tap) {
                            ret = options.tap.call($element, event, event.target);
                        }
	    		    }
	    		}
			}
			
			else if (gesture==DOUBLE_TAP) {
				if(phase === PHASE_CANCEL || phase === PHASE_END) {
					//Cancel any pending singletap 
				    clearTimeout(singleTapTimeout);
				    doubleTapStartTime=null;
				        
                    //Trigger the event
                    $element.trigger('doubletap', [event.target]);
                
                    //Fire the callback
                    if(options.doubleTap) {
                        ret = options.doubleTap.call($element, event, event.target);
                    }
	    		}
			}
			
			else if (gesture==LONG_TAP) {
				if(phase === PHASE_CANCEL || phase === PHASE_END) {
					//Cancel any pending singletap (shouldnt be one)
				    clearTimeout(singleTapTimeout);
				    doubleTapStartTime=null;
				        
                    //Trigger the event
                    $element.trigger('longtap', [event.target]);
                
                    //Fire the callback
                    if(options.longTap) {
                        ret = options.longTap.call($element, event, event.target);
                    }
	    		}
			}				
				
			return ret;
		}



		
		//
		// GESTURE VALIDATION
		//
		
		/**
		* Checks the user has swipe far enough
		* @return Boolean if <code>threshold</code> has been set, return true if the threshold was met, else false.
		* If no threshold was set, then we return true.
		* @inner
		*/
		function validateSwipeDistance() {
			var valid = true;
			//If we made it past the min swipe distance..
			if (options.threshold !== null) {
				valid = distance >= options.threshold;
			}
			
            return valid;
		}
		
		/**
		* Checks the user has swiped back to cancel.
		* @return Boolean if <code>cancelThreshold</code> has been set, return true if the cancelThreshold was met, else false.
		* If no cancelThreshold was set, then we return true.
		* @inner
		*/
		function didSwipeBackToCancel() {
            var cancelled = false;
    		if(options.cancelThreshold !== null && direction !==null)  {
    		    cancelled =  (getMaxDistance( direction ) - distance) >= options.cancelThreshold;
			}
			
			return cancelled;
		}

		/**
		* Checks the user has pinched far enough
		* @return Boolean if <code>pinchThreshold</code> has been set, return true if the threshold was met, else false.
		* If no threshold was set, then we return true.
		* @inner
		*/
		function validatePinchDistance() {
			if (options.pinchThreshold !== null) {
				return pinchDistance >= options.pinchThreshold;
			}
			return true;
		}

		/**
		* Checks that the time taken to swipe meets the minimum / maximum requirements
		* @return Boolean
		* @inner
		*/
		function validateSwipeTime() {
			var result;
			//If no time set, then return true

			if (options.maxTimeThreshold) {
				if (duration >= options.maxTimeThreshold) {
					result = false;
				} else {
					result = true;
				}
			}
			else {
				result = true;
			}

			return result;
		}


		/**
		* Checks direction of the swipe and the value allowPageScroll to see if we should allow or prevent the default behaviour from occurring.
		* This will essentially allow page scrolling or not when the user is swiping on a touchSwipe object.
		* @param {object} jqEvent The normalised jQuery representation of the event object.
		* @param {string} direction The direction of the event. See {@link $.fn.swipe.directions}
		* @see $.fn.swipe.directions
		* @inner
		*/
		function validateDefaultEvent(jqEvent, direction) {
			if (options.allowPageScroll === NONE || hasPinches()) {
				jqEvent.preventDefault();
			} else {
				var auto = options.allowPageScroll === AUTO;

				switch (direction) {
					case LEFT:
						if ((options.swipeLeft && auto) || (!auto && options.allowPageScroll != HORIZONTAL)) {
							jqEvent.preventDefault();
						}
						break;

					case RIGHT:
						if ((options.swipeRight && auto) || (!auto && options.allowPageScroll != HORIZONTAL)) {
							jqEvent.preventDefault();
						}
						break;

					case UP:
						if ((options.swipeUp && auto) || (!auto && options.allowPageScroll != VERTICAL)) {
							jqEvent.preventDefault();
						}
						break;

					case DOWN:
						if ((options.swipeDown && auto) || (!auto && options.allowPageScroll != VERTICAL)) {
							jqEvent.preventDefault();
						}
						break;
				}
			}

		}


		// PINCHES
		/**
		 * Returns true of the current pinch meets the thresholds
		 * @return Boolean
		 * @inner
		*/
		function validatePinch() {
		    var hasCorrectFingerCount = validateFingers();
		    var hasEndPoint = validateEndPoint();
			var hasCorrectDistance = validatePinchDistance();
			return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
			
		}
		
		/**
		 * Returns true if any Pinch events have been registered
		 * @return Boolean
		 * @inner
		*/
		function hasPinches() {
			//Enure we dont return 0 or null for false values
			return !!(options.pinchStatus || options.pinchIn || options.pinchOut);
		}
		
		/**
		 * Returns true if we are detecting pinches, and have one
		 * @return Boolean
		 * @inner
		 */
		function didPinch() {
			//Enure we dont return 0 or null for false values
			return !!(validatePinch() && hasPinches());
		}




		// SWIPES
		/**
		 * Returns true if the current swipe meets the thresholds
		 * @return Boolean
		 * @inner
		*/
		function validateSwipe() {
			//Check validity of swipe
			var hasValidTime = validateSwipeTime();
			var hasValidDistance = validateSwipeDistance();	
			var hasCorrectFingerCount = validateFingers();
		    var hasEndPoint = validateEndPoint();
		    var didCancel = didSwipeBackToCancel();	
		    
			// if the user swiped more than the minimum length, perform the appropriate action
			// hasValidDistance is null when no distance is set 
			var valid =  !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
			
			return valid;
		}
		
		/**
		 * Returns true if any Swipe events have been registered
		 * @return Boolean
		 * @inner
		*/
		function hasSwipes() {
			//Enure we dont return 0 or null for false values
			return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown);
		}
		
		
		/**
		 * Returns true if we are detecting swipes and have one
		 * @return Boolean
		 * @inner
		*/
		function didSwipe() {
			//Enure we dont return 0 or null for false values
			return !!(validateSwipe() && hasSwipes());
		}

        /**
		 * Returns true if we have matched the number of fingers we are looking for
		 * @return Boolean
		 * @inner
		*/
        function validateFingers() {
            //The number of fingers we want were matched, or on desktop we ignore
    		return ((fingerCount === options.fingers || options.fingers === ALL_FINGERS) || !SUPPORTS_TOUCH);
    	}
        
        /**
		 * Returns true if we have an end point for the swipe
		 * @return Boolean
		 * @inner
		*/
        function validateEndPoint() {
            //We have an end value for the finger
		    return fingerData[0].end.x !== 0;
        }

		// TAP / CLICK
		/**
		 * Returns true if a click / tap events have been registered
		 * @return Boolean
		 * @inner
		*/
		function hasTap() {
			//Enure we dont return 0 or null for false values
			return !!(options.tap) ;
		}
		
		/**
		 * Returns true if a double tap events have been registered
		 * @return Boolean
		 * @inner
		*/
		function hasDoubleTap() {
			//Enure we dont return 0 or null for false values
			return !!(options.doubleTap) ;
		}
		
		/**
		 * Returns true if any long tap events have been registered
		 * @return Boolean
		 * @inner
		*/
		function hasLongTap() {
			//Enure we dont return 0 or null for false values
			return !!(options.longTap) ;
		}
		
		/**
		 * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
		 * @return Boolean
		 * @inner
		*/
		function validateDoubleTap() {
		    if(doubleTapStartTime==null){
		        return false;
		    }
		    var now = getTimeStamp();
		    return (hasDoubleTap() && ((now-doubleTapStartTime) <= options.doubleTapThreshold));
		}
		
		/**
		 * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
		 * @return Boolean
		 * @inner
		*/
		function inDoubleTap() {
		    return validateDoubleTap();
		}
		
		
		/**
		 * Returns true if we have a valid tap
		 * @return Boolean
		 * @inner
		*/
		function validateTap() {
		    return ((fingerCount === 1 || !SUPPORTS_TOUCH) && (isNaN(distance) || distance === 0));
		}
		
		/**
		 * Returns true if we have a valid long tap
		 * @return Boolean
		 * @inner
		*/
		function validateLongTap() {
		    //slight threshold on moving finger
            return ((duration > options.longTapThreshold) && (distance < DOUBLE_TAP_THRESHOLD)); 
		}
		
		/**
		 * Returns true if we are detecting taps and have one
		 * @return Boolean
		 * @inner
		*/
		function didTap() {
		    //Enure we dont return 0 or null for false values
			return !!(validateTap() && hasTap());
		}
		
		
		/**
		 * Returns true if we are detecting double taps and have one
		 * @return Boolean
		 * @inner
		*/
		function didDoubleTap() {
		    //Enure we dont return 0 or null for false values
			return !!(validateDoubleTap() && hasDoubleTap());
		}
		
		/**
		 * Returns true if we are detecting long taps and have one
		 * @return Boolean
		 * @inner
		*/
		function didLongTap() {
		    //Enure we dont return 0 or null for false values
			return !!(validateLongTap() && hasLongTap());
		}
		
		
		
		
		// MULTI FINGER TOUCH
		/**
		 * Starts tracking the time between 2 finger releases, and keeps track of how many fingers we initially had up
		 * @inner
		*/
		function startMultiFingerRelease() {
			previousTouchEndTime = getTimeStamp();
			previousTouchFingerCount = event.touches.length+1;
		}
		
		/**
		 * Cancels the tracking of time between 2 finger releases, and resets counters
		 * @inner
		*/
		function cancelMultiFingerRelease() {
			previousTouchEndTime = 0;
			previousTouchFingerCount = 0;
		}
		
		/**
		 * Checks if we are in the threshold between 2 fingers being released 
		 * @return Boolean
		 * @inner
		*/
		function inMultiFingerRelease() {
			
			var withinThreshold = false;
			
			if(previousTouchEndTime) {	
				var diff = getTimeStamp() - previousTouchEndTime	
				if( diff<=options.fingerReleaseThreshold ) {
					withinThreshold = true;
				}
			}
			
			return withinThreshold;	
		}
		

		/**
		* gets a data flag to indicate that a touch is in progress
		* @return Boolean
		* @inner
		*/
		function getTouchInProgress() {
			//strict equality to ensure only true and false are returned
			return !!($element.data(PLUGIN_NS+'_intouch') === true);
		}
		
		/**
		* Sets a data flag to indicate that a touch is in progress
		* @param {boolean} val The value to set the property to
		* @inner
		*/
		function setTouchInProgress(val) {
			
			//Add or remove event listeners depending on touch status
			if(val===true) {
				$element.bind(MOVE_EV, touchMove);
				$element.bind(END_EV, touchEnd);
				
				//we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
				if(LEAVE_EV) { 
					$element.bind(LEAVE_EV, touchLeave);
				}
			} else {
				$element.unbind(MOVE_EV, touchMove, false);
				$element.unbind(END_EV, touchEnd, false);
			
				//we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
				if(LEAVE_EV) { 
					$element.unbind(LEAVE_EV, touchLeave, false);
				}
			}
			
		
			//strict equality to ensure only true and false can update the value
			$element.data(PLUGIN_NS+'_intouch', val === true);
		}
		
		
		/**
		 * Creates the finger data for the touch/finger in the event object.
		 * @param {int} index The index in the array to store the finger data (usually the order the fingers were pressed)
		 * @param {object} evt The event object containing finger data
		 * @return finger data object
		 * @inner
		*/
		function createFingerData( index, evt ) {
			var id = evt.identifier!==undefined ? evt.identifier : 0; 
			
			fingerData[index].identifier = id;
			fingerData[index].start.x = fingerData[index].end.x = evt.pageX||evt.clientX;
			fingerData[index].start.y = fingerData[index].end.y = evt.pageY||evt.clientY;
			
			return fingerData[index];
		}
		
		/**
		 * Updates the finger data for a particular event object
		 * @param {object} evt The event object containing the touch/finger data to upadte
		 * @return a finger data object.
		 * @inner
		*/
		function updateFingerData(evt) {
			
			var id = evt.identifier!==undefined ? evt.identifier : 0; 
			var f = getFingerData( id );
			
			f.end.x = evt.pageX||evt.clientX;
			f.end.y = evt.pageY||evt.clientY;
			
			return f;
		}
		
		/**
		 * Returns a finger data object by its event ID.
		 * Each touch event has an identifier property, which is used 
		 * to track repeat touches
		 * @param {int} id The unique id of the finger in the sequence of touch events.
		 * @return a finger data object.
		 * @inner
		*/
		function getFingerData( id ) {
			for(var i=0; i<fingerData.length; i++) {
				if(fingerData[i].identifier == id) {
					return fingerData[i];	
				}
			}
		}
		
		/**
		 * Creats all the finger onjects and returns an array of finger data
		 * @return Array of finger objects
		 * @inner
		*/
		function createAllFingerData() {
			var fingerData=[];
			for (var i=0; i<=5; i++) {
				fingerData.push({
					start:{ x: 0, y: 0 },
					end:{ x: 0, y: 0 },
					identifier:0
				});
			}
			
			return fingerData;
		}
		
		/**
		 * Sets the maximum distance swiped in the given direction. 
		 * If the new value is lower than the current value, the max value is not changed.
		 * @param {string}  direction The direction of the swipe
		 * @param {int}  distance The distance of the swipe
		 * @inner
		*/
		function setMaxDistance(direction, distance) {
    		distance = Math.max(distance, getMaxDistance(direction) );
    		maximumsMap[direction].distance = distance;
		}
        
        /**
		 * gets the maximum distance swiped in the given direction. 
		 * @param {string}  direction The direction of the swipe
		 * @return int  The distance of the swipe
		 * @inner
		*/        
		function getMaxDistance(direction) {
			if (maximumsMap[direction]) return maximumsMap[direction].distance;
			return undefined;
		}
		
		/**
		 * Creats a map of directions to maximum swiped values.
		 * @return Object A dictionary of maximum values, indexed by direction.
		 * @inner
		*/
		function createMaximumsData() {
			var maxData={};
			maxData[LEFT]=createMaximumVO(LEFT);
			maxData[RIGHT]=createMaximumVO(RIGHT);
			maxData[UP]=createMaximumVO(UP);
			maxData[DOWN]=createMaximumVO(DOWN);
			
			return maxData;
		}
		
		/**
		 * Creates a map maximum swiped values for a given swipe direction
		 * @param {string} The direction that these values will be associated with
		 * @return Object Maximum values
		 * @inner
		*/
		function createMaximumVO(dir) {
		    return { 
		        direction:dir, 
		        distance:0
		    }
		}
		
		
		//
		// MATHS / UTILS
		//

		/**
		* Calculate the duration of the swipe
		* @return int
		* @inner
		*/
		function calculateDuration() {
			return endTime - startTime;
		}
		
		/**
		* Calculate the distance between 2 touches (pinch)
		* @param {point} startPoint A point object containing x and y co-ordinates
	    * @param {point} endPoint A point object containing x and y co-ordinates
	    * @return int;
		* @inner
		*/
		function calculateTouchesDistance(startPoint, endPoint) {
			var diffX = Math.abs(startPoint.x - endPoint.x);
			var diffY = Math.abs(startPoint.y - endPoint.y);
				
			return Math.round(Math.sqrt(diffX*diffX+diffY*diffY));
		}
		
		/**
		* Calculate the zoom factor between the start and end distances
		* @param {int} startDistance Distance (between 2 fingers) the user started pinching at
	    * @param {int} endDistance Distance (between 2 fingers) the user ended pinching at
	    * @return float The zoom value from 0 to 1.
		* @inner
		*/
		function calculatePinchZoom(startDistance, endDistance) {
			var percent = (endDistance/startDistance) * 1;
			return percent.toFixed(2);
		}
		
		
		/**
		* Returns the pinch direction, either IN or OUT for the given points
		* @return string Either {@link $.fn.swipe.directions.IN} or {@link $.fn.swipe.directions.OUT}
		* @see $.fn.swipe.directions
		* @inner
		*/
		function calculatePinchDirection() {
			if(pinchZoom<1) {
				return OUT;
			}
			else {
				return IN;
			}
		}
		
		
		/**
		* Calculate the length / distance of the swipe
		* @param {point} startPoint A point object containing x and y co-ordinates
	    * @param {point} endPoint A point object containing x and y co-ordinates
	    * @return int
		* @inner
		*/
		function calculateDistance(startPoint, endPoint) {
			return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
		}

		/**
		* Calculate the angle of the swipe
		* @param {point} startPoint A point object containing x and y co-ordinates
	    * @param {point} endPoint A point object containing x and y co-ordinates
	    * @return int
		* @inner
		*/
		function calculateAngle(startPoint, endPoint) {
			var x = startPoint.x - endPoint.x;
			var y = endPoint.y - startPoint.y;
			var r = Math.atan2(y, x); //radians
			var angle = Math.round(r * 180 / Math.PI); //degrees

			//ensure value is positive
			if (angle < 0) {
				angle = 360 - Math.abs(angle);
			}

			return angle;
		}

		/**
		* Calculate the direction of the swipe
		* This will also call calculateAngle to get the latest angle of swipe
		* @param {point} startPoint A point object containing x and y co-ordinates
	    * @param {point} endPoint A point object containing x and y co-ordinates
	    * @return string Either {@link $.fn.swipe.directions.LEFT} / {@link $.fn.swipe.directions.RIGHT} / {@link $.fn.swipe.directions.DOWN} / {@link $.fn.swipe.directions.UP}
		* @see $.fn.swipe.directions
		* @inner
		*/
		function calculateDirection(startPoint, endPoint ) {
			var angle = calculateAngle(startPoint, endPoint);

			if ((angle <= 45) && (angle >= 0)) {
				return LEFT;
			} else if ((angle <= 360) && (angle >= 315)) {
				return LEFT;
			} else if ((angle >= 135) && (angle <= 225)) {
				return RIGHT;
			} else if ((angle > 45) && (angle < 135)) {
				return DOWN;
			} else {
				return UP;
			}
		}
		

		/**
		* Returns a MS time stamp of the current time
		* @return int
		* @inner
		*/
		function getTimeStamp() {
			var now = new Date();
			return now.getTime();
		}
		
		
		
		/**
		 * Returns a bounds object with left, right, top and bottom properties for the element specified.
		 * @param {DomNode} The DOM node to get the bounds for.
		 */
		function getbounds( el ) {
			el = $(el);
			var offset = el.offset();
			
			var bounds = {	
					left:offset.left,
					right:offset.left+el.outerWidth(),
					top:offset.top,
					bottom:offset.top+el.outerHeight()
					}
			
			return bounds;	
		}
		
		
		/**
		 * Checks if the point object is in the bounds object.
		 * @param {object} point A point object.
		 * @param {int} point.x The x value of the point.
		 * @param {int} point.y The x value of the point.
		 * @param {object} bounds The bounds object to test
		 * @param {int} bounds.left The leftmost value
		 * @param {int} bounds.right The righttmost value
		 * @param {int} bounds.top The topmost value
		* @param {int} bounds.bottom The bottommost value
		 */
		function isInBounds(point, bounds) {
			return (point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom);
		};
	
	
	}
	
	


/**
 * A catch all handler that is triggered for all swipe directions. 
 * @name $.fn.swipe#swipe
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */
 



/**
 * A handler that is triggered for "left" swipes.
 * @name $.fn.swipe#swipeLeft
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */
 
/**
 * A handler that is triggered for "right" swipes.
 * @name $.fn.swipe#swipeRight
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */

/**
 * A handler that is triggered for "up" swipes.
 * @name $.fn.swipe#swipeUp
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */
 
/**
 * A handler that is triggered for "down" swipes.
 * @name $.fn.swipe#swipeDown
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */
 
/**
 * A handler triggered for every phase of the swipe. This handler is constantly fired for the duration of the pinch.
 * This is triggered regardless of swipe thresholds.
 * @name $.fn.swipe#swipeStatus
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {string} phase The phase of the swipe event. See {@link $.fn.swipe.phases}
 * @param {string} direction The direction the user swiped in. This is null if the user has yet to move. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped. This is 0 if the user has yet to move.
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */
 
/**
 * A handler triggered for pinch in events.
 * @name $.fn.swipe#pinchIn
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user pinched
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
 */

/**
 * A handler triggered for pinch out events.
 * @name $.fn.swipe#pinchOut
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user pinched
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
 */ 

/**
 * A handler triggered for all pinch events. This handler is constantly fired for the duration of the pinch. This is triggered regardless of thresholds.
 * @name $.fn.swipe#pinchStatus
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user pinched
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
 */

/**
 * A click handler triggered when a user simply clicks, rather than swipes on an element.
 * This is deprecated since version 1.6.2, any assignment to click will be assigned to the tap handler.
 * You cannot use <code>on</code> to bind to this event as the default jQ <code>click</code> event will be triggered.
 * Use the <code>tap</code> event instead.
 * @name $.fn.swipe#click
 * @event
 * @deprecated since version 1.6.2, please use {@link $.fn.swipe#tap} instead 
 * @default null
 * @param {EventObject} event The original event object
 * @param {DomObject} target The element clicked on.
 */
 
 /**
 * A click / tap handler triggered when a user simply clicks or taps, rather than swipes on an element.
 * @name $.fn.swipe#tap
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {DomObject} target The element clicked on.
 */
 
/**
 * A double tap handler triggered when a user double clicks or taps on an element.
 * You can set the time delay for a double tap with the {@link $.fn.swipe.defaults#doubleTapThreshold} property. 
 * Note: If you set both <code>doubleTap</code> and <code>tap</code> handlers, the <code>tap</code> event will be delayed by the <code>doubleTapThreshold</code>
 * as the script needs to check if its a double tap.
 * @name $.fn.swipe#doubleTap
 * @see  $.fn.swipe.defaults#doubleTapThreshold
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {DomObject} target The element clicked on.
 */
 
 /**
 * A long tap handler triggered when a user long clicks or taps on an element.
 * You can set the time delay for a long tap with the {@link $.fn.swipe.defaults#longTapThreshold} property. 
 * @name $.fn.swipe#longTap
 * @see  $.fn.swipe.defaults#longTapThreshold
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {DomObject} target The element clicked on.
 */

}));

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-js/Form',[ 'enketo-js/FormModel', 'enketo-js/widgets', 'jquery', 'enketo-js/plugins', 'enketo-js/extend', 'bootstrap', 'jquery.touchswipe' ],
    function( FormModel, widgets, $ ) {
        

        /**
         * Class: Form
         *
         * This class provides the JavaRosa form functionality by manipulating the survey form DOM object and
         * continuously updating the data XML Document. All methods are placed inside the constructor (so privileged
         * or private) because only one instance will be created at a time.
         *
         * @param {string} formSelector  jquery selector for the form
         * @param {string} dataStr       <instance> as XML string
         * @param {?string=} dataStrToEdit <instance> as XML string that is to be edit. This may not be a complete instance (empty nodes could be missing) and may have additional nodes.
         * @param { ?boolean= } unsubmitted    whether the dataStrToEdit has been submitted to the OpenRosa server before
         *
         * @constructor
         */

        function Form( formSelector, dataStr, dataStrToEdit, unsubmitted ) {
            var model, dataToEdit, cookies, form, $form, $formClone, repeatsPresent, fixExpr,
                loadErrors = [];

            /**
             * Function: init
             *
             * Initializes the Form instance (XML Model and HTML View).
             *
             */
            this.init = function() {
                // cloning children to keep any delegated event handlers on 'form.or' intact upon resetting
                $formClone = $( formSelector ).clone().appendTo( '<original></original>' );

                model = new FormModel( dataStr );
                form = new FormView( formSelector );

                //var profiler = new Profiler('model.init()');
                loadErrors = loadErrors.concat( model.init() );

                //profiler.report();

                if ( typeof dataStrToEdit !== 'undefined' && dataStrToEdit && dataStrToEdit.length > 0 ) {
                    dataToEdit = new FormModel( dataStrToEdit );
                    loadErrors = loadErrors.concat( dataToEdit.init() );
                    this.load( dataToEdit );
                }
                repeatsPresent = ( $( formSelector ).find( '.or-repeat' ).length > 0 );

                //profiler = new Profiler('html form.init()');
                form.init();
                //profiler.report();

                if ( loadErrors.length > 0 ) {
                    console.error( 'loadErrors: ', loadErrors );
                }

                if ( window.scrollTo ) {
                    window.scrollTo( 0, 0 );
                }

                return loadErrors;
            };

            this.ex = function( expr, type, selector, index ) {
                return model.evaluate( expr, type, selector, index );
            };
            this.getModel = function() {
                return model;
            };
            this.getInstanceID = function() {
                return model.getInstanceID();
            };
            this.getView = function() {
                return form;
            };
            this.getEncryptionKey = function() {
                return form.$.data( 'base64rsapublickey' );
            };

            /**
             * @param {boolean=} incTempl
             * @param {boolean=} incNs
             * @param {boolean=} all
             */
            this.getDataStr = function( incTempl, incNs, all ) {
                return model.getStr( incTempl, incNs, all );
            };

            this.getRecordName = function() {
                return form.recordName.get();
            };
            /**
             * @param {string} name
             */
            this.setRecordName = function( name ) {
                return form.recordName.set( name );
            };
            /**
             * @param { boolean } status [description]
             */
            this.setEditStatus = function( status ) {
                return form.editStatus.set( status );
            };
            this.getEditStatus = function() {
                return form.editStatus.get();
            };
            this.getSurveyName = function() {
                return $form.find( '#form-title' ).text();
            };

            /**
             * Restores HTML form to pre-initialized state. It is meant to be called before re-initializing with
             * new Form ( .....) and form.init()
             * For this reason, it does not fix event handler, $form, formView.$ etc.!
             * It also does not affect the XML instance!
             */
            this.resetView = function() {
                //form language selector was moved outside of <form> so has to be separately removed
                $( '#form-languages' ).remove();
                $form.replaceWith( $formClone );
            };
            /**
             * @deprecated
             * @type {Function}
             */
            this.resetHTML = this.resetView;

            /**
             * Validates the whole form and returns true or false
             *
             * @return {boolean}
             */
            this.validate = function() {
                return form.validateAll();
            };
            /**
             * Returns wether form has validated as true or false. Needs to be called AFTER calling validate()!
             *
             *  @return {!boolean}
             */
            this.isValid = function() {
                return form.isValid();
            };

            /**
             * Function to load an (possibly incomplete) instance so that it can be edited.
             *
             * @param  {Object} instanceOfFormModel [description]
             *
             */
            this.load = function( instanceOfFormModel ) {
                var nodesToLoad, index, xmlDataType, path, value, target, $input, $target, $template, instanceID, error,
                    filter = {
                        noTemplate: true,
                        noEmpty: true
                    };

                nodesToLoad = instanceOfFormModel.node( null, null, filter ).get();
                // first empty all form data nodes, to clear any default values except those inside templates
                model.node( null, null, filter ).get().each( function() {
                    // something seems fishy about doing it this way instead of using node.setVal('');
                    $( this ).text( '' );
                } );

                nodesToLoad.each( function() {
                    var errMsg,
                        name = $( this ).prop( 'nodeName' );
                    path = $( this ).getXPath( 'instance' );
                    index = instanceOfFormModel.node( path ).get().index( $( this ) );
                    value = $( this ).text();

                    //input is not populated in this function, so we take index 0 to get the XML data type
                    $input = $form.find( '[name="' + path + '"]' ).eq( 0 );

                    xmlDataType = ( $input.length > 0 ) ? form.input.getXmlType( $input ) : 'string';

                    target = model.node( path, index );

                    /*
                     *  Proper error handling on xfind with .error(function(){}) doesn't seem to work
                     *  this catch block is created to catch namespace prefix errors.
                     *  When we have WGXP, it would be better to remove this and
                     *  replace xfind with the proper XPath evaluator and pass a namespace handler
                     *  currently namespace prefix errors show up as 'unsupported psuedo selector' in JQuery
                     *  Note that this is just additional security because known namespaces will be removed in PHP.
                     */
                    try {
                        $target = target.get();
                    } catch ( error ) {
                        console.error( error );
                        errMsg = error.message || 'unknown error';
                        loadErrors.push( errMsg + ' when retrieving ' + path );
                        return;
                    }

                    //if there are multiple nodes with that name and index (actually impossible)
                    if ( $target.length > 1 ) {
                        console.error( 'Found multiple nodes with path: ' + path + ' and index: ' + index );
                    }
                    //if there is a corresponding node in the form's original instance
                    else if ( $target.length === 1 ) {
                        //set the value
                        target.setVal( value, null, xmlDataType );
                    }
                    //if there is no corresponding data node but there is a corresponding template node (=> <repeat>)
                    //this use of node(path,index,file).get() is a bit of a trick that is difficult to wrap one's head around
                    else if ( model.node( path, 0, {
                        noTemplate: false
                    } ).get().closest( '[template]' ).length > 0 ) {
                        //clone the template node 
                        //TODO add support for repeated nodes in forms that do not use template="" (not possible in formhub)
                        $template = model.node( path, 0, {
                            noTemplate: false
                        } ).get().closest( '[template]' );
                        //TODO: test this for nested repeats
                        //if a preceding repeat with that path was empty this repeat may not have been created yet,
                        //so we need to make sure all preceding repeats are created
                        for ( var p = 0; p < index; p++ ) {
                            model.cloneTemplate( $template.getXPath( 'instance' ), p );
                        }
                        //try setting the value again
                        target = model.node( path, index );
                        if ( target.get().length === 1 ) {
                            target.setVal( value, null, xmlDataType );
                        } else {
                            error = 'Error occured trying to clone template node to set the repeat value of the instance to be edited.';
                            console.error( error );
                            loadErrors.push( error );
                        }
                    }
                    //as an exception, missing meta nodes will be quietly added if a meta node exists at that path
                    //the latter requires e.g the root node to have the correct name
                    else if ( $( this ).parent( 'meta' ).length === 1 && model.node( $( this ).parent( 'meta' ).getXPath( 'instance' ), 0 ).get().length === 1 ) {
                        //if there is no existing meta node with that node as child
                        if ( model.node( ':first > meta > ' + name, 0 ).get().length === 0 ) {
                            $( this ).clone().appendTo( model.node( ':first > meta' ).get() );
                        } else {
                            error = 'Found duplicate meta node (' + name + ')!';
                            console.error( error );
                            loadErrors.push( error );
                        }
                    } else {
                        error = 'Did not find form element with path: ' + path + ' and index: ' + index + ' so failed to load model.';
                        console.error( error );
                        loadErrors.push( error );
                    }
                } );

                instanceID = model.node( '*>meta>instanceID' );
                if ( instanceID.get().length !== 1 ) {
                    error = 'InstanceID node in default instance error (found ' + instanceID.get().length + ' instanceID nodes)';
                    console.error( error );
                    loadErrors.push( error );
                    return;
                }

                // if record is not local, copy instanceID value to deprecatedID and empty instanceID
                if ( !unsubmitted ) {
                    // add deprecatedID node
                    if ( model.node( '*>meta>deprecatedID' ).get().length !== 1 ) {
                        var deprecatedIDXMLNode = $.parseXML( "<deprecatedID/>" ).documentElement;
                        document.adoptNode( deprecatedIDXMLNode );
                        $( deprecatedIDXMLNode ).appendTo( model.node( '*>meta' ).get() );
                    }

                    model.node( '*>meta>deprecatedID' ).setVal( instanceID.getVal()[ 0 ], null, 'string' );
                    instanceID.setVal( '', null, 'string' );
                }
            };

            // Implements jr:choice-name
            // TODO: this needs to work for all expressions (relevants, constraints), now it only works for calulated items
            // Ideally this belongs in the form Model, but unfortunately it needs access to the view
            fixExpr = function( expr, resTypeStr, selector, index, tryNative ) {
                var value, name, $input, label = '',
                    matches = expr.match( /jr:choice-name\(([^,]+),\s?'(.*?)'\)/ );

                if ( matches ) {
                    value = model.evaluate( matches[ 1 ], resTypeStr, selector, index, tryNative );
                    name = matches[ 2 ].trim();
                    $input = $form.find( '[name="' + name + '"]' );

                    if ( $input.length > 0 && $input.prop( 'nodeName' ).toLowerCase() === 'select' ) {
                        label = $input.find( '[value="' + value + '"]' ).text();
                    } else if ( $input.length > 0 && $input.prop( 'nodeName' ).toLowerCase() === 'input' ) {
                        label = $input.filter( function() {
                            return $( this ).attr( 'value' ) === value;
                        } ).siblings( '.option-label.active' ).text();
                    }
                    return expr.replace( matches[ 0 ], "'" + label + "'" );
                }
                return expr;
            };


            /**
             * Inner Class dealing with the HTML Form
             * @param {string} selector jQuery selector of form
             * @constructor
             * @extends Form
             */

            function FormView( selector ) {
                //there will be only one instance of FormView
                $form = $( selector );
                //used for testing
                this.$ = $form;
                this.$nonRepeats = {};
            }

            FormView.prototype.init = function() {
                var name, $required, $hint;

                if ( typeof model == 'undefined' || !( model instanceof FormModel ) ) {
                    return console.error( 'variable data needs to be defined as instance of FormModel' );
                }

                //var profiler = new Profiler('preloads.init()');
                this.preloads.init( this ); //before widgets.init (as instanceID used in offlineFilepicker widget)
                //profiler.report();

                this.grosslyViolateStandardComplianceByIgnoringCertainCalcs(); //before calcUpdate!

                //profiler = new Profiler('calcupdate');
                this.calcUpdate(); //before repeat.init as repeat count may use a calculated item
                //profiler.report();

                //profiler = new Profiler('setLangs()');
                this.langs.init(); //test: before itemsetUpdate
                //profiler.report();

                //profiler = new Profiler('repeat.init()');
                this.repeat.init( this ); //after radio button data-name setting
                //profiler.report();

                //profiler = new Profiler('itemsets initialization');
                this.itemsetUpdate();
                //profiler.report();

                //profiler = new Profiler('setting default values in form inputs');
                this.setAllVals();
                //profiler.report();

                //profiler = new Profiler('widgets initialization');
                widgets.init(); //after setAllVals()
                //profiler.report();

                //profiler = new Profiler('bootstrapify');
                this.bootstrapify();
                //profiler.report();

                //profiler = new Profiler('branch.init()');
                this.branchUpdate(); //after widgets.init()
                //profiler.report();

                this.pages.init(); // after branch.init();

                //profiler = new Profiler('outputUpdate initial');
                this.outputUpdate();
                //profiler.report();

                this.setEventHandlers(); //after widgets init to make sure widget handlers are called before

                this.editStatus.set( false );
                //profiler.report('time taken across all functions to evaluate '+xpathEvalNum+' XPath expressions: '+xpathEvalTime);
            };

            FormView.prototype.pages = {
                active: false,
                $current: [],
                $activePages: $(),
                init: function() {

                    if ( $form.hasClass( 'pages' ) ) {
                        var $allPages = $form.find( '.note, .question, .trigger, .or-appearance-field-list' )
                            .filter( function() {
                                // something tells me there is a more efficient way to doing this
                                // e.g. by selecting the descendants of the .or-appearance-field-list and removing those
                                return $( this ).parent().closest( '.or-appearance-field-list' ).length === 0;
                            } )
                            .attr( 'role', 'page' );

                        this.setToCurrent( $allPages.first( ':not(.disabled)' ) );

                        //console.log( 'all pages', $allPages );

                        if ( $allPages.length > 1 || $allPages.eq( 0 ).hasClass( 'or-repeat' ) ) {
                            this.$formFooter = $( '.form-footer' );
                            this.$btnFirst = this.$formFooter.find( '.first-page' );
                            this.$btnPrev = this.$formFooter.find( '.previous-page' );
                            this.$btnNext = this.$formFooter.find( '.next-page' );
                            this.$btnLast = this.$formFooter.find( '.last-page' );

                            this.updateAllActive( $allPages );
                            this.toggleButtons( 0 );
                            this.setButtonHandlers();
                            this.setRepeatHandlers();
                            this.setBranchHandlers();
                            this.setSwipeHandlers();
                            this.active = true;
                        }

                        $form.show();
                    }
                },
                setButtonHandlers: function() {
                    var that = this;
                    this.$btnFirst.click( function() {
                        that.flipToFirst();
                        return false;
                    } );
                    this.$btnPrev.click( function() {
                        that.prev();
                        return false;
                    } );
                    this.$btnNext.click( function() {
                        console.log( 'next!' );
                        that.next();
                        return false;
                    } );
                    this.$btnLast.click( function() {
                        that.flipToLast();
                        return false;
                    } );
                },
                setSwipeHandlers: function() {
                    var that = this;
                    $( document ).swipe( {
                        allowPageScroll: "vertical",
                        threshold: 50,
                        swipeLeft: function( ev ) {
                            that.next();
                        },
                        swipeRight: function( ev ) {
                            console.log( 'swipe left!' );
                            that.prev();
                        }
                    } );
                },
                setRepeatHandlers: function() {
                    var that = this;
                    // TODO: can be optimized by smartly updating the active pages
                    $form.on( 'addrepeat', function( event ) {
                        that.updateAllActive();
                        //removing the class in effect avoids the animation
                        $( event.target ).removeClass( 'current contains-current' ).find( '.current' ).removeClass( 'current' );
                        that.flipToPageContaining( $( event.target ) );
                    } );
                    $form.on( 'removerepeat', function( event ) {
                        console.log( 'handling repeat removal in page object', event.target );
                        // if the current page is removed
                        // note that that.$current will have length 1 even if it was removed from DOM!!
                        if ( that.$current.closest( 'html' ).length === 0 ) {
                            that.updateAllActive();
                            // is it best to go to previous page always? 
                            that.flipToPageContaining( $( event.target ) );
                        }
                    } );
                },
                setBranchHandlers: function() {
                    var that = this;
                    // TODO: can be optimized by smartly updating the active pages
                    $form.on( 'showbranch hidebranch', function( event ) {
                        that.updateAllActive();
                        that.toggleButtons();
                    } );
                },
                getCurrent: function() {
                    return this.$current;
                },
                updateAllActive: function( $all ) {
                    //console.log( 'refreshing collection of active pages' );
                    $all = $all || $( '.or [role="page"]' );
                    this.$activePages = $all.filter( function() {
                        return $( this ).closest( '.disabled' ).length === 0;
                    } );
                },
                getAllActive: function() {
                    return this.$activePages;
                },
                getPrev: function( currentIndex ) {
                    return this.$activePages[ currentIndex - 1 ];
                },
                getNext: function( currentIndex ) {
                    return this.$activePages[ currentIndex + 1 ];
                },
                getCurrentIndex: function() {
                    return this.$activePages.index( this.$current );
                },
                next: function() {
                    var next, currentIndex;
                    this.updateAllActive();
                    currentIndex = this.getCurrentIndex();
                    next = this.getNext( currentIndex );

                    if ( next ) {
                        this.flipTo( next, currentIndex + 1 );
                    } else {
                        console.log( 'no page present to flip forward to!' );
                    }
                },
                prev: function() {
                    var prev, currentIndex;
                    this.updateAllActive();
                    currentIndex = this.getCurrentIndex();
                    prev = this.getPrev( currentIndex );

                    if ( prev ) {
                        this.flipTo( prev, currentIndex - 1 );
                    } else {
                        console.log( 'no page present to flip backward to' );
                    }
                },
                setToCurrent: function( pageEl ) {
                    var $n = $( pageEl );
                    $n.addClass( 'current hidden' );
                    this.$current = $n.removeClass( 'hidden' )
                        .parentsUntil( '.or', '.or-group, .or-group-data, .or-repeat' ).addClass( 'contains-current' ).end();
                },
                flipTo: function( pageEl, newIndex ) {
                    var that = this;

                    // if there is a current page
                    if ( this.$current.length > 0 && this.$current.closest( 'html' ).length === 1 ) {
                        // if current page is not same as pageEl
                        if ( this.$current[ 0 ] !== pageEl ) {
                            this.$current.removeClass( 'current fade-out' ).parentsUntil( '.or', '.or-group, .or-group-data, .or-repeat' ).removeClass( 'contains-current' );
                            this.setToCurrent( pageEl );
                            this.focusOnFirstQuestion( pageEl );
                            this.toggleButtons( newIndex );
                        }

                        //                            this.$current.addClass( 'fade-out' )
                        //                                .one( 'transitionend', function() {
                        //                                    that.$current.removeClass( 'current fade-out' ).parentsUntil( '.or', '.or-group, .or-group-data, .or-repeat' ).removeClass( 'contains-current' );
                        //                                    that.setToCurrent( pageEl );
                        //                                    that.focusOnFirstQuestion( pageEl );
                        //                                    that.toggleButtons( newIndex );
                        //                                } );
                        // }
                    } else {
                        this.setToCurrent( pageEl );
                        this.focusOnFirstQuestion( pageEl );
                        this.toggleButtons( newIndex );
                    }


                    if ( window.scrollTo ) {
                        window.scrollTo( 0, 0 );
                    }
                },
                flipToFirst: function() {
                    this.updateAllActive();
                    this.flipTo( this.$activePages[ 0 ] );
                },
                flipToLast: function() {
                    this.updateAllActive();
                    this.flipTo( this.$activePages.last()[ 0 ] );
                },
                // flips to the page provided as jQueried parameter or the page containing 
                // the jQueried element provided as parameter
                // alternatively, (e.g. if a top level repeat without field-list appearance is provided as parameter)
                // it flips to the page contained with the jQueried parameter;
                flipToPageContaining: function( $e ) {
                    var $closest;
                    $closest = $e.closest( '[role="page"]' );
                    $closest = ( $closest.length === 0 ) ? $e.find( '[role="page"]' ) : $closest;

                    //this.updateAllActive();
                    this.flipTo( $closest[ 0 ] );
                },
                focusOnFirstQuestion: function( pageEl ) {
                    //triggering fake focus in case element cannot be focused (if hidden by widget)
                    $( pageEl ).find( '.question:not(.disabled)' ).filter( function() {
                        return $( this ).parents( '.disabled' ).length === 0;
                    } ).eq( 0 ).find( 'input, select, textarea' ).eq( 0 ).trigger( 'fakefocus' );
                },
                toggleButtons: function( index ) {
                    var i = index || this.getCurrentIndex(),
                        next = this.getNext( i ),
                        prev = this.getPrev( i );
                    this.$btnNext.add( this.$btnLast ).toggleClass( 'disabled', !next );
                    this.$btnPrev.add( this.$btnFirst ).toggleClass( 'disabled', !prev );
                    this.$formFooter.toggleClass( 'end', !next );
                }
            };

            //this may not be the most efficient. Could also be implemented like model.Nodeset;
            //also use for fieldset nodes (to evaluate branch logic) and also used to get and set form data of the app settings
            FormView.prototype.input = {
                //multiple nodes are limited to ones of the same input type (better implemented as JQuery plugin actually)
                getWrapNodes: function( $inputNodes ) {
                    var type = this.getInputType( $inputNodes.eq( 0 ) );
                    return ( type == 'fieldset' ) ? $inputNodes : $inputNodes.closest( '.question, .note' );
                },
                /** very inefficient, should actually not be used **/
                getProps: function( $node ) {
                    if ( $node.length !== 1 ) {
                        return console.error( 'getProps(): no input node provided or multiple' );
                    }
                    return {
                        path: this.getName( $node ),
                        ind: this.getIndex( $node ),
                        inputType: this.getInputType( $node ),
                        xmlType: this.getXmlType( $node ),
                        constraint: $node.attr( 'data-constraint' ),
                        relevant: $node.attr( 'data-relevant' ),
                        val: this.getVal( $node ),
                        required: ( $node.attr( 'required' ) !== undefined && $node.parents( '.or-appearance-label' ).length === 0 ) ? true : false,
                        enabled: this.isEnabled( $node ),
                        multiple: this.isMultiple( $node )
                    };
                },
                getInputType: function( $node ) {
                    var nodeName;
                    if ( $node.length !== 1 ) {
                        return ''; //console.error('getInputType(): no input node provided or multiple');
                    }
                    nodeName = $node.prop( 'nodeName' ).toLowerCase();
                    if ( nodeName == 'input' ) {
                        if ( $node.attr( 'type' ).length > 0 ) {
                            return $node.attr( 'type' ).toLowerCase();
                        } else {
                            return console.error( '<input> node has no type' );
                        }
                    } else if ( nodeName == 'select' ) {
                        return 'select';
                    } else if ( nodeName == 'textarea' ) {
                        return 'textarea';
                    } else if ( nodeName == 'fieldset' || nodeName == 'section' ) {
                        return 'fieldset';
                    } else return console.error( 'unexpected input node type provided' );
                },
                getXmlType: function( $node ) {
                    if ( $node.length !== 1 ) {
                        return console.error( 'getXMLType(): no input node provided or multiple' );
                    }
                    return $node.attr( 'data-type-xml' );
                },
                getName: function( $node ) {
                    var name;
                    if ( $node.length !== 1 ) {
                        return console.error( 'getName(): no input node provided or multiple' );
                    }
                    name = $node.attr( 'data-name' ) || $node.attr( 'name' );
                    return name || console.error( 'input node has no name' );
                },
                /**
                 * Used to retrieve the index of a question amidst all questions with the same name.
                 * The index that can be used to find the corresponding node in the model.
                 * NOTE: this function should be used sparingly, as it is CPU intensive!
                 * TODO: simplify this function by looking for nodes with same CLASS on wrapNode
                 *
                 * @param  {jQuery} $node The jQuery-wrapped input element
                 * @return {number}       The index
                 */
                getIndex: function( $node ) {
                    var inputType, name, $wrapNode, $wrapNodesSameName;
                    if ( $node.length !== 1 ) {
                        return console.error( 'getIndex(): no input node provided or multiple' );
                    }

                    inputType = this.getInputType( $node );
                    name = this.getName( $node );
                    $wrapNode = this.getWrapNodes( $node );

                    if ( inputType === 'radio' && name !== $node.attr( 'name' ) ) {
                        $wrapNodesSameName = this.getWrapNodes( $form.find( '[data-name="' + name + '"]' ) );
                    }
                    // fieldset.or-group wraps fieldset.or-repeat and can have same name attribute!)
                    else if ( inputType === 'fieldset' && $node.hasClass( 'or-repeat' ) ) {
                        $wrapNodesSameName = this.getWrapNodes( $form.find( '.or-repeat[name="' + name + '"]' ) );
                    } else if ( inputType === 'fieldset' && $node.hasClass( 'or-group' ) ) {
                        $wrapNodesSameName = this.getWrapNodes( $form.find( '.or-group[name="' + name + '"]' ) );
                    } else {
                        $wrapNodesSameName = this.getWrapNodes( $form.find( '[name="' + name + '"]' ) );
                    }

                    return $wrapNodesSameName.index( $wrapNode );
                },
                isMultiple: function( $node ) {
                    return ( this.getInputType( $node ) == 'checkbox' || $node.attr( 'multiple' ) !== undefined ) ? true : false;
                },
                isEnabled: function( $node ) {
                    return !( $node.prop( 'disabled' ) || $node.parents( '.disabled' ).length > 0 );
                },
                getVal: function( $node ) {
                    var inputType, values = [],
                        name;
                    if ( $node.length !== 1 ) {
                        return console.error( 'getVal(): no inputNode provided or multiple' );
                    }
                    inputType = this.getInputType( $node );
                    name = this.getName( $node );

                    if ( inputType === 'radio' ) {
                        return this.getWrapNodes( $node ).find( 'input:checked' ).val() || '';
                    }
                    // checkbox values bug in jQuery as (node.val() should work)
                    if ( inputType === 'checkbox' ) {
                        this.getWrapNodes( $node ).find( 'input[name="' + name + '"]:checked' ).each( function() {
                            values.push( $( this ).val() );
                        } );
                        return values;
                    }
                    return ( !$node.val() ) ? '' : ( $.isArray( $node.val() ) ) ? $node.val().join( ' ' ).trim() : $node.val().trim();
                },
                setVal: function( name, index, value ) {
                    var $inputNodes, type, date, $target;
                    // values = value.split(' ');
                    index = index || 0;

                    if ( this.getInputType( $form.find( '[data-name="' + name + '"]' ).eq( 0 ) ) == 'radio' ) {
                        $target = this.getWrapNodes( $form.find( '[data-name="' + name + '"]' ) ).eq( index ).find( 'input[value="' + value + '"]' );
                        // why not use this.getIndex?
                        $target.prop( 'checked', true );
                        return;
                    } else {
                        // why not use this.getIndex?
                        $inputNodes = this.getWrapNodes( $form.find( '[name="' + name + '"]' ).eq( index ) ).find( 'input, select, textarea' );
                        // console.log( 'input nodes with', name, $form.find( '[name="' + name + '"]' ) );
                        type = this.getInputType( $inputNodes.eq( 0 ) );

                        if ( type === 'file' ) {
                            $inputNodes.eq( 0 ).attr( 'data-loaded-file-name', value );
                            // console.error('Cannot set value of file input field (value: '+value+'). If trying to load '+
                            //  'this record for editing this file input field will remain unchanged.');
                            return false;
                        }

                        if ( type === 'date' || type === 'datetime' ) {
                            // convert current value (loaded from instance) to a value that a native datepicker understands
                            // TODO test for IE, FF, Safari when those browsers start including native datepickers
                            value = model.node().convert( value, type );
                        }
                    }

                    if ( this.isMultiple( $inputNodes.eq( 0 ) ) === true ) {
                        value = value.split( ' ' );
                    }

                    // the has-value class enables hiding empty readonly inputs for prettier notes
                    if ( $inputNodes.is( '[readonly]' ) ) {
                        $inputNodes.toggleClass( 'has-value', !!value );
                    }

                    $inputNodes.val( value );

                    return;
                }
            };

            /**
             *  Uses current content of $data to set all the values in the form.
             *  Since not all data nodes with a value have a corresponding input element, it could be considered to turn this
             *  around and cycle through the HTML form elements and check for each form element whether data is available.
             */
            FormView.prototype.setAllVals = function() {
                var index, name, value,
                    that = this;

                model.node( null, null, {
                    noEmpty: true
                } ).get().each( function() {
                    try {
                        value = $( this ).text();
                        name = $( this ).getXPath( 'instance' );
                        index = model.node( name ).get().index( $( this ) );
                        that.input.setVal( name, index, value );
                    } catch ( e ) {
                        console.error( e );
                        loadErrors.push( 'Could not load input field value with name: ' + name + ' and value: ' + value );
                    }
                } );
                return;
            };

            FormView.prototype.langs = {
                init: function() {
                    var lang,
                        that = this,
                        setOptionLangs,
                        defaultLang = $form.find( '#form-languages' ).attr( 'data-default-lang' ),
                        $langSelector = $( '.form-language-selector' );

                    $( '#form-languages' ).detach().appendTo( $langSelector );

                    if ( !defaultLang || defaultLang === '' ) {
                        defaultLang = $( '#form-languages option' ).eq( 0 ).attr( 'value' );
                    }
                    $( '#form-languages' ).val( defaultLang );

                    if ( $( '#form-languages option' ).length < 2 ) {
                        return;
                    }

                    $langSelector.removeClass( 'hide' );

                    $( '#form-languages' ).change( function( event ) {
                        lang = $( this ).val();
                        event.preventDefault();
                        that.setAll( lang );
                    } );
                },
                setAll: function( lang ) {
                    var that = this;
                    $( '#form-languages option' ).removeClass( 'active' );
                    $( this ).addClass( 'active' );

                    $form.find( '[lang]' ).removeClass( 'active' ).filter( '[lang="' + lang + '"], [lang=""]' ).addClass( 'active' );

                    $form.find( 'select' ).each( function() {
                        that.setSelect( $( this ) );
                    } );

                    $form.trigger( 'changelanguage' );
                },
                // swap language of <select> <option>s
                setSelect: function( $select ) {
                    var value, /** @type {string} */ curLabel, /** @type {string} */ newLabel;
                    $select.children( 'option' ).not( '[value=""]' ).each( function() {
                        curLabel = $( this ).text();
                        value = $( this ).attr( 'value' );
                        newLabel = $( this ).parent( 'select' ).siblings( '.or-option-translations' )
                            .children( '.active[data-option-value="' + value + '"]' ).text().trim();
                        newLabel = ( typeof newLabel !== 'undefined' && newLabel.length > 0 ) ? newLabel : curLabel;
                        $( this ).text( newLabel );
                    } );
                }
            };


            FormView.prototype.editStatus = {
                set: function( status ) {
                    $form.attr( 'data-edited', Boolean( status ) );
                    $form.trigger( 'edit', status );
                },
                get: function() {
                    console.log( 'form element', $form );
                    return ( $form.attr( 'data-edited' ) === 'true' ) ? true : false;
                }
            };

            FormView.prototype.recordName = {
                set: function( name ) {
                    $form.attr( 'name', name );
                },
                get: function() {
                    return $form.attr( 'name' );
                }
            };

            /**
             * Crafts an optimized jQuery selector for element attributes that contain an expression with a target node name.
             *
             * @param  {string} attribute The attribute name to search for
             * @param  {?string} filter   The optional filter to append to each selector
             * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
             * @return {jQuery}           A jQuery collection of elements
             */
            FormView.prototype.getNodesToUpdate = function( attr, filter, updated ) {
                var $collection,
                    $repeat = null,
                    selector = [],
                    that = this;

                updated = updated || {};
                filter = filter || '';

                // The collection of non-repeat inputs is cached (unchangeable)
                if ( !this.$nonRepeats[ attr ] ) {
                    this.$nonRepeats[ attr ] = $form.find( filter + '[' + attr + ']' )
                        .closest( '.calculation, .question, .note, .trigger' ).filter( function( index ) {
                            return $( this ).closest( '.or-repeat' ).length === 0;
                        } );
                }

                // If the updated node is inside a repeat (and there are multiple repeats present)
                if ( typeof updated.repeatPath !== 'undefined' && updated.repeatIndex >= 0 ) {
                    $repeat = $form.find( '.or-repeat[name="' + updated.repeatPath + '"]' ).eq( updated.repeatIndex );
                }

                // If the update was triggered from a repeat, it improves performance (a lot)
                // to exclude all those repeats that did not trigger it...
                $collection = ( $repeat ) ? this.$nonRepeats[ attr ].add( $repeat ) : $form;

                if ( !updated.nodes || updated.nodes.length === 0 ) {
                    selector = [ filter + '[' + attr + ']' ];
                } else {
                    updated.nodes.forEach( function( node ) {
                        // The target node name is ALWAYS at the END of a path inside the expression.
                        // #1: followed by space
                        selector.push( filter + '[' + attr + '*="/' + node + ' "]' );
                        // #2: followed by )
                        selector.push( filter + '[' + attr + '*="/' + node + ')"]' );
                        // #3: followed by , if used as first parameter of multiple parameters
                        selector.push( filter + '[' + attr + '*="/' + node + ',"]' );
                        // #4: at the end of an expression
                        selector.push( filter + '[' + attr + '$="/' + node + '"]' );
                        // #5: followed by ] (used in itemset filters)
                        selector.push( filter + '[' + attr + '*="/' + node + ']"]' );
                    } );
                }

                //TODO: exclude descendents of disabled elements? .find( ':not(:disabled) span.active' )
                return $collection.find( selector.join() );
            };

            /**
             * Updates branches
             *
             * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
             */
            FormView.prototype.branchUpdate = function( updated ) {
                var p, $branchNode, result, insideRepeat, insideRepeatClone, cacheIndex, $nodes,
                    relevantCache = {},
                    alreadyCovered = [],
                    that = this,
                    evaluations = 0,
                    clonedRepeatsPresent;

                // console.log( 'branchUpdate', updated );

                $nodes = this.getNodesToUpdate( 'data-relevant', '', updated );

                clonedRepeatsPresent = ( repeatsPresent && $form.find( '.or-repeat.clone' ).length > 0 ) ? true : false;

                $nodes.each( function() {
                    //note that $(this).attr('name') is not the same as p.path for repeated radiobuttons!
                    if ( $.inArray( $( this ).attr( 'name' ), alreadyCovered ) !== -1 ) {
                        return;
                    }
                    p = {};
                    cacheIndex = null;

                    p.relevant = $( this ).attr( 'data-relevant' );
                    p.path = that.input.getName( $( this ) );

                    $branchNode = $( this ).closest( '.or-branch' );

                    if ( $branchNode.length !== 1 ) {
                        if ( $( this ).parents( '#or-calculated-items' ).length === 0 ) {
                            console.error( 'could not find branch node for ', $( this ) );
                        }
                        return;
                    }
                    /* 
                     * Determining ancestry is expensive. Using the knowledge most forms don't use repeats and
                     * if they usually don't have cloned repeats during initialization we perform first a check for .repeat.clone.
                     * The first condition is usually false (and is a very quick one-time check) so this presents a big performance boost
                     * (6-7 seconds of loading time on the bench6 form)
                     */
                    insideRepeat = ( clonedRepeatsPresent && $branchNode.closest( '.or-repeat' ).length > 0 ) ? true : false;
                    insideRepeatClone = ( clonedRepeatsPresent && $branchNode.closest( '.or-repeat.clone' ).length > 0 ) ? true : false;
                    /*
                     * Determining the index is expensive, so we only do this when the branch is inside a cloned repeat.
                     * It can be safely set to 0 for other branches.
                     */
                    p.ind = ( insideRepeatClone ) ? that.input.getIndex( $( this ) ) : 0;
                    /*
                     * Caching is only possible for expressions that do not contain relative paths to nodes.
                     * So, first do a *very* aggresive check to see if the expression contains a relative path.
                     * This check assumes that child nodes (e.g. "mychild = 'bob'") are NEVER used in a relevant
                     * expression, which may prove to be incorrect.
                     */
                    if ( p.relevant.indexOf( '..' ) === -1 ) {
                        /*
                         * For now, let's just not cache relevants inside a repeat.
                         */
                        if ( !insideRepeat ) {
                            cacheIndex = p.relevant;
                        } else {
                            // the path is stripped of the last nodeName to record the context.
                            cacheIndex = p.relevant + '__' + p.path.substring( 0, p.path.lastIndexOf( '/' ) ) + '__' + p.ind;
                        }
                    }
                    if ( cacheIndex && typeof relevantCache[ cacheIndex ] !== 'undefined' ) {
                        result = relevantCache[ cacheIndex ];
                    } else {
                        result = evaluate( p.relevant, p.path, p.ind );
                        evaluations++;
                        relevantCache[ cacheIndex ] = result;
                    }

                    if ( !insideRepeat ) {
                        alreadyCovered.push( $( this ).attr( 'name' ) );
                    }

                    process( $branchNode, result );
                } );

                /**
                 * Evaluates a relevant expression (for future fancy stuff this is placed in a separate function)
                 *
                 * @param  {string} expr        [description]
                 * @param  {string} contextPath [description]
                 * @param  {number} index       [description]
                 * @return {boolean}             [description]
                 */
                function evaluate( expr, contextPath, index ) {
                    var result = model.evaluate( expr, 'boolean', contextPath, index );
                    return result;
                }
                /**
                 * Processes the evaluation result for a branch
                 *
                 * @param  {jQuery} $branchNode [description]
                 * @param  {boolean} result      [description]
                 */
                function process( $branchNode, result ) {
                    // for mysterious reasons '===' operator fails after Advanced Compilation even though result has value true 
                    // and type boolean
                    if ( result === true ) {
                        enable( $branchNode );
                    } else {
                        disable( $branchNode );
                    }
                }
                /**
                 * Checks whether branch currently has 'relevant' state
                 *
                 * @param  {jQuery} $branchNode [description]
                 * @return {boolean}             [description]
                 */
                function selfRelevant( $branchNode ) {
                    return !$branchNode.hasClass( 'disabled' ) && !$branchNode.hasClass( 'pre-init' );
                }
                /**
                 * Enables and reveals a branch node/group
                 *
                 * @param  {jQuery} $branchNode The jQuery object to reveal and enable
                 */
                function enable( $branchNode ) {
                    var type;

                    if ( !selfRelevant( $branchNode ) ) {
                        $branchNode.removeClass( 'disabled pre-init' ).trigger( 'showbranch' );
                        widgets.enable( $branchNode );

                        type = $branchNode.prop( 'nodeName' ).toLowerCase();

                        if ( type === 'label' ) {
                            $branchNode.children( 'input:not(.force-disabled), select, textarea' ).prop( 'disabled', false );
                        } else if ( type === 'fieldset' ) {
                            $branchNode.prop( 'disabled', false );
                            /*
                             * A temporary workaround for a Chrome bug described in https://github.com/modilabs/enketo/issues/503
                             * where the file inputs end up in a weird partially enabled state.
                             * Refresh the state by disabling and enabling the file inputs again.
                             */
                            $branchNode.find( '*:not(.or-branch) input[type="file"]:not(.force-disabled, [data-relevant])' )
                                .prop( 'disabled', true ).prop( 'disabled', false );
                        } else {
                            $branchNode.find( 'fieldset, input, select, textarea' ).prop( 'disabled', false );
                        }
                    }
                }
                /**
                 * Disables and hides a branch node/group
                 *
                 * @param  {jQuery} $branchNode The jQuery object to hide and disable
                 */
                function disable( $branchNode ) {
                    var type = $branchNode.prop( 'nodeName' ).toLowerCase(),
                        virgin = $branchNode.hasClass( 'pre-init' );
                    if ( selfRelevant( $branchNode ) || virgin ) {
                        $branchNode.addClass( 'disabled' ).trigger( 'hidebranch' );

                        // if the branch was previously enabled
                        if ( !virgin ) {
                            $branchNode.clearInputs( 'change' );
                            widgets.disable( $branchNode );
                            // all remaining fields marked as invalid can now be marked as valid
                            $branchNode.find( '.invalid-required, .invalid-constraint' ).find( 'input, select, textarea' ).each( function() {
                                that.setValid( $( this ) );
                            } );
                        } else {
                            $branchNode.removeClass( 'pre-init' );
                        }

                        if ( type === 'label' ) {
                            $branchNode.children( 'input, select, textarea' ).prop( 'disabled', true );
                        } else if ( type === 'fieldset' ) {
                            $branchNode.prop( 'disabled', true );
                        } else {
                            $branchNode.find( 'fieldset, input, select, textarea' ).prop( 'disabled', true );
                        }
                    }
                }
            };


            /**
             * Updates itemsets
             *
             * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
             */
            FormView.prototype.itemsetUpdate = function( updated ) {
                var clonedRepeatsPresent, insideRepeat, insideRepeatClone, $repeat, $nodes,
                    that = this,
                    cleverSelector = [],
                    needToUpdateLangs = false,
                    itemsCache = {};

                // console.log( 'itemsetUpdate', updated );

                $nodes = this.getNodesToUpdate( 'data-items-path', '.itemset-template', updated );

                clonedRepeatsPresent = ( repeatsPresent && $form.find( '.or-repeat.clone' ).length > 0 ) ? true : false;

                $nodes.each( function() {
                    var $htmlItem, $htmlItemLabels, /**@type {string}*/ value, $instanceItems, index, context,
                        $template = $( this ),
                        newItems = {},
                        prevItems = $template.data(),
                        templateNodeName = $( this ).prop( 'nodeName' ).toLowerCase(),
                        $input = ( templateNodeName === 'label' ) ? $( this ).children( 'input' ).eq( 0 ) : $( this ).parent( 'select' ),
                        $labels = $template.closest( 'label, select' ).siblings( '.itemset-labels' ),
                        itemsXpath = $template.attr( 'data-items-path' ),
                        labelType = $labels.attr( 'data-label-type' ),
                        labelRef = $labels.attr( 'data-label-ref' ),
                        valueRef = $labels.attr( 'data-value-ref' );

                    context = that.input.getName( $input );

                    /*
                     * Determining the index is expensive, so we only do this when the itemset is inside a cloned repeat.
                     * It can be safely set to 0 for other branches.
                     */
                    insideRepeat = ( clonedRepeatsPresent && $input.closest( '.or-repeat' ).length > 0 ) ? true : false;
                    insideRepeatClone = ( clonedRepeatsPresent && $input.closest( '.or-repeat.clone' ).length > 0 ) ? true : false;

                    index = ( insideRepeatClone ) ? that.input.getIndex( $input ) : 0;

                    if ( typeof itemsCache[ itemsXpath ] !== 'undefined' ) {
                        $instanceItems = itemsCache[ itemsXpath ];
                    } else {
                        var safeToTryNative = true; // temporary until WGXP
                        $instanceItems = $( model.evaluate( itemsXpath, 'nodes', context, index, safeToTryNative ) );
                        if ( !insideRepeat ) {
                            itemsCache[ itemsXpath ] = $instanceItems;
                        }
                    }

                    // this property allows for more efficient 'itemschanged' detection
                    newItems.length = $instanceItems.length;
                    //this may cause problems for large itemsets. Use md5 instead?
                    newItems.text = $instanceItems.text();

                    if ( newItems.length === prevItems.length && newItems.text === prevItems.text ) {
                        return;
                    }

                    $template.data( newItems );

                    // console.log( 'template node name:', templateNodeName, '$template', $template );

                    // clear data values through inputs. Note: if a value exists, 
                    // this will trigger a dataupdate event which may call this update function again
                    $( this ).closest( '.question' )
                        .clearInputs( 'change' )
                        .find( templateNodeName ).not( $template ).remove();
                    $( this ).parent( 'select' ).siblings( '.or-option-translations' ).empty();

                    $instanceItems.each( function() {
                        $htmlItem = $( '<root/>' );
                        $template
                            .clone().appendTo( $htmlItem )
                            .removeClass( 'itemset-template' )
                            .addClass( 'itemset' )
                            .removeAttr( 'data-items-path' );

                        $htmlItemLabels = ( labelType === 'itext' ) ?
                            $labels.find( '[data-itext-id="' + $( this ).children( labelRef ).text() + '"]' ).clone() :
                            $( '<span class="active" lang="">' + $( this ).children( labelRef ).text() + '</span>' );

                        value = $( this ).children( valueRef ).text();
                        $htmlItem.find( '[value]' ).attr( 'value', value );

                        if ( templateNodeName === 'label' ) {
                            $htmlItem.find( 'input' )
                                .after( $htmlItemLabels );
                            $labels.before( $htmlItem.find( ':first' ) );
                        } else if ( templateNodeName === 'option' ) {
                            if ( $htmlItemLabels.length === 1 ) {
                                $htmlItem.find( 'option' ).text( $htmlItemLabels.text() );
                            }
                            $htmlItemLabels
                                .attr( 'data-option-value', value )
                                .attr( 'data-itext-id', '' )
                                .appendTo( $labels.siblings( '.or-option-translations' ) );
                            $template.siblings().addBack().last().after( $htmlItem.find( ':first' ) );
                        }
                    } );

                    if ( $input.prop( 'nodeName' ).toLowerCase() === 'select' ) {
                        //populate labels (with current language)
                        that.langs.setSelect( $input );
                        //update widget
                        $input.trigger( 'changeoption' );
                    }

                } );
            };

            /**
             * Updates output values, optionally filtered by those values that contain a changed node name
             *
             * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
             */
            FormView.prototype.outputUpdate = function( updated ) {
                var expr, clonedRepeatsPresent, insideRepeat, insideRepeatClone, $context, context, index, $nodes,
                    outputCache = {},
                    val = '',
                    that = this;

                // console.log( 'outputUpdate', updated );

                $nodes = this.getNodesToUpdate( 'data-value', '.or-output', updated );

                clonedRepeatsPresent = ( repeatsPresent && $form.find( '.or-repeat.clone' ).length > 0 ) ? true : false;

                $nodes.each( function() {
                    expr = $( this ).attr( 'data-value' );
                    /*
                     * Note that in XForms input is the parent of label and in HTML the other way around so an output inside a label
                     * should look at the HTML input to determine the context.
                     * So, context is either the input name attribute (if output is inside input label),
                     * or the parent with a name attribute
                     * or the whole document
                     */
                    $context = ( $( this ).parent( 'span' ).parent( 'label' ).find( '[name]' ).eq( 0 ).length === 1 ) ?
                        $( this ).parent().parent().find( '[name]' ).eq( 0 ) :
                        $( this ).parent( 'span' ).parent( 'legend' ).parent( 'fieldset' ).find( '[name]' ).eq( 0 ).length === 1 ?
                        $( this ).parent().parent().parent().find( '[name]' ).eq( 0 ) : $( this ).closest( '[name]' );
                    context = that.input.getName( $context );
                    insideRepeat = ( clonedRepeatsPresent && $( this ).closest( '.or-repeat' ).length > 0 );
                    insideRepeatClone = ( clonedRepeatsPresent && $( this ).closest( '.or-repeat.clone' ).length > 0 );
                    index = ( insideRepeatClone ) ? that.input.getIndex( $context ) : 0;

                    if ( typeof outputCache[ expr ] !== 'undefined' ) {
                        val = outputCache[ expr ];
                    } else {
                        val = model.evaluate( expr, 'string', context, index );
                        if ( !insideRepeat ) {
                            outputCache[ expr ] = val;
                        }
                    }
                    if ( $( this ).text !== val ) {
                        $( this ).text( val );
                    }
                } );
            };

            /**
             * See https://groups.google.com/forum/?fromgroups=#!topic/opendatakit-developers/oBn7eQNQGTg
             * and http://code.google.com/p/opendatakit/issues/detail?id=706
             *
             * Once the following is complete this function can and should be removed:
             *
             * 1. ODK Collect starts supporting an instanceID preload item (or automatic handling of meta->instanceID without binding)
             * 2. Pyxforms changes the instanceID binding from calculate to preload (or without binding)
             * 3. Formhub has re-generated all stored XML forms from the stored XLS forms with the updated pyxforms
             *
             */
            FormView.prototype.grosslyViolateStandardComplianceByIgnoringCertainCalcs = function() {
                var $culprit = $form.find( '[name$="/meta/instanceID"][data-calculate]' );
                if ( $culprit.length > 0 ) {
                    //console.log( "Found meta/instanceID with binding that has a calculate attribute and removed this calculation. It ain't right!" );
                    $culprit.removeAttr( 'data-calculate' );
                }
            };

            /**
             * Updates calculated items
             *
             * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
             * @param { jQuery=}         $repeat        The repeat that triggered the update
             * @param {Array<string>=}  updatedNodes    Array of updated nodes
             */
            FormView.prototype.calcUpdate = function( updated ) {
                var $nodes,
                    that = this;

                updated = updated || {};

                // console.log( 'calcUpdate', updated );

                $nodes = this.getNodesToUpdate( 'data-calculate', '', updated );

                // add relevant items that have a (any) calculation
                $nodes = $nodes.add( this.getNodesToUpdate( 'data-relevant', '[data-calculate]', updated ) );

                $nodes.each( function() {
                    var result, valid, $dataNodes, $dataNode, index,
                        $this = $( this ),
                        name = $this.attr( 'name' ),
                        dataNodeName = ( name.lastIndexOf( '/' ) !== -1 ) ? name.substring( name.lastIndexOf( '/' ) + 1 ) : name,
                        expr = $this.attr( 'data-calculate' ),
                        dataType = $this.attr( 'data-type-xml' ),
                        // for inputs that have a calculation and need to be validated
                        constraint = $this.attr( 'data-constraint' ),
                        relevantExpr = $this.attr( 'data-relevant' ),
                        relevant = ( relevantExpr ) ? model.evaluate( relevantExpr, 'boolean', name ) : true;

                    /*
                     * If the update was triggered by a datanode inside a repeat
                     * and the dependent node is inside the same repeat
                     */
                    $dataNodes = model.node( name ).get();

                    if ( $dataNodes.length > 1 && updated.repeatPath && name.indexOf( updated.repeatPath ) !== -1 ) {
                        $dataNode = model.node( updated.repeatPath, updated.repeatIndex ).get().find( dataNodeName );
                        index = $dataNodes.index( $dataNode );
                    } else if ( $dataNodes.length === 1 ) {
                        index = 0;
                    } else {
                        console.error( 'Potential issue: Multiple data nodes with same path found. Cannot deal with this and will just ignore them. ', $dataNodes );
                        return;
                    }

                    //not sure if using 'string' is always correct
                    expr = fixExpr( expr, 'string', name, index );

                    // it is possible that the fixed expr is '' which causes an error in XPath
                    result = ( relevant && expr ) ? model.evaluate( expr, 'string', name, index ) : '';
                    valid = model.node( name, index ).setVal( result, constraint, dataType );

                    // not the most efficient to use input.setVal here as it will do another lookup
                    // of the node, that we already have...
                    that.input.setVal( name, index, result );
                } );
            };

            FormView.prototype.bootstrapify = function() {
                //if no constraintmessage use a default
                //TODO: move to XSLT
                $form.addClass( 'clearfix' )
                    .find( 'label, legend' ).each( function() {
                        var $label = $( this );
                        if ( $label.parent( '.option-wrapper' ).length === 0 &&
                            $label.parent( '#or-calculated-items, #or-preload-items' ).length === 0 &&
                            $label.find( '.or-constraint-msg' ).length === 0 &&
                            ( $label.prop( 'nodeName' ).toLowerCase() == 'legend' ||
                                $label.children( 'input.ignore' ).length !== $label.children( 'input' ).length ||
                                $label.children( 'select.ignore' ).length !== $label.children( 'select' ).length ||
                                $label.children( 'textarea.ignore' ).length !== $label.children( 'textarea' ).length ) ) {
                            $label.prepend( '<span class="or-constraint-msg active" lang="">Value not allowed</span>' );
                        }
                    } );

                //move constraint message to bottom of question and add message for required (could also be done in XSLT)
                //TODO: move to XSLT
                $form.find( '.or-constraint-msg' ).each( function() {
                    var $question = $( this ).closest( '.question' ).not( '.or-appearance-label' ),
                        $constraintMsg = $( this ).detach(),
                        isRequired = $question.find( '[required]' ).length > 0,
                        hasRequiredMsg = $question.find( '.or-required-msg' ).length > 0;

                    $question.append( $constraintMsg );
                    if ( !hasRequiredMsg && isRequired ) {
                        $constraintMsg.after( '<span class="or-required-msg active" lang="">This field is required</span>' );
                    }
                } );

                // took a shortcut, but this should actually move to its own 'horizontal-choices-widget'
                // even better to move to XSLT
                $form.find( '.or-appearance-horizontal .option-wrapper' ).each( function() {
                    var $wrapper = $( this ),
                        $options = $wrapper.find( 'label' );

                    if ( ( $options.length % 3 ) === 2 ) {
                        $wrapper.append( '<label class="filler"></label>' );
                    }
                } );

            };

            /*
             * Note that preloaders may be deprecated in the future and be handled as metadata without bindings at all, in which
             * case all this stuff should perhaps move to FormModel
             *
             * functions are designed to fail silently if unknown preloaders are called
             */
            FormView.prototype.preloads = {
                init: function( parentO ) {
                    var item, param, name, curVal, newVal, meta, dataNode, props, xmlType,
                        that = this;
                    //these initialize actual preload items
                    $form.find( '#or-preload-items input' ).each( function() {
                        props = parentO.input.getProps( $( this ) );
                        item = $( this ).attr( 'data-preload' ).toLowerCase();
                        param = $( this ).attr( 'data-preload-params' ).toLowerCase();

                        if ( typeof that[ item ] !== 'undefined' ) {
                            dataNode = model.node( props.path, props.index );
                            curVal = dataNode.getVal()[ 0 ];
                            newVal = that[ item ]( {
                                param: param,
                                curVal: curVal,
                                dataNode: dataNode
                            } );
                            dataNode.setVal( newVal, null, props.xmlType );
                        } else {
                            console.error( 'Preload "' + item + '"" not supported. May or may not be a big deal.' );
                        }
                    } );
                    // In addition the presence of certain meta data in the instance may automatically trigger a preload function
                    // even if the binding is not present. Note, that this actually does not deal with HTML elements at all.
                    meta = model.node( '*>meta>*' );
                    meta.get().each( function() {
                        item = null;
                        name = $( this ).prop( 'nodeName' );
                        dataNode = model.node( '*>meta>' + name );
                        curVal = dataNode.getVal()[ 0 ];
                        //first check if there isn't a binding with a preloader that already took care of this
                        if ( $form.find( '#or-preload-items input[name$="/meta/' + name + '"][data-preload]' ).length === 0 ) {
                            switch ( name ) {
                                case 'instanceID':
                                    item = 'instance';
                                    xmlType = 'string';
                                    param = '';
                                    break;
                                case 'timeStart':
                                    item = 'timestamp';
                                    xmlType = 'datetime';
                                    param = 'start';
                                    break;
                                case 'timeEnd':
                                    item = 'timestamp';
                                    xmlType = 'datetime';
                                    param = 'end';
                                    break;
                                case 'deviceID':
                                    item = 'property';
                                    xmlType = 'string';
                                    param = 'deviceid';
                                    break;
                                case 'userID':
                                    item = 'property';
                                    xmlType = 'string';
                                    param = 'username';
                                    break;
                            }
                        }
                        if ( item ) {
                            dataNode.setVal( that[ item ]( {
                                param: param,
                                curVal: curVal,
                                dataNode: dataNode
                            } ), null, xmlType );
                        }
                    } );
                },
                'timestamp': function( o ) {
                    var value,
                        that = this;
                    // when is 'start' or 'end'
                    if ( o.param == 'start' ) {
                        return ( o.curVal.length > 0 ) ? o.curVal : model.evaluate( 'now()', 'string' );
                    }
                    if ( o.param == 'end' ) {
                        //set event handler for each save event (needs to be triggered!)
                        $form.on( 'beforesave', function() {
                            value = model.evaluate( 'now()', 'string' );
                            o.dataNode.setVal( value, null, 'datetime' );
                        } );
                        return model.evaluate( 'now()', 'string' );
                    }
                    return 'error - unknown timestamp parameter';
                },
                'date': function( o ) {
                    var today, year, month, day;

                    if ( o.curVal.length === 0 ) {
                        today = new Date( model.evaluate( 'today()', 'string' ) );
                        year = today.getFullYear().toString().pad( 4 );
                        month = ( today.getMonth() + 1 ).toString().pad( 2 );
                        day = today.getDate().toString().pad( 2 );

                        return year + '-' + month + '-' + day;
                    }
                    return o.curVal;
                },
                'property': function( o ) {
                    var readCookie, noSupportMsg, response;

                    readCookie = function( name, c, C, i ) {
                        if ( cookies ) {
                            return cookies[ name ];
                        }

                        c = document.cookie.split( '; ' );
                        cookies = {};

                        for ( i = c.length - 1; i >= 0; i-- ) {
                            C = c[ i ].split( '=' );
                            cookies[ C[ 0 ] ] = decodeURIComponent( C[ 1 ] );
                        }

                        return cookies[ name ];
                    };

                    // 'deviceid', 'subscriberid', 'simserial', 'phonenumber'
                    if ( o.curVal.length === 0 ) {
                        noSupportMsg = 'no ' + o.param + ' property in enketo';
                        switch ( o.param ) {
                            case 'deviceid':
                                response = readCookie( '__enketo_meta_deviceid' ) || 'Error: could not determine deviceID';
                                break;
                            case 'username':
                                response = readCookie( '__enketo_meta_uid' );
                                break;
                            default:
                                response = noSupportMsg;
                                break;
                        }
                        return response;
                    }
                    return o.curVal;
                },
                'context': function( o ) {
                    // 'application', 'user'??
                    if ( o.curVal.length === 0 ) {
                        return ( o.param == 'application' ) ? 'enketo' : o.param + ' not supported in enketo';
                    }
                    return o.curVal;
                },
                'patient': function( o ) {
                    if ( o.curVal.length === 0 ) {
                        return 'patient preload not supported in enketo';
                    }
                    return o.curVal;
                },
                'user': function( o ) {
                    //uuid, user_id, user_type
                    //if (o.param == 'uuid'){
                    //  return (o.curVal.length > 1) ? o.curVal : model.evaluate('uuid()', 'string');
                    //}
                    if ( o.curVal.length === 0 ) {
                        return 'user preload item not supported in enketo yet';
                    }
                    return o.curVal;
                },
                'uid': function( o ) {
                    //general 
                    if ( o.curVal.length === 0 ) {
                        return 'no uid yet in enketo';
                    }
                    return o.curVal;
                },
                'browser': function( o ) {
                    /*if (o.curVal.length === 0){
                    if (o.param == 'name'){ 
                    var a = ($.browser.webkit) ? 'webkit' : ($.browser.mozilla) ? 'mozilla' : ($.browser.opera) ? 'opera' : ($.browser.msie) ? 'msie' : 'unknown';
                    //console.debug(a);
                    return a;
                    }
                    if (o.param == 'version'){
                    return $.browser.version;
                    }
                    return o.param+' not supported in enketo';
                    }
                    return o.curVal;*/
                },
                'os': function( o ) {
                    if ( o.curVal.length === 0 ) {
                        return 'not known';
                    }
                    return o.curVal;
                },
                //Not according to spec yet, this will be added to spec but name may change
                'instance': function( o ) {
                    var id = ( o.curVal.length > 0 ) ? o.curVal : model.evaluate( "concat('uuid:', uuid())", 'string' );
                    //store the current instanceID as data on the form element so it can be easily accessed by e.g. widgets
                    $form.data( {
                        instanceID: id
                    } );
                    return id;
                }
            };

            /**
             * Variable: repeat
             *
             * This can perhaps be simplified and improved by:
             * - adding a function repeat.update() that looks at the instance whether to add repeat form fields
             * - calling update from init() (model.init() is called before form.init() so the initial repeats have been added already)
             * - when button is clicked model.node().clone() or model.node().remove() is called first and then repeat.update()
             * - watch out though when repeats in the middle are removed... or just disable that possibility
             *
             */
            FormView.prototype.repeat = {
                /**
                 * Initializes all Repeat Groups in form (only called once).
                 * @param  {FormView} formO the parent form object
                 */
                init: function( formO ) {
                    var i, numRepsInCount, repCountPath, numRepsInInstance, numRepsDefault, cloneDefaultReps, repLevel, $dataRepeat, index,
                        that = this;

                    this.formO = formO;
                    $form.find( '.or-repeat' ).prepend( '<span class="repeat-number"></span>' );
                    $form.find( '.or-repeat:not([data-repeat-fixed])' )
                        .append( '<div class="repeat-buttons"><button type="button" class="btn btn-default repeat"><i class="glyphicon glyphicon-plus"> </i></button>' +
                            '<button type="button" disabled class="btn btn-default remove"><i class="glyphicon glyphicon-minus"> </i></button></div>' );

                    //delegated handlers (strictly speaking not required, but checked for doubling of events -> OK)
                    $form.on( 'click', 'button.repeat:enabled', function() {
                        // Create a clone
                        that.clone( $( this ).closest( '.or-repeat' ) );
                        // Prevent default
                        return false;
                    } );
                    $form.on( 'click', 'button.remove:enabled', function() {
                        //remove clone
                        that.remove( $( this ).closest( '.or-repeat.clone' ) );
                        //prevent default
                        return false;
                    } );

                    cloneDefaultReps = function( $repeat ) {
                        repLevel++;
                        repCountPath = $repeat.attr( 'data-repeat-count' ) || "";
                        numRepsInCount = ( repCountPath.length > 0 ) ? parseInt( model.node( repCountPath ).getVal()[ 0 ], 10 ) : 0;
                        // console.debug('number of reps in count attribute: ' +numRepsInCount);
                        index = $form.find( '.or-repeat[name="' + $repeat.attr( 'name' ) + '"]' ).index( $repeat );
                        $dataRepeat = model.node( $repeat.attr( 'name' ), index ).get();
                        numRepsInInstance = $dataRepeat.siblings( $dataRepeat.prop( 'nodeName' ) + ':not([template])' ).addBack().length;
                        numRepsDefault = ( numRepsInCount > numRepsInInstance ) ? numRepsInCount : numRepsInInstance;
                        // console.debug('default number of repeats for '+$repeat.attr('name')+' is '+numRepsDefault);
                        // First rep is already included (by XSLT transformation)
                        for ( i = 1; i < numRepsDefault; i++ ) {
                            that.clone( $repeat.siblings().addBack().last(), false );
                        }
                        //now check the defaults of all the descendants of this repeat and its new siblings, level-by-level
                        $repeat.siblings( '.or-repeat' ).addBack().find( '.or-repeat' )
                            .filter( function( i ) {
                                return $( this ).parents( '.or-repeat' ).length === repLevel;
                            } ).each( function() {
                                cloneDefaultReps( $( this ) );
                            } );
                    };

                    //clone form fields to create the default number 
                    //NOTE THIS ASSUMES THE DEFAULT NUMBER IS STATIC, NOT DYNAMIC
                    $form.find( '.or-repeat' ).filter( function( i ) {
                        return $( this ).parents( '.or-repeat' ).length === 0;
                    } ).each( function() {
                        repLevel = 0;
                        cloneDefaultReps( $( this ) );
                    } );
                },
                /**
                 * clone a repeat group/node
                 * @param   {jQuery} $node node to clone
                 * @param   {boolean=} animate whether to animate the cloning
                 * @return  {boolean}       [description]
                 */
                clone: function( $node, animate ) {
                    //var p = new Profiler('repeat cloning');
                    var $master, $clone, $parent, index, radioNames, i, path, timestamp, duration,
                        that = this;

                    duration = ( animate === false ) ? 0 : 400;
                    if ( $node.length !== 1 ) {
                        console.error( 'Nothing to clone' );
                        return false;
                    }
                    $parent = $node.parent( '.or-group, .or-group-data' );
                    $master = $parent.children( '.or-repeat:not(.clone)' ).eq( 0 );
                    $clone = $master.clone( true, true );

                    // Add clone class and remove any child clones.. (cloned repeats within repeats..)
                    $clone.addClass( 'clone' ).find( '.clone' ).remove();

                    // Mark all cloned fields as valid
                    $clone.find( '.invalid-required, .invalid-constraint' ).find( 'input, select, textarea' ).each( function() {
                        that.formO.setValid( $( this ) );
                    } );

                    $clone.insertAfter( $node )
                        .parent( '.or-group' ).numberRepeats();

                    $clone.clearInputs( '' );

                    // Note: in http://formhub.org/formhub_u/forms/hh_polio_survey_cloned/form.xml a parent group of a repeat
                    // has the same ref attribute as the nodeset attribute of the repeat. This would cause a problem determining 
                    // the proper index if .or-repeat was not included in the selector
                    index = $form.find( '.or-repeat[name="' + $node.attr( 'name' ) + '"]' ).index( $node );
                    // add ____x to names of radio buttons where x is the index
                    radioNames = [];

                    $clone.find( 'input[type="radio"]' ).each( function() {
                        if ( $.inArray( $( this ).attr( 'data-name' ), radioNames ) === -1 ) {
                            radioNames.push( $( this ).attr( 'data-name' ) );
                        }
                    } );

                    for ( i = 0; i < radioNames.length; i++ ) {
                        // Amazingly, this executes so fast when compiled that the timestamp in milliseconds is
                        // not sufficient guarantee of uniqueness (??)
                        timestamp = new Date().getTime().toString() + '_' + Math.floor( ( Math.random() * 10000 ) + 1 );
                        $clone.find( 'input[type="radio"][data-name="' + radioNames[ i ] + '"]' ).attr( 'name', timestamp );
                    }

                    this.toggleButtons( $master.parent() );

                    // Create a new data point in <instance> by cloning the template node
                    // and clone data node if it doesn't already exist
                    path = $master.attr( 'name' );
                    if ( path.length > 0 && index >= 0 ) {
                        model.cloneTemplate( path, index );
                    }

                    // this will trigger setting default values and other stuff
                    $clone.trigger( 'addrepeat', index + 1 );

                    // Re-initiate widgets in clone after default values have been set
                    widgets.destroy( $clone );
                    widgets.init( $clone );

                    //p.report();
                    return true;
                },
                remove: function( $repeat ) {
                    var delay = 600, // dataNode,
                        that = this,
                        $prev = $repeat.prev( '.or-repeat' ),
                        repeatPath = $repeat.attr( 'name' ),
                        repeatIndex = $form.find( '.or-repeat[name="' + repeatPath + '"]' ).index( $repeat ),
                        $parentGroup = $repeat.parent( '.or-group' );

                    $repeat.hide( delay, function() {
                        $repeat.remove();
                        $parentGroup.numberRepeats();
                        that.toggleButtons( $parentGroup );
                        // trigger the removerepeat on the previous repeat (always present)
                        // so that removerepeat handlers know where the repeat was removed
                        $prev.trigger( 'removerepeat' );
                        //now remove the data node
                        model.node( repeatPath, repeatIndex ).remove();
                    } );
                },
                toggleButtons: function( $node ) {
                    $node = ( typeof $node == 'undefined' || $node.length === 0 || !$node ) ? $node = $form : $node;

                    //first switch everything off and remove hover state
                    $node.find( 'button.repeat, button.remove' ).prop( 'disabled', true ); //button('disable').removeClass('ui-state-hover');

                    //then enable the appropriate ones
                    $node.find( '.or-repeat:last-child > .repeat-buttons button.repeat' ).prop( 'disabled', false ); //.button('enable');
                    $node.find( 'button.remove' ).not( ':eq(0)' ).prop( 'disabled', false );
                }
            };

            FormView.prototype.setEventHandlers = function() {
                var that = this;

                //first prevent default submission, e.g. when text field is filled in and Enter key is pressed
                $form.attr( 'onsubmit', 'return false;' );

                /* 
                 * workaround for Chrome to clear invalid values right away
                 * issue: https://code.google.com/p/chromium/issues/detail?can=2&start=0&num=100&q=&colspec=ID%20Pri%20M%20Iteration%20ReleaseBlock%20Cr%20Status%20Owner%20Summary%20OS%20Modified&groupby=&sort=&id=178437)
                 * a workaround was chosen instead of replacing the change event listener to a blur event listener
                 * because I'm guessing that Google will bring back the old behaviour.
                 */
                $form.on( 'blur', 'input:not([type="text"], [type="radio"], [type="checkbox"])', function( event ) {
                    if ( typeof $( this ).prop( 'validity' ).badInput !== 'undefined' && $( this ).prop( 'validity' ).badInput ) {
                        $( this ).val( '' );
                    }
                } );

                // why is the file namespace added
                $form.on( 'change.file validate', 'input:not(.ignore), select:not(.ignore), textarea:not(.ignore)', function( event ) {
                    var validCons, validReq,
                        n = that.input.getProps( $( this ) );

                    // why is this called? add explanation when figured out that it is necessary!
                    // event.stopImmediatePropagation();

                    // set file input values to the actual name of file (without c://fakepath or anything like that)
                    if ( n.val.length > 0 && n.inputType === 'file' && $( this )[ 0 ].files[ 0 ] && $( this )[ 0 ].files[ 0 ].size > 0 ) {
                        n.val = $( this )[ 0 ].files[ 0 ].name;
                    }

                    if ( event.type === 'validate' ) {
                        // the enabled check serves a purpose only when an input field itself is marked as enabled but its parent fieldset is not
                        // if an element is disabled mark it as valid (to undo a previously shown branch with fields marked as invalid)
                        validCons = ( n.enabled && n.inputType !== 'hidden' ) ? model.node( n.path, n.ind ).validate( n.constraint, n.xmlType ) : true;
                    } else {
                        validCons = model.node( n.path, n.ind ).setVal( n.val, n.constraint, n.xmlType );
                        // geotrace and geoshape are very complex data types that require various change events
                        // to avoid annoying users, we ignore the INVALID onchange validation result
                        validCons = ( validCons === false && ( n.xmlType === 'geotrace' || n.xmlType === 'geoshape' ) ) ? null : validCons;
                    }

                    // validate 'required', checking value in Model (not View)
                    validReq = ( n.enabled && n.inputType !== 'hidden' && n.required && model.node( n.path, n.ind ).getVal()[ 0 ].length < 1 ) ? false : true;

                    if ( validReq === false ) {
                        that.setValid( $( this ), 'constraint' );
                        if ( event.type === 'validate' ) {
                            that.setInvalid( $( this ), 'required' );
                        }
                    } else {
                        that.setValid( $( this ), 'required' );
                        if ( typeof validCons !== 'undefined' && validCons === false ) {
                            that.setInvalid( $( this ), 'constraint' );
                        } else if ( validCons !== null ) {
                            that.setValid( $( this ), 'constraint' );
                        }
                    }
                } );

                // doing this on the focus event may have little effect on performance, because nothing else is happening :)
                $form.on( 'focus fakefocus', 'input:not(.ignore), select:not(.ignore), textarea:not(.ignore)', function( event ) {
                    // update the form progress status
                    that.progress.update( event.target );
                } );

                //using fakefocus because hidden (by widget) elements won't get focus
                $form.on( 'focus blur fakefocus fakeblur', 'input:not(.ignore), select:not(.ignore), textarea:not(.ignore)', function( event ) {
                    var props = that.input.getProps( $( this ) ),
                        required = $( this ).attr( 'required' ),
                        $question = $( this ).closest( '.question' ),
                        $legend = $question.find( 'legend' ).eq( 0 ),
                        loudErrorShown = $question.hasClass( 'invalid-required' ) || $question.hasClass( 'invalid-constraint' ),
                        insideTable = ( $( this ).closest( '.or-appearance-list-nolabel' ).length > 0 ),
                        $reqSubtle = $question.find( '.required-subtle' ),
                        reqSubtle = $( '<span class="required-subtle" style="color: transparent;">Required</span>' );

                    if ( event.type === 'focusin' || event.type === "fakefocus" ) {
                        $question.addClass( 'focus' );
                        if ( required && $reqSubtle.length === 0 && !insideTable ) {
                            $reqSubtle = $( reqSubtle );

                            if ( $legend.length > 0 ) {
                                $legend.append( $reqSubtle );
                            } else {
                                $reqSubtle.insertBefore( this );
                            }

                            if ( !loudErrorShown ) {
                                $reqSubtle.show( function() {
                                    $( this ).removeAttr( 'style' );
                                } );
                            }
                        } else if ( !loudErrorShown ) {
                            //$question.addClass( 'focus' );
                        }
                    } else if ( event.type === 'focusout' || event.type === 'fakeblur' ) {
                        $question.removeClass( 'focus' );
                        if ( required && props.val.length > 0 ) {
                            $reqSubtle.remove();
                        } else if ( !loudErrorShown ) {
                            $reqSubtle.removeAttr( 'style' );
                        }
                    }
                } );

                model.$.on( 'dataupdate', function( event, updated ) {
                    // console.log( 'dataupdate', updated );
                    that.calcUpdate( updated ); //EACH CALCUPDATE THAT CHANGES A VALUE TRIGGERS ANOTHER CALCUPDATE => INEFFICIENT
                    that.branchUpdate( updated );
                    that.outputUpdate( updated );
                    that.itemsetUpdate( updated );
                } );

                // edit is fired when the form changes due to user input or repeats added/removed
                // branch update doesn't require detection as it always happens as a result of an event that triggers change or changerepeat.
                $form.on( 'change addrepeat removerepeat', function( event ) {
                    that.editStatus.set( true );
                } );

                $form.on( 'addrepeat', function( event, index ) {
                    var $clone = $( event.target );
                    // Set defaults of added repeats in FormView, setAllVals does not trigger change event
                    that.setAllVals( $clone );
                    // for a NEW repeat ALL calculations inside that repeat have to be initialized
                    that.calcUpdate( {
                        repeatPath: $clone.attr( 'name' ),
                        repeatIndex: index
                    } );
                } );

                $form.on( 'changelanguage', function() {
                    that.outputUpdate();
                } );
            };

            FormView.prototype.setValid = function( $node, type ) {
                var classes = ( type ) ? 'invalid-' + type : 'invalid-constraint invalid-required';
                this.input.getWrapNodes( $node ).removeClass( classes );
            };

            FormView.prototype.setInvalid = function( $node, type ) {
                type = type || 'constraint';
                this.input.getWrapNodes( $node ).addClass( 'invalid-' + type ).find( '.required-subtle' ).attr( 'style', 'color: transparent;' );
            };

            /**
             * Validates all enabled input fields after first resetting everything as valid.
             * @return {boolean} whether the form contains any errors
             */
            FormView.prototype.validateAll = function() {
                var that = this,
                    $firstError;

                //can't fire custom events on disabled elements therefore we set them all as valid
                $form.find( 'fieldset:disabled input, fieldset:disabled select, fieldset:disabled textarea, ' +
                    'input:disabled, select:disabled, textarea:disabled' ).each( function() {
                    that.setValid( $( this ) );
                } );
                $form.find( 'input, select, textarea' ).not( '.ignore' ).trigger( 'validate' );
                $firstError = $form.find( '.invalid-required, .invalid-constraint' ).eq( 0 );
                if ( $firstError.length > 0 && window.scrollTo ) {
                    if ( this.pages.active ) {
                        // move to the first page with an error
                        this.pages.flipToPageContaining( $firstError );
                    }
                    window.scrollTo( 0, $firstError.offset().top - 50 );
                }
                return $firstError.length === 0;
            };

            /**
             * Maintains progress state of user traversing through form, using
             * currently focused input || last changed input as current location.
             */
            FormView.prototype.progress = {
                status: 0,
                lastChanged: null,
                // updates rounded % value of progress and triggers event if changed
                update: function( el ) {
                    var status,
                        $all = $form.find( '.question' ).not( '.disabled' ).filter( function() {
                            return $( this ).closest( '.disabled' ).length === 0;
                        } );
                    this.lastChanged = el || this.lastChanged;
                    status = Math.round( ( ( $all.index( $( this.lastChanged ).closest( '.question' ) ) + 1 ) * 100 ) / $all.length );

                    if ( status !== this.status ) {
                        this.status = status;
                        $form.trigger( 'progressupdate', status );
                    }
                },
                get: function() {
                    return this.status;
                }
            };

            /**
             * Returns true is form is valid and false if not. Needs to be called AFTER (or by) validateAll()
             * @return {!boolean} whether the form is valid
             */
            FormView.prototype.isValid = function() {
                return ( $form.find( '.invalid-required, .invalid-constraint' ).length > 0 ) ? false : true;
            };

            /**
             * Adds <hr class="page-break"> to prevent cutting off questions with page-breaks
             */
            FormView.prototype.addPageBreaks = function() {

            };
        }

        return Form;
    } );

requirejs.config( {
    baseUrl: "../lib",
    paths: {
        "enketo-js": "../src/js",
        "enketo-widget": "../src/widget",
        "enketo-config": "../config.json",
        "text": "text/text",
        "xpath": "xpath/build/xpathjs_javarosa",
        "file-manager": "file-manager/src/file-manager",
        "jquery.xpath": "jquery-xpath/jquery.xpath",
        "jquery.touchswipe": "jquery-touchswipe/jquery.touchSwipe",
        "leaflet": "leaflet/leaflet",
        "bootstrap-slider": "bootstrap-slider/js/bootstrap-slider"
    },
    shim: {
        "xpath": {
            exports: "XPathJS"
        },
        "bootstrap": {
            deps: [ "jquery" ],
            exports: "jQuery.fn.popover"
        },
        "widget/date/bootstrap3-datepicker/js/bootstrap-datepicker": {
            deps: [ "jquery" ],
            exports: "jQuery.fn.datepicker"
        },
        "widget/time/bootstrap3-timepicker/js/bootstrap-timepicker": {
            deps: [ "jquery" ],
            exports: "jQuery.fn.timepicker"
        },
        "Modernizr": {
            exports: "Modernizr"
        },
        "leaflet": {
            exports: "L"
        }
    }
} );

var loadEnketo = function(options){
    var localStore = options.localStore;

    requirejs( [ 'jquery', 'Modernizr', 'enketo-js/Form'],
    function( $, Modernizr, Form) {
        var loadErrors;
        var global_data;
        //if querystring touch=true is added, override Modernizr
        if ( getURLParameter( 'touch' ) === 'true' ) {
            Modernizr.touch = true;
            $( 'html' ).addClass( 'touch' );
        }

        localStore.getProjectById(options.project_uuid).then(function(project){
            var data = project.xform;
            var edit_xml = "";
            
            var submissionPromise;
            if(options.isServerSubmission)
                submissionPromise = options.getSubmissionFromServer(options.submission_id);
            else
                submissionPromise = localStore.getSubmissionById(options.submission_id);

            submissionPromise.then(function(submission){
                if(options.submission_id != "null"){
                    edit_xml = submission.xml;
                }
                $( '.guidance' ).remove();
                data = data.replace( /jr\:template=/gi, 'template=' );
                $data = $( $.parseXML( data ) );
                $($data.find( 'form:eq(0)' )[0]).find("#form-title").remove();
                formStr = ( new XMLSerializer() ).serializeToString( $data.find( 'form:eq(0)' )[ 0 ] );
                modelStr = ( new XMLSerializer() ).serializeToString( $data.find( 'model:eq(0)' )[ 0 ] );
                $( '#validate-form' ).before( formStr );
                initializeForm(edit_xml);
            });
        });

        //validate handler for validate button

        var button = $( '#validate-form' );
        if(options.isServerSubmission)
            button.hide();

        button.html(options.buttonLabel);
        button.on( 'click', function() {
            form.validate();
            if ( !form.isValid() ) {
                options.onError('error!!!');
            } else {
                    var submission = {};
                    submission.project_uuid = options.project_uuid;
                    submission.xml = form.getDataStr();

                    var parsedData = xmlToJson.xml_str2json(submission.xml);
                    for(k in parsedData) // this will loop once
                        var json_data = parsedData[k];

                    delete json_data.meta;

                    var value;
                    // TODO update to support repeat inside group
                    for (var dataIndex in json_data) {
                        value = json_data[dataIndex];
                        // hack to make single repeat data in array as xml_to_json for single child converts to object than object array
                        if (typeof value == "object" && !(value instanceof Array))
                            json_data[dataIndex] = [value];
                    };

                    submission.data = JSON.stringify(json_data);
                    submission.created = options.getDate();

                    if (options.submission_id == 'null') {
                        localStore.createSubmission(submission).then(function(submission) {
                            form.resetView();
                            initializeForm("");
                            options.onSuccess('Saved');
                        }, function(error) {
                            console.log(error);
                        });
                    } else {
                        localStore.updateSubmission(options.submission_id, submission).then(function() {
                            options.onSuccess('Updated');
                            options.redirect("/submission-list/" + options.project_uuid);
                        }, function(error) {
                            console.log(error);
                        }); 
                    }
            }

          });

        //initialize the form

        function initializeForm(dataStrToEdit ) {
            form = new Form( 'form.or:eq(0)', modelStr, dataStrToEdit );
            //for debugging
            window.form = form;
            //initialize form and check for load errors
            loadErrors = form.init();
            if ( loadErrors.length > 0 ) {
                alert( 'loadErrors: ' + loadErrors.join( ', ' ) );
            }
        }

        //get query string parameter

        function getURLParameter( name ) {
            return decodeURI(
                ( RegExp( name + '=' + '(.+?)(&|$)' ).exec( location.search ) || [ , null ] )[ 1 ]
            );
        }
    });
};

define("../app", function(){});

/**
 * @preserve Copyright 2012 Silvio Moreto, Martijn van de Rijdt & Modilabs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-js/Widget',[ 'jquery' ], function( $ ) {

    /**
     * A Widget class that can be extended to provide some of the basic widget functionality out of the box.
     * pattern: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
     *
     * @constructor
     * @param {Element} element The DOM element the widget is applied on
     * @param {(boolean|{touch: boolean})} options Options passed to the widget during instantiation
     * @param {string} event Not sure, this may not be necessary but the desktopSelectpicker does something with it
     */
    var Widget = function( element, options, event ) {
        this.element = element;
        this.options = options || {};
        // Determining the namespace automatically from the name of the constructor will not work 
        // in conjunction with function renaming by uglify2
        this.namespace = this.namespace || 'somewidget';
        this.options.touch = ( typeof this.options.touch !== 'undefined' ) ? this.options.touch : false;
        this.event = event || null;
    };

    Widget.prototype = {
        /**
         * Destroys (a deeply cloned) widget (inside a repeat)
         * The sole purpose of this function in Enketo is to ensure a widget inside a cloned repeat stays
         * fully functional. The most robust way of doing this is to destroy the copy and then reinitialize it.
         * This is what the repeat controller does. It calls $input.mywidget('destroy') and $input.mywidget({}) in succession.
         * In some rare cases, this may simply be an empty function (e.g. see note widget).
         *
         * @param  {Element} element The element the widget is applied on. Note that if element was clone this.element applies to the origin.
         */
        destroy: function( element ) {
            $( element )
            //data is not used elsewhere by enketo
            .removeData( this.namespace )
            //remove all the event handlers that used this.namespace as the namespace
            .off( '.' + this.namespace )
            //show the original element
            .show()
            //remove elements immediately after the target that have the widget class
            .next( '.widget' ).remove();
            //console.debug( this.namespace, 'destroy' );
        },
        /**
         * Do whatever necessary to ensure that the widget does not allow user input if its parent branch is disabled.
         * Most of the times this branch can remain empty.
         * Check with $('.or-branch').show() whether input is disabled in a disabled branch.
         */
        disable: function() {
            //console.debug( this.namespace, 'disable' );
        },
        /**
         * Does whatever necessary to enable the widget if its parent branch is enabled.
         * Most of the times this function can remain empty.
         */
        enable: function() {
            //console.debug( this.namespace, 'enable' );
        },
        /**
         * Updates languages and <option>s (cascading selects.
         * Most of the times this function can remain empty
         */
        update: function() {
            //console.debug( this.namespace, 'update' );
        }

    };

    return Widget;
} );

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modilabs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/note/notewidget',[ 'enketo-js/Widget', 'jquery', 'enketo-js/plugins' ], function( Widget, $ ) {
    

    var pluginName = 'notewidget';

    /**
     * Enhances notes
     *
     * @constructor
     * @param {Element} element [description]
     * @param {(boolean|{touch: boolean, repeat: boolean})} options options
     * @param {*=} e     event
     */

    function Notewidget( element, options ) {
        this.namespace = pluginName;
        Widget.call( this, element, options );
        this._init();
    }

    //copy the prototype functions from the Widget super class
    Notewidget.prototype = Object.create( Widget.prototype );

    //ensure the constructor is the new one
    Notewidget.prototype.constructor = Notewidget;

    Notewidget.prototype._init = function() {
        var $el = $( this.element );
        $el.find( '.question-label' ).markdownToHtml()
            .end().find( '[readonly]' ).addClass( 'ignore' );

        if ( $el.is( '.note' ) && !$el.next().is( '.note' ) ) {
            $el.addClass( 'last-of-class' );
        }
    };

    $.fn[ pluginName ] = function( options, event ) {
        return this.each( function() {
            var $this = $( this ),
                data = $this.data( pluginName );

            options = options || {};

            if ( !data && typeof options === 'object' ) {
                $this.data( pluginName, ( data = new Notewidget( this, options, event ) ) );
            } else if ( data && typeof options == 'string' ) {
                data[ options ]( this );
            }
        } );
    };

} );

/**
 * @preserve Copyright 2012 Silvio Moreto, Martijn van de Rijdt & Modilabs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/select-desktop/selectpicker',[ 'jquery', 'enketo-js/Widget', 'bootstrap' ], function( $, Widget ) {
    

    var pluginName = 'desktopSelectpicker';

    /**
     * Bootstrap Select picker that supports single and multiple selects
     * A port of https://github.com/silviomoreto/bootstrap-select
     *
     * @constructor
     * @param {Element} element [description]
     * @param {(boolean|{touch: boolean, btnStyle: string, noneSelectedText: string, maxlength:number})} options options
     * @param {*=} e     event
     */

    function DesktopSelectpicker( element, options, e ) {
        this.namespace = pluginName;
        Widget.call( this, element, options );
        if ( e ) {
            e.stopPropagation();
            e.preventDefault();
        }

        this.$picker = null;
        this.noneSelectedText = options.noneSelectedText || 'none selected';
        this.lengthmax = options.maxlength || 15;
        this.multiple = ( typeof $( element ).attr( 'multiple' ) !== 'undefined' && $( element ).attr( 'multiple' ) !== false );
        this._init();
    }

    //copy the prototype functions from the Widget super class
    DesktopSelectpicker.prototype = Object.create( Widget.prototype );

    //ensure the constructor is the new one
    DesktopSelectpicker.prototype.constructor = DesktopSelectpicker;

    DesktopSelectpicker.prototype._init = function() {
        var $template = this._getTemplate(),
            $select = $( this.element );
        $select.css( 'display', 'none' );
        $template = this._createLi( $template );
        this.$picker = $template.insertAfter( $select );
        this.$picker.find( '> a' ).addClass( this.selectClass );
        this._clickListener();
        this._focusListener();
    };

    DesktopSelectpicker.prototype._getTemplate = function() {
        var template =
            '<div class="btn-group bootstrap-select widget clearfix">' +
            '<button type="button" class="btn btn-default dropdown-toggle clearfix" data-toggle="dropdown">' +
            '<span class="selected">__SELECTED_OPTIONS</span><span class="caret"></span>' +
            '</button>' +
            '<ul class="dropdown-menu" role="menu">' +
            '__ADD_LI' +
            '</ul>' +
            '</div>';

        return template;
    };

    DesktopSelectpicker.prototype._createLi = function( template ) {

        var li = [];
        var liHtml = '';
        var inputAttr = ( this.multiple ) ? "type='checkbox'" : "type='radio' name='" + Math.random() * 100000 + "'";
        var _this = this;
        var checkedInputAttr,
            checkedLiAttr;

        $( this.element ).find( 'option' ).each( function() {
            li.push( {
                label: $( this ).text(),
                selected: $( this ).is( ':selected' ),
                value: $( this ).attr( 'value' )
            } );
        } );

        if ( li.length > 0 ) {
            template = template.replace( '__SELECTED_OPTIONS', this._createSelectedStr() );
            for ( var i = 0; i < li.length; i++ ) {
                if ( li[ i ].value ) {
                    checkedInputAttr = ( li[ i ].selected ) ? " checked='checked'" : '';
                    checkedLiAttr = ( li[ i ].selected && !_this.multiple ) ? "class='active'" : '';
                    /**
                     * e.g.:
                     * <li checked="checked">
                     *   <a class="option-wrapper" tabindex="-1" href="#">
                     *         <label>
                     *           <input class="ignore" type="checkbox" checked="checked" value="a"/>
                     *         </label>
                     *       </a>
                     *    </li>
                     */
                    liHtml +=
                        "<li " + checkedLiAttr + ">" +
                        "<a class='option-wrapper' tabindex='-1' href='#'>" +
                        "<label>" +
                        "<input class='ignore' " + inputAttr + checkedInputAttr + "value='" + li[ i ].value + "' />" +
                        "<span class='option-label'>" + li[ i ].label + "</span></label>" +
                        "</a>" +
                        "</li>";
                }
            }
        }

        template = template.replace( '__ADD_LI', liHtml );

        return $( template );
    };


    /**
     * create text to show in closed picker
     * @param  {jQuery=} $select  jQuery-wrapped select element
     * @return {string}
     */
    DesktopSelectpicker.prototype._createSelectedStr = function() {
        var textToShow,
            selectedLabels = [],
            $select = $( this.element );
        $select.find( 'option:selected' ).each( function() {
            if ( $( this ).attr( 'value' ).length > 0 ) {
                selectedLabels.push( $( this ).text() );
            }
        } );

        if ( selectedLabels.length === 0 ) {
            return this.noneSelectedText;
        }
        textToShow = selectedLabels.join( ', ' );
        return ( textToShow.length > this.lengthmax ) ? selectedLabels.length + ' selected' : textToShow;
    };

    DesktopSelectpicker.prototype._clickListener = function() {
        var _this = this;

        this.$picker.on( 'click', 'li:not(.disabled)', function( e ) {
            e.preventDefault();
            var $li = $( this ),
                $input = $li.find( 'input' ),
                $select = $( _this.element ),
                $option = $select.find( 'option[value="' + $input.val() + '"]' ),
                selectedBefore = $option.is( ':selected' );

            console.log( 'li', $li, 'select', $select, 'option', $option );

            if ( !_this.multiple ) {
                _this.$picker.find( 'li' ).removeClass( 'active' );
                $option.siblings( 'option' ).prop( 'selected', false );
                _this.$picker.find( 'input' ).prop( 'checked', false );
            } else {
                //don't close dropdown for multiple select
                e.stopPropagation();
            }

            if ( selectedBefore ) {
                $li.removeClass( 'active' );
                $input.prop( 'checked', false );
                $option.prop( 'selected', false );
            } else {
                if ( !_this.multiple ) {
                    $li.addClass( 'active' );
                }
                $input.prop( 'checked', true );
                $option.prop( 'selected', true );
            }

            _this.$picker.find( '.selected' ).html( _this._createSelectedStr() );

            $select.trigger( 'change' );
        } );
    };

    DesktopSelectpicker.prototype._focusListener = function() {
        var _this = this;

        this.$picker.on( 'shown.bs.dropdown', function() {
            $( _this.element ).trigger( 'fakefocus' );
            return true;
        } ).on( 'hidden.bs.dropdown', function() {
            $( _this.element ).trigger( 'fakeblur' );
            return true;
        } );
    };

    //override super method
    DesktopSelectpicker.prototype.disable = function() {
        this.$picker.find( 'li' ).addClass( 'disabled' );
    };

    //override super method
    DesktopSelectpicker.prototype.enable = function() {
        this.$picker.find( 'li' ).removeClass( 'disabled' );
    };

    //override super method
    DesktopSelectpicker.prototype.update = function() {
        this.$picker.remove();
        this._init();
    };

    /**
     * [selectpicker description]
     * @param {({btnStyle: string, noneSelectedText: string, maxlength:number}|string)=} option options
     * @param {*=} event       [description]
     */
    $.fn[ pluginName ] = function( options, event ) {

        options = options || {};

        return this.each( function() {

            var $this = $( this ),
                data = $this.data( pluginName );

            //only instantiate if options is an object AND if options.touch is falsy
            if ( !data && typeof options == 'object' && !options.touch ) {
                $this.data( pluginName, ( data = new DesktopSelectpicker( this, options, event ) ) );
            } else if ( data && typeof options == 'string' ) {
                data[ options ]( this );
            }
        } );
    };

} );

/**
 * @preserve Copyright 2013 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/select-mobile/selectpicker',[ 'jquery', 'enketo-js/Widget' ], function( $, Widget ) {
    

    var pluginName = 'mobileSelectpicker';

    /**
     * An enhancement for the native multi-selectpicker found on most mobile devices,
     * that shows the selected values next to the select box
     *
     * @constructor
     * @param {Element} element Element to apply widget to.
     * @param {(boolean|{touch: boolean})} options options
     * @param {*=} e     event
     */

    function MobileSelectpicker( element, options, e ) {
        this.namespace = pluginName;
        Widget.call( this, element, options );
        this._init();
    }

    //copy the prototype functions from the Widget super class
    MobileSelectpicker.prototype = Object.create( Widget.prototype );

    //ensure the constructor is the new one
    MobileSelectpicker.prototype.constructor = MobileSelectpicker;

    /**
     * initialize
     */
    MobileSelectpicker.prototype._init = function() {
        var that = this;

        //show values on change
        $( this.element ).on( 'change.' + pluginName, function() {
            that._showSelectedValues();
            return true;
        } );

        //show defaults
        this._showSelectedValues();
    };

    /**
     * display the selected values
     */
    MobileSelectpicker.prototype._showSelectedValues = function() {
        var i, valueText = [],
            template = '<span class="widget mobileselect"></span>',
            $select = $( this.element ),
            $widget = ( $select.next( '.widget' ).length > 0 ) ? $select.next( '.widget' ) : $( template ).insertAfter( $select ),
            values = ( $.isArray( $select.val() ) ) ? $select.val() : [ $select.val() ];

        for ( i = 0; i < values.length; i++ ) {
            valueText.push( $( this ).find( 'option[value="' + values[ i ] + '"]' ).text() );
        }

        $widget.text( values.join( ', ' ) );
    };

    $.fn[ pluginName ] = function( options, event ) {

        options = options || {};

        return this.each( function() {
            var $this = $( this ),
                data = $this.data( pluginName );

            //only instantiate if options is an object AND if options.touch is truthy
            if ( !data && typeof options === 'object' && options.touch ) {
                $this.data( pluginName, ( data = new MobileSelectpicker( this, options, event ) ) );
            }
            if ( data && typeof options == 'string' ) {
                data[ options ]( this );
            }
        } );
    };
} );

/*
 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
 (c) 2010-2013, Vladimir Agafonkin
 (c) 2010-2011, CloudMade
*/
(function (window, document, undefined) {
var oldL = window.L,
    L = {};

L.version = '0.7.2';

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define('leaflet',L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed

L.noConflict = function () {
	window.L = oldL;
	return this;
};

window.L = L;


/*
 * L.Util contains various utility functions used throughout Leaflet code.
 */

L.Util = {
	extend: function (dest) { // (Object[, Object, ...]) ->
		var sources = Array.prototype.slice.call(arguments, 1),
		    i, j, len, src;

		for (j = 0, len = sources.length; j < len; j++) {
			src = sources[j] || {};
			for (i in src) {
				if (src.hasOwnProperty(i)) {
					dest[i] = src[i];
				}
			}
		}
		return dest;
	},

	bind: function (fn, obj) { // (Function, Object) -> Function
		var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
		return function () {
			return fn.apply(obj, args || arguments);
		};
	},

	stamp: (function () {
		var lastId = 0,
		    key = '_leaflet_id';
		return function (obj) {
			obj[key] = obj[key] || ++lastId;
			return obj[key];
		};
	}()),

	invokeEach: function (obj, method, context) {
		var i, args;

		if (typeof obj === 'object') {
			args = Array.prototype.slice.call(arguments, 3);

			for (i in obj) {
				method.apply(context, [i, obj[i]].concat(args));
			}
			return true;
		}

		return false;
	},

	limitExecByInterval: function (fn, time, context) {
		var lock, execOnUnlock;

		return function wrapperFn() {
			var args = arguments;

			if (lock) {
				execOnUnlock = true;
				return;
			}

			lock = true;

			setTimeout(function () {
				lock = false;

				if (execOnUnlock) {
					wrapperFn.apply(context, args);
					execOnUnlock = false;
				}
			}, time);

			fn.apply(context, args);
		};
	},

	falseFn: function () {
		return false;
	},

	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	setOptions: function (obj, options) {
		obj.options = L.extend({}, obj.options, options);
		return obj.options;
	},

	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},
	template: function (str, data) {
		return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
			var value = data[key];
			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);
			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {

	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		var i, fn,
		    prefixes = ['webkit', 'moz', 'o', 'ms'];

		for (i = 0; i < prefixes.length && !fn; i++) {
			fn = window[prefixes[i] + name];
		}

		return fn;
	}

	var lastTime = 0;

	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame ||
	        getPrefixed('RequestAnimationFrame') || timeoutDefer;

	var cancelFn = window.cancelAnimationFrame ||
	        getPrefixed('CancelAnimationFrame') ||
	        getPrefixed('CancelRequestAnimationFrame') ||
	        function (id) { window.clearTimeout(id); };


	L.Util.requestAnimFrame = function (fn, context, immediate, element) {
		fn = L.bind(fn, context);

		if (immediate && requestFn === timeoutDefer) {
			fn();
		} else {
			return requestFn.call(window, fn, element);
		}
	};

	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};

}());

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;


/*
 * L.Class powers the OOP facilities of the library.
 * Thanks to John Resig and Dean Edwards for inspiration!
 */

L.Class = function () {};

L.Class.extend = function (props) {

	// extended class with the new prototype
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		if (this._initHooks) {
			this.callInitHooks();
		}
	};

	// instantiate class without calling constructor
	var F = function () {};
	F.prototype = this.prototype;

	var proto = new F();
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	//inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (props.options && proto.options) {
		props.options = L.extend({}, proto.options, props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	var parent = this;
	// jshint camelcase: false
	NewClass.__super__ = parent.prototype;

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parent.prototype.callInitHooks) {
			parent.prototype.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// method for adding properties to prototype
L.Class.include = function (props) {
	L.extend(this.prototype, props);
};

// merge new default options to the Class
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
};

// add a constructor hook
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
};


/*
 * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
 */

var eventsKey = '_leaflet_events';

L.Mixin = {};

L.Mixin.Events = {

	addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])

		// types can be a map of types/handlers
		if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey] = this[eventsKey] || {},
		    contextId = context && context !== this && L.stamp(context),
		    i, len, event, type, indexKey, indexLenKey, typeIndex;

		// types can be a string of space-separated words
		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			event = {
				action: fn,
				context: context || this
			};
			type = types[i];

			if (contextId) {
				// store listeners of a particular context in a separate hash (if it has an id)
				// gives a major performance boost when removing thousands of map layers

				indexKey = type + '_idx';
				indexLenKey = indexKey + '_len';

				typeIndex = events[indexKey] = events[indexKey] || {};

				if (!typeIndex[contextId]) {
					typeIndex[contextId] = [];

					// keep track of the number of keys in the index to quickly check if it's empty
					events[indexLenKey] = (events[indexLenKey] || 0) + 1;
				}

				typeIndex[contextId].push(event);


			} else {
				events[type] = events[type] || [];
				events[type].push(event);
			}
		}

		return this;
	},

	hasEventListeners: function (type) { // (String) -> Boolean
		var events = this[eventsKey];
		return !!events && ((type in events && events[type].length > 0) ||
		                    (type + '_idx' in events && events[type + '_idx_len'] > 0));
	},

	removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

		if (!this[eventsKey]) {
			return this;
		}

		if (!types) {
			return this.clearAllEventListeners();
		}

		if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey],
		    contextId = context && context !== this && L.stamp(context),
		    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			type = types[i];
			indexKey = type + '_idx';
			indexLenKey = indexKey + '_len';

			typeIndex = events[indexKey];

			if (!fn) {
				// clear all listeners for a type if function isn't specified
				delete events[type];
				delete events[indexKey];
				delete events[indexLenKey];

			} else {
				listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

				if (listeners) {
					for (j = listeners.length - 1; j >= 0; j--) {
						if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
							removed = listeners.splice(j, 1);
							// set the old action to a no-op, because it is possible
							// that the listener is being iterated over as part of a dispatch
							removed[0].action = L.Util.falseFn;
						}
					}

					if (context && typeIndex && (listeners.length === 0)) {
						delete typeIndex[contextId];
						events[indexLenKey]--;
					}
				}
			}
		}

		return this;
	},

	clearAllEventListeners: function () {
		delete this[eventsKey];
		return this;
	},

	fireEvent: function (type, data) { // (String[, Object])
		if (!this.hasEventListeners(type)) {
			return this;
		}

		var event = L.Util.extend({}, data, { type: type, target: this });

		var events = this[eventsKey],
		    listeners, i, len, typeIndex, contextId;

		if (events[type]) {
			// make sure adding/removing listeners inside other listeners won't cause infinite loop
			listeners = events[type].slice();

			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].action.call(listeners[i].context, event);
			}
		}

		// fire event for the context-indexed listeners as well
		typeIndex = events[type + '_idx'];

		for (contextId in typeIndex) {
			listeners = typeIndex[contextId].slice();

			if (listeners) {
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].action.call(listeners[i].context, event);
				}
			}
		}

		return this;
	},

	addOneTimeEventListener: function (types, fn, context) {

		if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }

		var handler = L.bind(function () {
			this
			    .removeEventListener(types, fn, context)
			    .removeEventListener(types, handler, context);
		}, this);

		return this
		    .addEventListener(types, fn, context)
		    .addEventListener(types, handler, context);
	}
};

L.Mixin.Events.on = L.Mixin.Events.addEventListener;
L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
L.Mixin.Events.fire = L.Mixin.Events.fireEvent;


/*
 * L.Browser handles different browser and feature detections for internal Leaflet use.
 */

(function () {

	var ie = 'ActiveXObject' in window,
		ielt9 = ie && !document.addEventListener,

	    // terrible browser detection to work around Safari / iOS / Android browser bugs
	    ua = navigator.userAgent.toLowerCase(),
	    webkit = ua.indexOf('webkit') !== -1,
	    chrome = ua.indexOf('chrome') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android = ua.indexOf('android') !== -1,
	    android23 = ua.search('android [23]') !== -1,
		gecko = ua.indexOf('gecko') !== -1,

	    mobile = typeof orientation !== undefined + '',
	    msPointer = window.navigator && window.navigator.msPointerEnabled &&
	              window.navigator.msMaxTouchPoints && !window.PointerEvent,
		pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||
				  msPointer,
	    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
	             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
	              window.matchMedia('(min-resolution:144dpi)').matches),

	    doc = document.documentElement,
	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera3d = 'OTransition' in doc.style,
	    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;


	// PhantomJS has 'ontouchstart' in document.documentElement, but doesn't actually support touch.
	// https://github.com/Leaflet/Leaflet/pull/1434#issuecomment-13843151

	var touch = !window.L_NO_TOUCH && !phantomjs && (function () {

		var startName = 'ontouchstart';

		// IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.
		if (pointer || (startName in doc)) {
			return true;
		}

		// Firefox/Gecko
		var div = document.createElement('div'),
		    supported = false;

		if (!div.setAttribute) {
			return false;
		}
		div.setAttribute(startName, 'return;');

		if (typeof div[startName] === 'function') {
			supported = true;
		}

		div.removeAttribute(startName);
		div = null;

		return supported;
	}());


	L.Browser = {
		ie: ie,
		ielt9: ielt9,
		webkit: webkit,
		gecko: gecko && !webkit && !window.opera && !ie,

		android: android,
		android23: android23,

		chrome: chrome,

		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		opera3d: opera3d,
		any3d: any3d,

		mobile: mobile,
		mobileWebkit: mobile && webkit,
		mobileWebkit3d: mobile && webkit3d,
		mobileOpera: mobile && window.opera,

		touch: touch,
		msPointer: msPointer,
		pointer: pointer,

		retina: retina
	};

}());


/*
 * L.Point represents a point with x and y coordinates.
 */

L.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// non-destructive, returns a new point
	add: function (point) {
		return this.clone()._add(L.point(point));
	},

	// destructive, used directly for performance in situations where it's safe to modify existing point
	_add: function (point) {
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	return new L.Point(x, y, round);
};


/*
 * L.Bounds represents a rectangular area on the screen in pixel coordinates.
 */

L.Bounds = function (a, b) { //(Point, Point) or Point[]
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// extend the bounds to contain the given point
	extend: function (point) { // (Point)
		point = L.point(point);

		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	getCenter: function (round) { // (Boolean) -> Point
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	getBottomLeft: function () { // -> Point
		return new L.Point(this.min.x, this.max.y);
	},

	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	getSize: function () {
		return this.max.subtract(this.min);
	},

	contains: function (obj) { // (Bounds) or (Point) -> Boolean
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};

L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};


/*
 * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
 */

L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};


/*
 * L.DomUtil contains various utility functions for working with DOM.
 */

L.DomUtil = {
	get: function (id) {
		return (typeof id === 'string' ? document.getElementById(id) : id);
	},

	getStyle: function (el, style) {

		var value = el.style[style];

		if (!value && el.currentStyle) {
			value = el.currentStyle[style];
		}

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	getViewportOffset: function (element) {

		var top = 0,
		    left = 0,
		    el = element,
		    docBody = document.body,
		    docEl = document.documentElement,
		    pos;

		do {
			top  += el.offsetTop  || 0;
			left += el.offsetLeft || 0;

			//add borders
			top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
			left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

			pos = L.DomUtil.getStyle(el, 'position');

			if (el.offsetParent === docBody && pos === 'absolute') { break; }

			if (pos === 'fixed') {
				top  += docBody.scrollTop  || docEl.scrollTop  || 0;
				left += docBody.scrollLeft || docEl.scrollLeft || 0;
				break;
			}

			if (pos === 'relative' && !el.offsetLeft) {
				var width = L.DomUtil.getStyle(el, 'width'),
				    maxWidth = L.DomUtil.getStyle(el, 'max-width'),
				    r = el.getBoundingClientRect();

				if (width !== 'none' || maxWidth !== 'none') {
					left += r.left + el.clientLeft;
				}

				//calculate full y offset since we're breaking out of the loop
				top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);

				break;
			}

			el = el.offsetParent;

		} while (el);

		el = element;

		do {
			if (el === docBody) { break; }

			top  -= el.scrollTop  || 0;
			left -= el.scrollLeft || 0;

			el = el.parentNode;
		} while (el);

		return new L.Point(left, top);
	},

	documentIsLtr: function () {
		if (!L.DomUtil._docIsLtrCached) {
			L.DomUtil._docIsLtrCached = true;
			L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
		}
		return L.DomUtil._docIsLtr;
	},

	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className;

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil._getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil._getClass(el);
			L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	_setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	_getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {

			var filter = false,
			    filterName = 'DXImageTransform.Microsoft.Alpha';

			// filters collection throws an error if we try to retrieve a filter that doesn't exist
			try {
				filter = el.filters.item(filterName);
			} catch (e) {
				// don't set opacity to 1 if we haven't already set an opacity,
				// it isn't needed and breaks transparent pngs.
				if (value === 1) { return; }
			}

			value = Math.round(value * 100);

			if (filter) {
				filter.Enabled = (value !== 100);
				filter.Opacity = value;
			} else {
				el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
			}
		}
	},

	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	getTranslateString: function (point) {
		// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
		// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
		// (same speed either way), Opera 12 doesn't support translate3d

		var is3d = L.Browser.webkit3d,
		    open = 'translate' + (is3d ? '3d' : '') + '(',
		    close = (is3d ? ',0' : '') + ')';

		return open + point.x + 'px,' + point.y + 'px' + close;
	},

	getScaleString: function (scale, origin) {

		var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
		    scaleStr = ' scale(' + scale + ') ';

		return preTranslateStr + scaleStr;
	},

	setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

		// jshint camelcase: false
		el._leaflet_pos = point;

		if (!disable3D && L.Browser.any3d) {
			el.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		// jshint camelcase: false
		return el._leaflet_pos;
	}
};


// prefix style property names

L.DomUtil.TRANSFORM = L.DomUtil.testProp(
        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

L.DomUtil.TRANSITION = L.DomUtil.testProp(
        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

L.DomUtil.TRANSITION_END =
        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?
        L.DomUtil.TRANSITION + 'End' : 'transitionend';

(function () {
    if ('onselectstart' in document) {
        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
            },

            enableTextSelection: function () {
                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
            }
        });
    } else {
        var userSelectProperty = L.DomUtil.testProp(
            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                if (userSelectProperty) {
                    var style = document.documentElement.style;
                    this._userSelect = style[userSelectProperty];
                    style[userSelectProperty] = 'none';
                }
            },

            enableTextSelection: function () {
                if (userSelectProperty) {
                    document.documentElement.style[userSelectProperty] = this._userSelect;
                    delete this._userSelect;
                }
            }
        });
    }

	L.extend(L.DomUtil, {
		disableImageDrag: function () {
			L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
		},

		enableImageDrag: function () {
			L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
		}
	});
})();


/*
 * L.LatLng represents a geographical point with latitude and longitude coordinates.
 */

L.LatLng = function (lat, lng, alt) { // (Number, Number, Number)
	lat = parseFloat(lat);
	lng = parseFloat(lng);

	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	this.lat = lat;
	this.lng = lng;

	if (alt !== undefined) {
		this.alt = parseFloat(alt);
	}
};

L.extend(L.LatLng, {
	DEG_TO_RAD: Math.PI / 180,
	RAD_TO_DEG: 180 / Math.PI,
	MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
});

L.LatLng.prototype = {
	equals: function (obj) { // (LatLng) -> Boolean
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= L.LatLng.MAX_MARGIN;
	},

	toString: function (precision) { // (Number) -> String
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
	// TODO move to projection code, LatLng shouldn't know about Earth
	distanceTo: function (other) { // (LatLng) -> Number
		other = L.latLng(other);

		var R = 6378137, // earth radius in meters
		    d2r = L.LatLng.DEG_TO_RAD,
		    dLat = (other.lat - this.lat) * d2r,
		    dLon = (other.lng - this.lng) * d2r,
		    lat1 = this.lat * d2r,
		    lat2 = other.lat * d2r,
		    sin1 = Math.sin(dLat / 2),
		    sin2 = Math.sin(dLon / 2);

		var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

		return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	},

	wrap: function (a, b) { // (Number, Number) -> LatLng
		var lng = this.lng;

		a = a || -180;
		b = b ||  180;

		lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);

		return new L.LatLng(this.lat, lng);
	}
};

L.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a)) {
		if (typeof a[0] === 'number' || typeof a[0] === 'string') {
			return new L.LatLng(a[0], a[1], a[2]);
		} else {
			return null;
		}
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b);
};



/*
 * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {
	// extend the bounds to contain the given point or bounds
	extend: function (obj) { // (LatLng) or (LatLngBounds)
		if (!obj) { return this; }

		var latLng = L.latLng(obj);
		if (latLng !== null) {
			obj = latLng;
		} else {
			obj = L.latLngBounds(obj);
		}

		if (obj instanceof L.LatLng) {
			if (!this._southWest && !this._northEast) {
				this._southWest = new L.LatLng(obj.lat, obj.lng);
				this._northEast = new L.LatLng(obj.lat, obj.lng);
			} else {
				this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
				this._southWest.lng = Math.min(obj.lng, this._southWest.lng);

				this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
				this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
			}
		} else if (obj instanceof L.LatLngBounds) {
			this.extend(obj._southWest);
			this.extend(obj._northEast);
		}
		return this;
	},

	// extend the bounds by a percentage
	pad: function (bufferRatio) { // (Number) -> LatLngBounds
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	getCenter: function () { // -> LatLng
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	getSouthWest: function () {
		return this._southWest;
	},

	getNorthEast: function () {
		return this._northEast;
	},

	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	getWest: function () {
		return this._southWest.lng;
	},

	getSouth: function () {
		return this._southWest.lat;
	},

	getEast: function () {
		return this._northEast.lng;
	},

	getNorth: function () {
		return this._northEast.lat;
	},

	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	intersects: function (bounds) { // (LatLngBounds)
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	equals: function (bounds) { // (LatLngBounds)
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

//TODO International date line?

L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
	if (!a || a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};


/*
 * L.Projection contains various geographical projections used by CRS classes.
 */

L.Projection = {};


/*
 * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
 */

L.Projection.SphericalMercator = {
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    x = latlng.lng * d,
		    y = lat * d;

		y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    lng = point.x * d,
		    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;

		return new L.LatLng(lat, lng);
	}
};


/*
 * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
 */

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	}
};


/*
 * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
 */

L.CRS = {
	latLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	pointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	project: function (latlng) {
		return this.projection.project(latlng);
	},

	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	getSize: function (zoom) {
		var s = this.scale(zoom);
		return L.point(s, s);
	}
};


/*
 * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	}
});


/*
 * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
 * and is used by Leaflet by default.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS, {
	code: 'EPSG:3857',

	projection: L.Projection.SphericalMercator,
	transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),

	project: function (latlng) { // (LatLng) -> Point
		var projectedPoint = this.projection.project(latlng),
		    earthRadius = 6378137;
		return projectedPoint.multiplyBy(earthRadius);
	}
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});


/*
 * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS, {
	code: 'EPSG:4326',

	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
});


/*
 * L.Map is the central class of the API - it is used to create a map.
 */

L.Map = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		crs: L.CRS.EPSG3857,

		/*
		center: LatLng,
		zoom: Number,
		layers: Array,
		*/

		fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
		trackResize: true,
		markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);


		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];

		this._layers = {};
		this._zoomBoundLayers = {};
		this._tileLayersNum = 0;

		this.callInitHooks();

		this._addLayers(options.layers);
	},


	// public methods that modify map state

	// replaced by animation-powered implementation in Map.PanAnimation.js
	setView: function (center, zoom) {
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), this._limitZoom(zoom));
		return this;
	},

	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = this._limitZoom(zoom);
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	zoomIn: function (delta, options) {
		return this.setZoom(this._zoom + (delta || 1), options);
	},

	zoomOut: function (delta, options) {
		return this.setZoom(this._zoom - (delta || 1), options);
	},

	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	fitBounds: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR)),
		    paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		zoom = options && options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;

		return this.setView(center, zoom, options);
	},

	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		this.options.maxBounds = bounds;

		if (!bounds) {
			return this.off('moveend', this._panInsideMaxBounds, this);
		}

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds, this);
	},

	panInsideBounds: function (bounds, options) {
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, bounds);

		if (center.equals(newCenter)) { return this; }

		return this.panTo(newCenter, options);
	},

	addLayer: function (layer) {
		// TODO method is too big, refactor

		var id = L.stamp(layer);

		if (this._layers[id]) { return this; }

		this._layers[id] = layer;

		// TODO getMaxZoom, getMinZoom in ILayer (instead of options)
		if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
			this._zoomBoundLayers[id] = layer;
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor!!!
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum++;
			this._tileLayersToLoad++;
			layer.on('load', this._onTileLayerLoad, this);
		}

		if (this._loaded) {
			this._layerAdd(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
		}

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum--;
			this._tileLayersToLoad--;
			layer.off('load', this._onTileLayerLoad, this);
		}

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (L.stamp(layer) in this._layers);
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._initialCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// TODO handler.addTo
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	remove: function () {
		if (this._loaded) {
			this.fire('unload');
		}

		this._initEvents('off');

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		this._clearPanes();
		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		return this;
	},


	// public methods for getting map state

	getCenter: function () { // (Boolean) -> LatLng
		this._checkIfLoaded();

		if (this._initialCenter && !this._moved()) {
			return this._initialCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	getZoom: function () {
		return this._zoom;
	},

	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	getMinZoom: function () {
		return this.options.minZoom === undefined ?
			(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :
			this.options.minZoom;
	},

	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);

		var zoom = this.getMinZoom() - (inside ? 1 : 0),
		    maxZoom = this.getMaxZoom(),
		    size = this.getSize(),

		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),

		    zoomNotFound = true,
		    boundsSize;

		padding = L.point(padding || [0, 0]);

		do {
			zoom++;
			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

		} while (zoomNotFound && zoom <= maxZoom);

		if (zoomNotFound && inside) {
			return null;
		}

		return inside ? zoom : zoom - 1;
	},

	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	getPixelBounds: function () {
		var topLeftPoint = this._getTopLeftPoint();
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._initialTopLeftPoint;
	},

	getPanes: function () {
		return this._panes;
	},

	getContainer: function () {
		return this._container;
	},


	// TODO replace with universal implementation after refactoring projections

	getZoomScale: function (toZoom) {
		var crs = this.options.crs;
		return crs.scale(toZoom) / crs.scale(this._zoom);
	},

	getScaleZoom: function (scale) {
		return this._zoom + (Math.log(scale) / Math.LN2);
	},


	// conversion methods

	project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	layerPointToLatLng: function (point) { // (Point)
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	latLngToLayerPoint: function (latlng) { // (LatLng)
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	mouseEventToContainerPoint: function (e) { // (MouseEvent)
		return L.DomEvent.getMousePosition(e, this._container);
	},

	mouseEventToLayerPoint: function (e) { // (MouseEvent)
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};

		this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);

		this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
		panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
		panes.shadowPane = this._createPane('leaflet-shadow-pane');
		panes.overlayPane = this._createPane('leaflet-overlay-pane');
		panes.markerPane = this._createPane('leaflet-marker-pane');
		panes.popupPane = this._createPane('leaflet-popup-pane');

		var zoomHide = ' leaflet-zoom-hide';

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, zoomHide);
			L.DomUtil.addClass(panes.shadowPane, zoomHide);
			L.DomUtil.addClass(panes.popupPane, zoomHide);
		}
	},

	_createPane: function (className, container) {
		return L.DomUtil.create('div', className, container || this._panes.objectsPane);
	},

	_clearPanes: function () {
		this._container.removeChild(this._mapPane);
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},


	// private methods that modify map state

	_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

		var zoomChanged = (this._zoom !== zoom);

		if (!afterZoomAnim) {
			this.fire('movestart');

			if (zoomChanged) {
				this.fire('zoomstart');
			}
		}

		this._zoom = zoom;
		this._initialCenter = center;

		this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

		if (!preserveMapOffset) {
			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
		} else {
			this._initialTopLeftPoint._add(this._getMapPanePos());
		}

		this._tileLayersToLoad = this._tileLayersNum;

		var loading = !this._loaded;
		this._loaded = true;

		if (loading) {
			this.fire('load');
			this.eachLayer(this._layerAdd, this);
		}

		this.fire('viewreset', {hard: !preserveMapOffset});

		this.fire('move');

		if (zoomChanged || afterZoomAnim) {
			this.fire('zoomend');
		}

		this.fire('moveend', {hard: !preserveMapOffset});
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_updateZoomLevels: function () {
		var i,
			minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (i in this._zoomBoundLayers) {
			var layer = this._zoomBoundLayers[i];
			if (!isNaN(layer.options.minZoom)) {
				minZoom = Math.min(minZoom, layer.options.minZoom);
			}
			if (!isNaN(layer.options.maxZoom)) {
				maxZoom = Math.max(maxZoom, layer.options.maxZoom);
			}
		}

		if (i === undefined) { // we have no tilelayers
			this._layersMaxZoom = this._layersMinZoom = undefined;
		} else {
			this._layersMaxZoom = maxZoom;
			this._layersMinZoom = minZoom;
		}

		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	},

	_panInsideMaxBounds: function () {
		this.panInsideBounds(this.options.maxBounds);
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// map events

	_initEvents: function (onOff) {
		if (!L.DomEvent) { return; }

		onOff = onOff || 'on';

		L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

		var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
		              'mouseleave', 'mousemove', 'contextmenu'],
		    i, len;

		for (i = 0, len = events.length; i < len; i++) {
			L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
		}

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);
	},

	_onMouseClick: function (e) {
		if (!this._loaded || (!e._simulated &&
		        ((this.dragging && this.dragging.moved()) ||
		         (this.boxZoom  && this.boxZoom.moved()))) ||
		            L.DomEvent._skipped(e)) { return; }

		this.fire('preclick');
		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type;

		type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

		if (!this.hasEventListeners(type)) { return; }

		if (type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}

		var containerPoint = this.mouseEventToContainerPoint(e),
		    layerPoint = this.containerPointToLayerPoint(containerPoint),
		    latlng = this.layerPointToLatLng(layerPoint);

		this.fire(type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});
	},

	_onTileLayerLoad: function () {
		this._tileLayersToLoad--;
		if (this._tileLayersNum && !this._tileLayersToLoad) {
			this.fire('tilelayersload');
		}
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, this);
		} else {
			this.on('load', callback, context);
		}
		return this;
	},

	_layerAdd: function (layer) {
		layer.onAdd(this);
		this.fire('layeradd', {layer: layer});
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function () {
		return this.getPixelOrigin().subtract(this._getMapPanePos());
	},

	_getNewTopLeftPoint: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		// TODO round on display, not calculation to increase precision?
		return this.project(center, zoom)._subtract(viewHalf)._round();
	},

	_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {
		var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
		return this.project(latlng, newZoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
		    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

		    dx = this._rebound(nwOffset.x, -seOffset.x),
		    dy = this._rebound(nwOffset.y, -seOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom();

		return Math.max(min, Math.min(max, zoom));
	}
});

L.map = function (id, options) {
	return new L.Map(id, options);
};


/*
 * Mercator projection that takes into account that the Earth is not a perfect sphere.
 * Less popular than spherical mercator; used by projections like EPSG:3395.
 */

L.Projection.Mercator = {
	MAX_LATITUDE: 85.0840591556,

	R_MINOR: 6356752.314245179,
	R_MAJOR: 6378137,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    x = latlng.lng * d * r,
		    y = lat * d,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1.0 - tmp * tmp),
		    con = eccent * Math.sin(y);

		con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

		var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
		y = -r * Math.log(ts);

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    lng = point.x * d / r,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1 - (tmp * tmp)),
		    ts = Math.exp(- point.y / r),
		    phi = (Math.PI / 2) - 2 * Math.atan(ts),
		    numIter = 15,
		    tol = 1e-7,
		    i = numIter,
		    dphi = 0.1,
		    con;

		while ((Math.abs(dphi) > tol) && (--i > 0)) {
			con = eccent * Math.sin(phi);
			dphi = (Math.PI / 2) - 2 * Math.atan(ts *
			            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, lng);
	}
};



L.CRS.EPSG3395 = L.extend({}, L.CRS, {
	code: 'EPSG:3395',

	projection: L.Projection.Mercator,

	transformation: (function () {
		var m = L.Projection.Mercator,
		    r = m.R_MAJOR,
		    scale = 0.5 / (Math.PI * r);

		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});


/*
 * L.TileLayer is used for standard xyz-numbered tile layers.
 */

L.TileLayer = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minZoom: 0,
		maxZoom: 18,
		tileSize: 256,
		subdomains: 'abc',
		errorTileUrl: '',
		attribution: '',
		zoomOffset: 0,
		opacity: 1,
		/*
		maxNativeZoom: null,
		zIndex: null,
		tms: false,
		continuousWorld: false,
		noWrap: false,
		zoomReverse: false,
		detectRetina: false,
		reuseTiles: false,
		bounds: false,
		*/
		unloadInvisibleTiles: L.Browser.mobile,
		updateWhenIdle: L.Browser.mobile
	},

	initialize: function (url, options) {
		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);
			options.zoomOffset++;

			if (options.minZoom > 0) {
				options.minZoom--;
			}
			this.options.maxZoom--;
		}

		if (options.bounds) {
			options.bounds = L.latLngBounds(options.bounds);
		}

		this._url = url;

		var subdomains = this.options.subdomains;

		if (typeof subdomains === 'string') {
			this.options.subdomains = subdomains.split('');
		}
	},

	onAdd: function (map) {
		this._map = map;
		this._animated = map._zoomAnimated;

		// create a container div for tiles
		this._initContainer();

		// set up events
		map.on({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.on({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
			map.on('move', this._limitedUpdate, this);
		}

		this._reset();
		this._update();
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		this._container.parentNode.removeChild(this._container);

		map.off({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.off({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			map.off('move', this._limitedUpdate, this);
		}

		this._container = null;
		this._map = null;
	},

	bringToFront: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.appendChild(this._container);
			this._setAutoZIndex(pane, Math.max);
		}

		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.insertBefore(this._container, pane.firstChild);
			this._setAutoZIndex(pane, Math.min);
		}

		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getContainer: function () {
		return this._container;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}
		return this;
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (pane, compare) {

		var layers = pane.children,
		    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
		    zIndex, i, len;

		for (i = 0, len = layers.length; i < len; i++) {

			if (layers[i] !== this._container) {
				zIndex = parseInt(layers[i].style.zIndex, 10);

				if (!isNaN(zIndex)) {
					edgeZIndex = compare(edgeZIndex, zIndex);
				}
			}
		}

		this.options.zIndex = this._container.style.zIndex =
		        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
	},

	_updateOpacity: function () {
		var i,
		    tiles = this._tiles;

		if (L.Browser.ielt9) {
			for (i in tiles) {
				L.DomUtil.setOpacity(tiles[i], this.options.opacity);
			}
		} else {
			L.DomUtil.setOpacity(this._container, this.options.opacity);
		}
	},

	_initContainer: function () {
		var tilePane = this._map._panes.tilePane;

		if (!this._container) {
			this._container = L.DomUtil.create('div', 'leaflet-layer');

			this._updateZIndex();

			if (this._animated) {
				var className = 'leaflet-tile-container';

				this._bgBuffer = L.DomUtil.create('div', className, this._container);
				this._tileContainer = L.DomUtil.create('div', className, this._container);

			} else {
				this._tileContainer = this._container;
			}

			tilePane.appendChild(this._container);

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}
	},

	_reset: function (e) {
		for (var key in this._tiles) {
			this.fire('tileunload', {tile: this._tiles[key]});
		}

		this._tiles = {};
		this._tilesToLoad = 0;

		if (this.options.reuseTiles) {
			this._unusedTiles = [];
		}

		this._tileContainer.innerHTML = '';

		if (this._animated && e && e.hard) {
			this._clearBgBuffer();
		}

		this._initContainer();
	},

	_getTileSize: function () {
		var map = this._map,
		    zoom = map.getZoom() + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom,
		    tileSize = this.options.tileSize;

		if (zoomN && zoom > zoomN) {
			tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
		}

		return tileSize;
	},

	_update: function () {

		if (!this._map) { return; }

		var map = this._map,
		    bounds = map.getPixelBounds(),
		    zoom = map.getZoom(),
		    tileSize = this._getTileSize();

		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			return;
		}

		var tileBounds = L.bounds(
		        bounds.min.divideBy(tileSize)._floor(),
		        bounds.max.divideBy(tileSize)._floor());

		this._addTilesFromCenterOut(tileBounds);

		if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
			this._removeOtherTiles(tileBounds);
		}
	},

	_addTilesFromCenterOut: function (bounds) {
		var queue = [],
		    center = bounds.getCenter();

		var j, i, point;

		for (j = bounds.min.y; j <= bounds.max.y; j++) {
			for (i = bounds.min.x; i <= bounds.max.x; i++) {
				point = new L.Point(i, j);

				if (this._tileShouldBeLoaded(point)) {
					queue.push(point);
				}
			}
		}

		var tilesToLoad = queue.length;

		if (tilesToLoad === 0) { return; }

		// load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(center) - b.distanceTo(center);
		});

		var fragment = document.createDocumentFragment();

		// if its the first batch of tiles to load
		if (!this._tilesToLoad) {
			this.fire('loading');
		}

		this._tilesToLoad += tilesToLoad;

		for (i = 0; i < tilesToLoad; i++) {
			this._addTile(queue[i], fragment);
		}

		this._tileContainer.appendChild(fragment);
	},

	_tileShouldBeLoaded: function (tilePoint) {
		if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
			return false; // already loaded
		}

		var options = this.options;

		if (!options.continuousWorld) {
			var limit = this._getWrapTileNum();

			// don't load if exceeds world bounds
			if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
				tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
		}

		if (options.bounds) {
			var tileSize = options.tileSize,
			    nwPoint = tilePoint.multiplyBy(tileSize),
			    sePoint = nwPoint.add([tileSize, tileSize]),
			    nw = this._map.unproject(nwPoint),
			    se = this._map.unproject(sePoint);

			// TODO temporary hack, will be removed after refactoring projections
			// https://github.com/Leaflet/Leaflet/issues/1618
			if (!options.continuousWorld && !options.noWrap) {
				nw = nw.wrap();
				se = se.wrap();
			}

			if (!options.bounds.intersects([nw, se])) { return false; }
		}

		return true;
	},

	_removeOtherTiles: function (bounds) {
		var kArr, x, y, key;

		for (key in this._tiles) {
			kArr = key.split(':');
			x = parseInt(kArr[0], 10);
			y = parseInt(kArr[1], 10);

			// remove tile if it's out of bounds
			if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
				this._removeTile(key);
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];

		this.fire('tileunload', {tile: tile, url: tile.src});

		if (this.options.reuseTiles) {
			L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
			this._unusedTiles.push(tile);

		} else if (tile.parentNode === this._tileContainer) {
			this._tileContainer.removeChild(tile);
		}

		// for https://github.com/CloudMade/Leaflet/issues/137
		if (!L.Browser.android) {
			tile.onload = null;
			tile.src = L.Util.emptyImageUrl;
		}

		delete this._tiles[key];
	},

	_addTile: function (tilePoint, container) {
		var tilePos = this._getTilePos(tilePoint);

		// get unused tile - or create a new tile
		var tile = this._getTile();

		/*
		Chrome 20 layouts much faster with top/left (verify with timeline, frames)
		Android 4 browser has display issues with top/left and requires transform instead
		(other browsers don't currently care) - see debug/hacks/jitter.html for an example
		*/
		L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

		this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

		this._loadTile(tile, tilePoint);

		if (tile.parentNode !== this._tileContainer) {
			container.appendChild(tile);
		}
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._map.getZoom();

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getTilePos: function (tilePoint) {
		var origin = this._map.getPixelOrigin(),
		    tileSize = this._getTileSize();

		return tilePoint.multiplyBy(tileSize).subtract(origin);
	},

	// image-specific code (override to implement e.g. Canvas or SVG tile layer)

	getTileUrl: function (tilePoint) {
		return L.Util.template(this._url, L.extend({
			s: this._getSubdomain(tilePoint),
			z: tilePoint.z,
			x: tilePoint.x,
			y: tilePoint.y
		}, this.options));
	},

	_getWrapTileNum: function () {
		var crs = this._map.options.crs,
		    size = crs.getSize(this._map.getZoom());
		return size.divideBy(this._getTileSize())._floor();
	},

	_adjustTilePoint: function (tilePoint) {

		var limit = this._getWrapTileNum();

		// wrap tile coordinates
		if (!this.options.continuousWorld && !this.options.noWrap) {
			tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
		}

		if (this.options.tms) {
			tilePoint.y = limit.y - tilePoint.y - 1;
		}

		tilePoint.z = this._getZoomForUrl();
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	_getTile: function () {
		if (this.options.reuseTiles && this._unusedTiles.length > 0) {
			var tile = this._unusedTiles.pop();
			this._resetTile(tile);
			return tile;
		}
		return this._createTile();
	},

	// Override if data stored on a tile needs to be cleaned up before reuse
	_resetTile: function (/*tile*/) {},

	_createTile: function () {
		var tile = L.DomUtil.create('img', 'leaflet-tile');
		tile.style.width = tile.style.height = this._getTileSize() + 'px';
		tile.galleryimg = 'no';

		tile.onselectstart = tile.onmousemove = L.Util.falseFn;

		if (L.Browser.ielt9 && this.options.opacity !== undefined) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}
		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.mobileWebkit3d) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer  = this;
		tile.onload  = this._tileOnLoad;
		tile.onerror = this._tileOnError;

		this._adjustTilePoint(tilePoint);
		tile.src     = this.getTileUrl(tilePoint);

		this.fire('tileloadstart', {
			tile: tile,
			url: tile.src
		});
	},

	_tileLoaded: function () {
		this._tilesToLoad--;

		if (this._animated) {
			L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
		}

		if (!this._tilesToLoad) {
			this.fire('load');

			if (this._animated) {
				// clear scaled tiles after all new tiles are loaded (for performance)
				clearTimeout(this._clearBgBufferTimer);
				this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
			}
		}
	},

	_tileOnLoad: function () {
		var layer = this._layer;

		//Only if we are loading an actual image
		if (this.src !== L.Util.emptyImageUrl) {
			L.DomUtil.addClass(this, 'leaflet-tile-loaded');

			layer.fire('tileload', {
				tile: this,
				url: this.src
			});
		}

		layer._tileLoaded();
	},

	_tileOnError: function () {
		var layer = this._layer;

		layer.fire('tileerror', {
			tile: this,
			url: this.src
		});

		var newUrl = layer.options.errorTileUrl;
		if (newUrl) {
			this.src = newUrl;
		}

		layer._tileLoaded();
	}
});

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};


/*
 * L.TileLayer.WMS is used for putting WMS tile layers on the map.
 */

L.TileLayer.WMS = L.TileLayer.extend({

	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',
		version: '1.1.1',
		layers: '',
		styles: '',
		format: 'image/jpeg',
		transparent: false
	},

	initialize: function (url, options) { // (String, Object)

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams),
		    tileSize = options.tileSize || this.options.tileSize;

		if (options.detectRetina && L.Browser.retina) {
			wmsParams.width = wmsParams.height = tileSize * 2;
		} else {
			wmsParams.width = wmsParams.height = tileSize;
		}

		for (var i in options) {
			// all keys that are not TileLayer options go to WMS params
			if (!this.options.hasOwnProperty(i) && i !== 'crs') {
				wmsParams[i] = options[i];
			}
		}

		this.wmsParams = wmsParams;

		L.setOptions(this, options);
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;

		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (tilePoint) { // (Point, Number) -> String

		var map = this._map,
		    tileSize = this.options.tileSize,

		    nwPoint = tilePoint.multiplyBy(tileSize),
		    sePoint = nwPoint.add([tileSize, tileSize]),

		    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
		    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
		    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
		        [se.y, nw.x, nw.y, se.x].join(',') :
		        [nw.x, se.y, se.x, nw.y].join(','),

		    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});

		return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
	},

	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});

L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};


/*
 * L.TileLayer.Canvas is a class that you can use as a base for creating
 * dynamically drawn Canvas-based tile layers.
 */

L.TileLayer.Canvas = L.TileLayer.extend({
	options: {
		async: false
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}

		for (var i in this._tiles) {
			this._redrawTile(this._tiles[i]);
		}
		return this;
	},

	_redrawTile: function (tile) {
		this.drawTile(tile, tile._tilePoint, this._map._zoom);
	},

	_createTile: function () {
		var tile = L.DomUtil.create('canvas', 'leaflet-tile');
		tile.width = tile.height = this.options.tileSize;
		tile.onselectstart = tile.onmousemove = L.Util.falseFn;
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer = this;
		tile._tilePoint = tilePoint;

		this._redrawTile(tile);

		if (!this.options.async) {
			this.tileDrawn(tile);
		}
	},

	drawTile: function (/*tile, tilePoint*/) {
		// override with rendering code
	},

	tileDrawn: function (tile) {
		this._tileOnLoad.call(tile);
	}
});


L.tileLayer.canvas = function (options) {
	return new L.TileLayer.Canvas(options);
};


/*
 * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
 */

L.ImageOverlay = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		opacity: 1
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._image) {
			this._initImage();
		}

		map._panes.overlayPane.appendChild(this._image);

		map.on('viewreset', this._reset, this);

		if (map.options.zoomAnimation && L.Browser.any3d) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._reset();
	},

	onRemove: function (map) {
		map.getPanes().overlayPane.removeChild(this._image);

		map.off('viewreset', this._reset, this);

		if (map.options.zoomAnimation) {
			map.off('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// TODO remove bringToFront/bringToBack duplication from TileLayer/Path
	bringToFront: function () {
		if (this._image) {
			this._map._panes.overlayPane.appendChild(this._image);
		}
		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.overlayPane;
		if (this._image) {
			pane.insertBefore(this._image, pane.firstChild);
		}
		return this;
	},

	setUrl: function (url) {
		this._url = url;
		this._image.src = this._url;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	_initImage: function () {
		this._image = L.DomUtil.create('img', 'leaflet-image-layer');

		if (this._map.options.zoomAnimation && L.Browser.any3d) {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
		} else {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
		}

		this._updateOpacity();

		//TODO createImage util method to remove duplication
		L.extend(this._image, {
			galleryimg: 'no',
			onselectstart: L.Util.falseFn,
			onmousemove: L.Util.falseFn,
			onload: L.bind(this._onImageLoad, this),
			src: this._url
		});
	},

	_animateZoom: function (e) {
		var map = this._map,
		    image = this._image,
		    scale = map.getZoomScale(e.zoom),
		    nw = this._bounds.getNorthWest(),
		    se = this._bounds.getSouthEast(),

		    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
		    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
		    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

		image.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
	},

	_reset: function () {
		var image   = this._image,
		    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);

		L.DomUtil.setPosition(image, topLeft);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_onImageLoad: function () {
		this.fire('load');
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};


/*
 * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
 */

L.Icon = L.Class.extend({
	options: {
		/*
		iconUrl: (String) (required)
		iconRetinaUrl: (String) (optional, used for retina devices if detected)
		iconSize: (Point) (can be set through CSS)
		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
		popupAnchor: (Point) (if not specified, popup opens in the anchor point)
		shadowUrl: (String) (no shadow by default)
		shadowRetinaUrl: (String) (optional, used for retina devices if detected)
		shadowSize: (Point)
		shadowAnchor: (Point)
		*/
		className: ''
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img;
		if (!oldIcon || oldIcon.tagName !== 'IMG') {
			img = this._createImg(src);
		} else {
			img = this._createImg(src, oldIcon);
		}
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options,
		    size = L.point(options[name + 'Size']),
		    anchor;

		if (name === 'shadow') {
			anchor = L.point(options.shadowAnchor || options.iconAnchor);
		} else {
			anchor = L.point(options.iconAnchor);
		}

		if (!anchor && size) {
			anchor = size.divideBy(2, true);
		}

		img.className = 'leaflet-marker-' + name + ' ' + options.className;

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
			return this.options[name + 'RetinaUrl'];
		}
		return this.options[name + 'Url'];
	}
});

L.icon = function (options) {
	return new L.Icon(options);
};


/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],

		shadowSize: [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		if (L.Browser.retina && name === 'icon') {
			name += '-2x';
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, matches, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src;
		matches = src.match(leafletRe);

		if (matches) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());


/*
 * L.Marker is used to display clickable/draggable icons on the map.
 */

L.Marker = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		icon: new L.Icon.Default(),
		title: '',
		alt: '',
		clickable: true,
		draggable: false,
		keyboard: true,
		zIndexOffset: 0,
		opacity: 1,
		riseOnHover: false,
		riseOffset: 250
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._map = map;

		map.on('viewreset', this.update, this);

		this._initIcon();
		this.update();
		this.fire('add');

		if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
			map.on('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		if (this.dragging) {
			this.dragging.disable();
		}

		this._removeIcon();
		this._removeShadow();

		this.fire('remove');

		map.off({
			'viewreset': this.update,
			'zoomanim': this._animateZoom
		}, this);

		this._map = null;
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);

		this.update();

		return this.fire('move', { latlng: this._latlng });
	},

	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		this.update();

		return this;
	},

	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup);
		}

		return this;
	},

	update: function () {
		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    map = this._map,
		    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
		    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		this._initInteraction();

		if (options.riseOnHover) {
			L.DomEvent
				.on(icon, 'mouseover', this._bringToFront, this)
				.on(icon, 'mouseout', this._resetZIndex, this);
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		var panes = this._map._panes;

		if (addIcon) {
			panes.markerPane.appendChild(this._icon);
		}

		if (newShadow && addShadow) {
			panes.shadowPane.appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			L.DomEvent
			    .off(this._icon, 'mouseover', this._bringToFront)
			    .off(this._icon, 'mouseout', this._resetZIndex);
		}

		this._map._panes.markerPane.removeChild(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			this._map._panes.shadowPane.removeChild(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.clickable) { return; }

		// TODO refactor into something shared with Map/Path/etc. to DRY it up

		var icon = this._icon,
		    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];

		L.DomUtil.addClass(icon, 'leaflet-clickable');
		L.DomEvent.on(icon, 'click', this._onMouseClick, this);
		L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);

		for (var i = 0; i < events.length; i++) {
			L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
		}

		if (L.Handler.MarkerDrag) {
			this.dragging = new L.Handler.MarkerDrag(this);

			if (this.options.draggable) {
				this.dragging.enable();
			}
		}
	},

	_onMouseClick: function (e) {
		var wasDragged = this.dragging && this.dragging.moved();

		if (this.hasEventListeners(e.type) || wasDragged) {
			L.DomEvent.stopPropagation(e);
		}

		if (wasDragged) { return; }

		if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});
	},

	_onKeyPress: function (e) {
		if (e.keyCode === 13) {
			this.fire('click', {
				originalEvent: e,
				latlng: this._latlng
			});
		}
	},

	_fireMouseEvent: function (e) {

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});

		// TODO proper custom event propagation
		// this line will always be called if marker is in a FeatureGroup
		if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousedown') {
			L.DomEvent.stopPropagation(e);
		} else {
			L.DomEvent.preventDefault(e);
		}
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._icon, this.options.opacity);
		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, this.options.opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});

L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};


/*
 * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
 * to use with L.Marker.
 */

L.DivIcon = L.Icon.extend({
	options: {
		iconSize: [12, 12], // also can be set through CSS
		/*
		iconAnchor: (Point)
		popupAnchor: (Point)
		html: (String)
		bgPos: (Point)
		*/
		className: 'leaflet-div-icon',
		html: false
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		if (options.html !== false) {
			div.innerHTML = options.html;
		} else {
			div.innerHTML = '';
		}

		if (options.bgPos) {
			div.style.backgroundPosition =
			        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
		}

		this._setIconStyles(div, 'icon');
		return div;
	},

	createShadow: function () {
		return null;
	}
});

L.divIcon = function (options) {
	return new L.DivIcon(options);
};


/*
 * L.Popup is used for displaying popups on the map.
 */

L.Map.mergeOptions({
	closePopupOnClick: true
});

L.Popup = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minWidth: 50,
		maxWidth: 300,
		// maxHeight: null,
		autoPan: true,
		closeButton: true,
		offset: [0, 7],
		autoPanPadding: [5, 5],
		// autoPanPaddingTopLeft: null,
		// autoPanPaddingBottomRight: null,
		keepInView: false,
		className: '',
		zoomAnimation: true
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
		this._animated = L.Browser.any3d && this.options.zoomAnimation;
		this._isOpen = false;
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initLayout();
		}

		var animFade = map.options.fadeAnimation;

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 0);
		}
		map._panes.popupPane.appendChild(this._container);

		map.on(this._getEvents(), this);

		this.update();

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.fire('open');

		map.fire('popupopen', {popup: this});

		if (this._source) {
			this._source.fire('popupopen', {popup: this});
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onRemove: function (map) {
		map._panes.popupPane.removeChild(this._container);

		L.Util.falseFn(this._container.offsetWidth); // force reflow

		map.off(this._getEvents(), this);

		if (map.options.fadeAnimation) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		this._map = null;

		this.fire('close');

		map.fire('popupclose', {popup: this});

		if (this._source) {
			this._source.fire('popupclose', {popup: this});
		}
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	getContent: function () {
		return this._content;
	},

	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	_getEvents: function () {
		var events = {
			viewreset: this._updatePosition
		};

		if (this._animated) {
			events.zoomanim = this._zoomAnimation;
		}
		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}
		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
			containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +
			        (this._animated ? 'animated' : 'hide'),
			container = this._container = L.DomUtil.create('div', containerClass),
			closeButton;

		if (this.options.closeButton) {
			closeButton = this._closeButton =
			        L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';
			L.DomEvent.disableClickPropagation(closeButton);

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper =
		        L.DomUtil.create('div', prefix + '-content-wrapper', container);
		L.DomEvent.disableClickPropagation(wrapper);

		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent.disableScrollPropagation(this._contentNode);
		L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateContent: function () {
		if (!this._content) { return; }

		if (typeof this._content === 'string') {
			this._contentNode.innerHTML = this._content;
		} else {
			while (this._contentNode.hasChildNodes()) {
				this._contentNode.removeChild(this._contentNode.firstChild);
			}
			this._contentNode.appendChild(this._content);
		}
		this.fire('contentupdate');
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    animated = this._animated,
		    offset = L.point(this.options.offset);

		if (animated) {
			L.DomUtil.setPosition(this._container, pos);
		}

		this._containerBottom = -offset.y - (animated ? 0 : pos.y);
		this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = this._containerBottom + 'px';
		this._container.style.left = this._containerLeft + 'px';
	},

	_zoomAnimation: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);

		L.DomUtil.setPosition(this._container, pos);
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,

		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._animated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	}
});

L.popup = function (options, source) {
	return new L.Popup(options, source);
};


L.Map.include({
	openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
		this.closePopup();

		if (!(popup instanceof L.Popup)) {
			var content = popup;

			popup = new L.Popup(options)
			    .setLatLng(latlng)
			    .setContent(content);
		}
		popup._isOpen = true;

		this._popup = popup;
		return this.addLayer(popup);
	},

	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
			popup._isOpen = false;
		}
		return this;
	}
});


/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	openPopup: function () {
		if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
			this._popup.setLatLng(this._latlng);
			this._map.openPopup(this._popup);
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	togglePopup: function () {
		if (this._popup) {
			if (this._popup._isOpen) {
				this.closePopup();
			} else {
				this.openPopup();
			}
		}
		return this;
	},

	bindPopup: function (content, options) {
		var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);

		anchor = anchor.add(L.Popup.prototype.options.offset);

		if (options && options.offset) {
			anchor = anchor.add(options.offset);
		}

		options = L.extend({offset: anchor}, options);

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this.togglePopup, this)
			    .on('remove', this.closePopup, this)
			    .on('move', this._movePopup, this);
			this._popupHandlersAdded = true;
		}

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
		} else {
			this._popup = new L.Popup(options, this)
				.setContent(content);
		}

		return this;
	},

	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this.togglePopup, this)
			    .off('remove', this.closePopup, this)
			    .off('move', this._movePopup, this);
			this._popupHandlersAdded = false;
		}
		return this;
	},

	getPopup: function () {
		return this._popup;
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});


/*
 * L.LayerGroup is a class to combine several layers into one so that
 * you can manipulate the group (e.g. add/remove it) as one layer.
 */

L.LayerGroup = L.Class.extend({
	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	clearLayers: function () {
		this.eachLayer(this.removeLayer, this);
		return this;
	},

	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this._map = map;
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
		this._map = null;
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	getLayer: function (id) {
		return this._layers[id];
	},

	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});

L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};


/*
 * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
 * shared between a group of interactive layers (like vectors or markers).
 */

L.FeatureGroup = L.LayerGroup.extend({
	includes: L.Mixin.Events,

	statics: {
		EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'
	},

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		if ('on' in layer) {
			layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
		}

		L.LayerGroup.prototype.addLayer.call(this, layer);

		if (this._popupContent && layer.bindPopup) {
			layer.bindPopup(this._popupContent, this._popupOptions);
		}

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		if (this._popupContent) {
			this.invoke('unbindPopup');
		}

		return this.fire('layerremove', {layer: layer});
	},

	bindPopup: function (content, options) {
		this._popupContent = content;
		this._popupOptions = options;
		return this.invoke('bindPopup', content, options);
	},

	openPopup: function (latlng) {
		// open popup on the first layer
		for (var id in this._layers) {
			this._layers[id].openPopup(latlng);
			break;
		}
		return this;
	},

	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();

		this.eachLayer(function (layer) {
			bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
		});

		return bounds;
	},

	_propagateEvent: function (e) {
		e = L.extend({
			layer: e.target,
			target: this
		}, e);
		this.fire(e.type, e);
	}
});

L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};


/*
 * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
 */

L.Path = L.Class.extend({
	includes: [L.Mixin.Events],

	statics: {
		// how much to extend the clip area around the map view
		// (relative to its size, e.g. 0.5 is half the screen in each direction)
		// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
		CLIP_PADDING: (function () {
			var max = L.Browser.mobile ? 1280 : 2000,
			    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
			return Math.max(0, Math.min(0.5, target));
		})()
	},

	options: {
		stroke: true,
		color: '#0033ff',
		dashArray: null,
		lineCap: null,
		lineJoin: null,
		weight: 5,
		opacity: 0.5,

		fill: false,
		fillColor: null, //same as color by default
		fillOpacity: 0.2,

		clickable: true
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initElements();
			this._initEvents();
		}

		this.projectLatlngs();
		this._updatePath();

		if (this._container) {
			this._map._pathRoot.appendChild(this._container);
		}

		this.fire('add');

		map.on({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		map._pathRoot.removeChild(this._container);

		// Need to fire remove event before we set _map to null as the event hooks might need the object
		this.fire('remove');
		this._map = null;

		if (L.Browser.vml) {
			this._container = null;
			this._stroke = null;
			this._fill = null;
		}

		map.off({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	projectLatlngs: function () {
		// do all projection stuff here
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._container) {
			this._updateStyle();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._updatePath();
		}
		return this;
	}
});

L.Map.include({
	_updatePathViewport: function () {
		var p = L.Path.CLIP_PADDING,
		    size = this.getSize(),
		    panePos = L.DomUtil.getPosition(this._mapPane),
		    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
		    max = min.add(size.multiplyBy(1 + p * 2)._round());

		this._pathViewport = new L.Bounds(min, max);
	}
});


/*
 * Extends L.Path with SVG-specific rendering code.
 */

L.Path.SVG_NS = 'http://www.w3.org/2000/svg';

L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);

L.Path = L.Path.extend({
	statics: {
		SVG: L.Browser.svg
	},

	bringToFront: function () {
		var root = this._map._pathRoot,
		    path = this._container;

		if (path && root.lastChild !== path) {
			root.appendChild(path);
		}
		return this;
	},

	bringToBack: function () {
		var root = this._map._pathRoot,
		    path = this._container,
		    first = root.firstChild;

		if (path && first !== path) {
			root.insertBefore(path, first);
		}
		return this;
	},

	getPathString: function () {
		// form path string here
	},

	_createElement: function (name) {
		return document.createElementNS(L.Path.SVG_NS, name);
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._initPath();
		this._initStyle();
	},

	_initPath: function () {
		this._container = this._createElement('g');

		this._path = this._createElement('path');

		if (this.options.className) {
			L.DomUtil.addClass(this._path, this.options.className);
		}

		this._container.appendChild(this._path);
	},

	_initStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke-linejoin', 'round');
			this._path.setAttribute('stroke-linecap', 'round');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill-rule', 'evenodd');
		}
		if (this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', this.options.pointerEvents);
		}
		if (!this.options.clickable && !this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', 'none');
		}
		this._updateStyle();
	},

	_updateStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke', this.options.color);
			this._path.setAttribute('stroke-opacity', this.options.opacity);
			this._path.setAttribute('stroke-width', this.options.weight);
			if (this.options.dashArray) {
				this._path.setAttribute('stroke-dasharray', this.options.dashArray);
			} else {
				this._path.removeAttribute('stroke-dasharray');
			}
			if (this.options.lineCap) {
				this._path.setAttribute('stroke-linecap', this.options.lineCap);
			}
			if (this.options.lineJoin) {
				this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
			}
		} else {
			this._path.setAttribute('stroke', 'none');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill', this.options.fillColor || this.options.color);
			this._path.setAttribute('fill-opacity', this.options.fillOpacity);
		} else {
			this._path.setAttribute('fill', 'none');
		}
	},

	_updatePath: function () {
		var str = this.getPathString();
		if (!str) {
			// fix webkit empty string parsing bug
			str = 'M0 0';
		}
		this._path.setAttribute('d', str);
	},

	// TODO remove duplication with L.Map
	_initEvents: function () {
		if (this.options.clickable) {
			if (L.Browser.svg || !L.Browser.vml) {
				L.DomUtil.addClass(this._path, 'leaflet-clickable');
			}

			L.DomEvent.on(this._container, 'click', this._onMouseClick, this);

			var events = ['dblclick', 'mousedown', 'mouseover',
			              'mouseout', 'mousemove', 'contextmenu'];
			for (var i = 0; i < events.length; i++) {
				L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
			}
		}
	},

	_onMouseClick: function (e) {
		if (this._map.dragging && this._map.dragging.moved()) { return; }

		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this.hasEventListeners(e.type)) { return; }

		var map = this._map,
		    containerPoint = map.mouseEventToContainerPoint(e),
		    layerPoint = map.containerPointToLayerPoint(containerPoint),
		    latlng = map.layerPointToLatLng(layerPoint);

		this.fire(e.type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});

		if (e.type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousemove') {
			L.DomEvent.stopPropagation(e);
		}
	}
});

L.Map.include({
	_initPathRoot: function () {
		if (!this._pathRoot) {
			this._pathRoot = L.Path.prototype._createElement('svg');
			this._panes.overlayPane.appendChild(this._pathRoot);

			if (this.options.zoomAnimation && L.Browser.any3d) {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');

				this.on({
					'zoomanim': this._animatePathZoom,
					'zoomend': this._endPathZoom
				});
			} else {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
			}

			this.on('moveend', this._updateSvgViewport);
			this._updateSvgViewport();
		}
	},

	_animatePathZoom: function (e) {
		var scale = this.getZoomScale(e.zoom),
		    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);

		this._pathRoot.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';

		this._pathZooming = true;
	},

	_endPathZoom: function () {
		this._pathZooming = false;
	},

	_updateSvgViewport: function () {

		if (this._pathZooming) {
			// Do not update SVGs while a zoom animation is going on otherwise the animation will break.
			// When the zoom animation ends we will be updated again anyway
			// This fixes the case where you do a momentum move and zoom while the move is still ongoing.
			return;
		}

		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    max = vp.max,
		    width = max.x - min.x,
		    height = max.y - min.y,
		    root = this._pathRoot,
		    pane = this._panes.overlayPane;

		// Hack to make flicker on drag end on mobile webkit less irritating
		if (L.Browser.mobileWebkit) {
			pane.removeChild(root);
		}

		L.DomUtil.setPosition(root, min);
		root.setAttribute('width', width);
		root.setAttribute('height', height);
		root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));

		if (L.Browser.mobileWebkit) {
			pane.appendChild(root);
		}
	}
});


/*
 * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
 */

L.Path.include({

	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			this._popup = content;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this._openPopup, this)
			    .on('remove', this.closePopup, this);

			this._popupHandlersAdded = true;
		}

		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this._openPopup)
			    .off('remove', this.closePopup);

			this._popupHandlersAdded = false;
		}
		return this;
	},

	openPopup: function (latlng) {

		if (this._popup) {
			// open the popup from one of the path's points if not specified
			latlng = latlng || this._latlng ||
			         this._latlngs[Math.floor(this._latlngs.length / 2)];

			this._openPopup({latlng: latlng});
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	_openPopup: function (e) {
		this._popup.setLatLng(e.latlng);
		this._map.openPopup(this._popup);
	}
});


/*
 * Vector rendering for IE6-8 through VML.
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
	statics: {
		VML: true,
		CLIP_PADDING: 0.02
	},

	_createElement: (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement(
				        '<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	}()),

	_initPath: function () {
		var container = this._container = this._createElement('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape' +
			(this.options.className ? ' ' + this.options.className : ''));

		if (this.options.clickable) {
			L.DomUtil.addClass(container, 'leaflet-clickable');
		}

		container.coordsize = '1 1';

		this._path = this._createElement('path');
		container.appendChild(this._path);

		this._map._pathRoot.appendChild(container);
	},

	_initStyle: function () {
		this._updateStyle();
	},

	_updateStyle: function () {
		var stroke = this._stroke,
		    fill = this._fill,
		    options = this.options,
		    container = this._container;

		container.stroked = options.stroke;
		container.filled = options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = this._stroke = this._createElement('stroke');
				stroke.endcap = 'round';
				container.appendChild(stroke);
			}
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			if (options.lineCap) {
				stroke.endcap = options.lineCap.replace('butt', 'flat');
			}
			if (options.lineJoin) {
				stroke.joinstyle = options.lineJoin;
			}

		} else if (stroke) {
			container.removeChild(stroke);
			this._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = this._fill = this._createElement('fill');
				container.appendChild(fill);
			}
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			this._fill = null;
		}
	},

	_updatePath: function () {
		var style = this._container.style;

		style.display = 'none';
		this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug
		style.display = '';
	}
});

L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
	_initPathRoot: function () {
		if (this._pathRoot) { return; }

		var root = this._pathRoot = document.createElement('div');
		root.className = 'leaflet-vml-container';
		this._panes.overlayPane.appendChild(root);

		this.on('moveend', this._updatePathViewport);
		this._updatePathViewport();
	}
});


/*
 * Vector rendering for all browsers that support canvas.
 */

L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
	statics: {
		//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
		CANVAS: true,
		SVG: false
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._requestUpdate();
		}
		return this;
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._map) {
			this._updateStyle();
			this._requestUpdate();
		}
		return this;
	},

	onRemove: function (map) {
		map
		    .off('viewreset', this.projectLatlngs, this)
		    .off('moveend', this._updatePath, this);

		if (this.options.clickable) {
			this._map.off('click', this._onClick, this);
			this._map.off('mousemove', this._onMouseMove, this);
		}

		this._requestUpdate();

		this._map = null;
	},

	_requestUpdate: function () {
		if (this._map && !L.Path._updateRequest) {
			L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
		}
	},

	_fireMapMoveEnd: function () {
		L.Path._updateRequest = null;
		this.fire('moveend');
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._ctx = this._map._canvasCtx;
	},

	_updateStyle: function () {
		var options = this.options;

		if (options.stroke) {
			this._ctx.lineWidth = options.weight;
			this._ctx.strokeStyle = options.color;
		}
		if (options.fill) {
			this._ctx.fillStyle = options.fillColor || options.color;
		}
	},

	_drawPath: function () {
		var i, j, len, len2, point, drawMethod;

		this._ctx.beginPath();

		for (i = 0, len = this._parts.length; i < len; i++) {
			for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
				point = this._parts[i][j];
				drawMethod = (j === 0 ? 'move' : 'line') + 'To';

				this._ctx[drawMethod](point.x, point.y);
			}
			// TODO refactor ugly hack
			if (this instanceof L.Polygon) {
				this._ctx.closePath();
			}
		}
	},

	_checkIfEmpty: function () {
		return !this._parts.length;
	},

	_updatePath: function () {
		if (this._checkIfEmpty()) { return; }

		var ctx = this._ctx,
		    options = this.options;

		this._drawPath();
		ctx.save();
		this._updateStyle();

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fill();
		}

		if (options.stroke) {
			ctx.globalAlpha = options.opacity;
			ctx.stroke();
		}

		ctx.restore();

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_initEvents: function () {
		if (this.options.clickable) {
			// TODO dblclick
			this._map.on('mousemove', this._onMouseMove, this);
			this._map.on('click', this._onClick, this);
		}
	},

	_onClick: function (e) {
		if (this._containsPoint(e.layerPoint)) {
			this.fire('click', e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map._animatingZoom) { return; }

		// TODO don't do on each move
		if (this._containsPoint(e.layerPoint)) {
			this._ctx.canvas.style.cursor = 'pointer';
			this._mouseInside = true;
			this.fire('mouseover', e);

		} else if (this._mouseInside) {
			this._ctx.canvas.style.cursor = '';
			this._mouseInside = false;
			this.fire('mouseout', e);
		}
	}
});

L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
	_initPathRoot: function () {
		var root = this._pathRoot,
		    ctx;

		if (!root) {
			root = this._pathRoot = document.createElement('canvas');
			root.style.position = 'absolute';
			ctx = this._canvasCtx = root.getContext('2d');

			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';

			this._panes.overlayPane.appendChild(root);

			if (this.options.zoomAnimation) {
				this._pathRoot.className = 'leaflet-zoom-animated';
				this.on('zoomanim', this._animatePathZoom);
				this.on('zoomend', this._endPathZoom);
			}
			this.on('moveend', this._updateCanvasViewport);
			this._updateCanvasViewport();
		}
	},

	_updateCanvasViewport: function () {
		// don't redraw while zooming. See _updateSvgViewport for more details
		if (this._pathZooming) { return; }
		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    size = vp.max.subtract(min),
		    root = this._pathRoot;

		//TODO check if this works properly on mobile webkit
		L.DomUtil.setPosition(root, min);
		root.width = size.x;
		root.height = size.y;
		root.getContext('2d').translate(-min.x, -min.y);
	}
});


/*
 * L.LineUtil contains different utility functions for line segments
 * and polylines (clipping, simplification, distances, etc.)
 */

/*jshint bitwise:false */ // allow bitwise operations for this file

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// distance from a point to a segment between two points
	pointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},

	// Cohen-Sutherland line clipping algorithm.
	// Used to avoid rendering parts of a polyline that are not currently visible.

	clipSegment: function (a, b, bounds, useLastCode) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			// if a,b is outside the clip window (trivial reject)
			} else if (codeA & codeB) {
				return false;
			// other cases
			} else {
				codeOut = codeA || codeB;
				p = this._getEdgeIntersection(a, b, codeOut, bounds);
				newCode = this._getBitCode(p, bounds);

				if (codeOut === codeA) {
					a = p;
					codeA = newCode;
				} else {
					b = p;
					codeB = newCode;
				}
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max;

		if (code & 8) { // top
			return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
		} else if (code & 4) { // bottom
			return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
		} else if (code & 2) { // right
			return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
		} else if (code & 1) { // left
			return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
		}
	},

	_getBitCode: function (/*Point*/ p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}
		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};


/*
 * L.Polyline is used to display polylines on a map.
 */

L.Polyline = L.Path.extend({
	initialize: function (latlngs, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlngs = this._convertLatLngs(latlngs);
	},

	options: {
		// how much to simplify the polyline on each zoom level
		// more = better performance and smoother look, less = more accurate
		smoothFactor: 1.0,
		noClip: false
	},

	projectLatlngs: function () {
		this._originalPoints = [];

		for (var i = 0, len = this._latlngs.length; i < len; i++) {
			this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
		}
	},

	getPathString: function () {
		for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {
			str += this._getPathPartStr(this._parts[i]);
		}
		return str;
	},

	getLatLngs: function () {
		return this._latlngs;
	},

	setLatLngs: function (latlngs) {
		this._latlngs = this._convertLatLngs(latlngs);
		return this.redraw();
	},

	addLatLng: function (latlng) {
		this._latlngs.push(L.latLng(latlng));
		return this.redraw();
	},

	spliceLatLngs: function () { // (Number index, Number howMany)
		var removed = [].splice.apply(this._latlngs, arguments);
		this._convertLatLngs(this._latlngs, true);
		this.redraw();
		return removed;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;

		for (var j = 0, jLen = parts.length; j < jLen; j++) {
			var points = parts[j];
			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];
				var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	getBounds: function () {
		return new L.LatLngBounds(this.getLatLngs());
	},

	_convertLatLngs: function (latlngs, overwrite) {
		var i, len, target = overwrite ? latlngs : [];

		for (i = 0, len = latlngs.length; i < len; i++) {
			if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
				return;
			}
			target[i] = L.latLng(latlngs[i]);
		}
		return target;
	},

	_initEvents: function () {
		L.Path.prototype._initEvents.call(this);
	},

	_getPathPartStr: function (points) {
		var round = L.Path.VML;

		for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {
			p = points[j];
			if (round) {
				p._round();
			}
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}
		return str;
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    len = points.length,
		    i, k, segment;

		if (this.options.noClip) {
			this._parts = [points];
			return;
		}

		this._parts = [];

		var parts = this._parts,
		    vp = this._map._pathViewport,
		    lu = L.LineUtil;

		for (i = 0, k = 0; i < len - 1; i++) {
			segment = lu.clipSegment(points[i], points[i + 1], vp, i);
			if (!segment) {
				continue;
			}

			parts[k] = parts[k] || [];
			parts[k].push(segment[0]);

			// if segment goes out of screen, or it's the last one, it's the end of the line part
			if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
				parts[k].push(segment[1]);
				k++;
			}
		}
	},

	// simplify each clipped part of the polyline
	_simplifyPoints: function () {
		var parts = this._parts,
		    lu = L.LineUtil;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
		}
	},

	_updatePath: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();

		L.Path.prototype._updatePath.call(this);
	}
});

L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};


/*
 * L.PolyUtil contains utility functions for polygons (clipping, etc.).
 */

/*jshint bitwise:false */ // allow bitwise operations here

L.PolyUtil = {};

/*
 * Sutherland-Hodgeman polygon clipping algorithm.
 * Used to avoid rendering parts of a polygon that are not currently visible.
 */
L.PolyUtil.clipPolygon = function (points, bounds) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};


/*
 * L.Polygon is used to display polygons on a map.
 */

L.Polygon = L.Polyline.extend({
	options: {
		fill: true
	},

	initialize: function (latlngs, options) {
		L.Polyline.prototype.initialize.call(this, latlngs, options);
		this._initWithHoles(latlngs);
	},

	_initWithHoles: function (latlngs) {
		var i, len, hole;
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._latlngs = this._convertLatLngs(latlngs[0]);
			this._holes = latlngs.slice(1);

			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
				if (hole[0].equals(hole[hole.length - 1])) {
					hole.pop();
				}
			}
		}

		// filter out last point if its equal to the first one
		latlngs = this._latlngs;

		if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
			latlngs.pop();
		}
	},

	projectLatlngs: function () {
		L.Polyline.prototype.projectLatlngs.call(this);

		// project polygon holes points
		// TODO move this logic to Polyline to get rid of duplication
		this._holePoints = [];

		if (!this._holes) { return; }

		var i, j, len, len2;

		for (i = 0, len = this._holes.length; i < len; i++) {
			this._holePoints[i] = [];

			for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
				this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
			}
		}
	},

	setLatLngs: function (latlngs) {
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._initWithHoles(latlngs);
			return this.redraw();
		} else {
			return L.Polyline.prototype.setLatLngs.call(this, latlngs);
		}
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    newParts = [];

		this._parts = [points].concat(this._holePoints);

		if (this.options.noClip) { return; }

		for (var i = 0, len = this._parts.length; i < len; i++) {
			var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
			if (clipped.length) {
				newParts.push(clipped);
			}
		}

		this._parts = newParts;
	},

	_getPathPartStr: function (points) {
		var str = L.Polyline.prototype._getPathPartStr.call(this, points);
		return str + (L.Browser.svg ? 'z' : 'x');
	}
});

L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};


/*
 * Contains L.MultiPolyline and L.MultiPolygon layers.
 */

(function () {
	function createMulti(Klass) {

		return L.FeatureGroup.extend({

			initialize: function (latlngs, options) {
				this._layers = {};
				this._options = options;
				this.setLatLngs(latlngs);
			},

			setLatLngs: function (latlngs) {
				var i = 0,
				    len = latlngs.length;

				this.eachLayer(function (layer) {
					if (i < len) {
						layer.setLatLngs(latlngs[i++]);
					} else {
						this.removeLayer(layer);
					}
				}, this);

				while (i < len) {
					this.addLayer(new Klass(latlngs[i++], this._options));
				}

				return this;
			},

			getLatLngs: function () {
				var latlngs = [];

				this.eachLayer(function (layer) {
					latlngs.push(layer.getLatLngs());
				});

				return latlngs;
			}
		});
	}

	L.MultiPolyline = createMulti(L.Polyline);
	L.MultiPolygon = createMulti(L.Polygon);

	L.multiPolyline = function (latlngs, options) {
		return new L.MultiPolyline(latlngs, options);
	};

	L.multiPolygon = function (latlngs, options) {
		return new L.MultiPolygon(latlngs, options);
	};
}());


/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	setBounds: function (latLngBounds) {
		this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});

L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};


/*
 * L.Circle is a circle overlay (with a certain radius in meters).
 */

L.Circle = L.Path.extend({
	initialize: function (latlng, radius, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlng = L.latLng(latlng);
		this._mRadius = radius;
	},

	options: {
		fill: true
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		return this.redraw();
	},

	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	projectLatlngs: function () {
		var lngRadius = this._getLngRadius(),
		    latlng = this._latlng,
		    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);

		this._point = this._map.latLngToLayerPoint(latlng);
		this._radius = Math.max(this._point.x - pointLeft.x, 1);
	},

	getBounds: function () {
		var lngRadius = this._getLngRadius(),
		    latRadius = (this._mRadius / 40075017) * 360,
		    latlng = this._latlng;

		return new L.LatLngBounds(
		        [latlng.lat - latRadius, latlng.lng - lngRadius],
		        [latlng.lat + latRadius, latlng.lng + lngRadius]);
	},

	getLatLng: function () {
		return this._latlng;
	},

	getPathString: function () {
		var p = this._point,
		    r = this._radius;

		if (this._checkIfEmpty()) {
			return '';
		}

		if (L.Browser.svg) {
			return 'M' + p.x + ',' + (p.y - r) +
			       'A' + r + ',' + r + ',0,1,1,' +
			       (p.x - 0.1) + ',' + (p.y - r) + ' z';
		} else {
			p._round();
			r = Math.round(r);
			return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
		}
	},

	getRadius: function () {
		return this._mRadius;
	},

	// TODO Earth hardcoded, move into projection code!

	_getLatRadius: function () {
		return (this._mRadius / 40075017) * 360;
	},

	_getLngRadius: function () {
		return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
	},

	_checkIfEmpty: function () {
		if (!this._map) {
			return false;
		}
		var vp = this._map._pathViewport,
		    r = this._radius,
		    p = this._point;

		return p.x - r > vp.max.x || p.y - r > vp.max.y ||
		       p.x + r < vp.min.x || p.y + r < vp.min.y;
	}
});

L.circle = function (latlng, radius, options) {
	return new L.Circle(latlng, radius, options);
};


/*
 * L.CircleMarker is a circle overlay with a permanent pixel radius.
 */

L.CircleMarker = L.Circle.extend({
	options: {
		radius: 10,
		weight: 2
	},

	initialize: function (latlng, options) {
		L.Circle.prototype.initialize.call(this, latlng, null, options);
		this._radius = this.options.radius;
	},

	projectLatlngs: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
	},

	_updateStyle : function () {
		L.Circle.prototype._updateStyle.call(this);
		this.setRadius(this.options.radius);
	},

	setLatLng: function (latlng) {
		L.Circle.prototype.setLatLng.call(this, latlng);
		if (this._popup && this._popup._isOpen) {
			this._popup.setLatLng(latlng);
		}
		return this;
	},

	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._radius;
	}
});

L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};


/*
 * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
 */

L.Polyline.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, dist, part,
		    w = this.options.weight / 2;

		if (L.Browser.touch) {
			w += 10; // polyline click tolerance on touch devices
		}

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];
			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) {
					continue;
				}

				dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

				if (dist <= w) {
					return true;
				}
			}
		}
		return false;
	}
});


/*
 * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
 */

L.Polygon.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p) {
		var inside = false,
		    part, p1, p2,
		    i, j, k,
		    len, len2;

		// TODO optimization: check if within bounds first

		if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
			// click on polygon border
			return true;
		}

		// ray casting algorithm for detecting if point is in polygon

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) &&
						(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		return inside;
	}
});


/*
 * Extends L.Circle with Canvas-specific code.
 */

L.Circle.include(!L.Path.CANVAS ? {} : {
	_drawPath: function () {
		var p = this._point;
		this._ctx.beginPath();
		this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
	},

	_containsPoint: function (p) {
		var center = this._point,
		    w2 = this.options.stroke ? this.options.weight / 2 : 0;

		return (p.distanceTo(center) <= this._radius + w2);
	}
});


/*
 * CircleMarker canvas specific drawing parts.
 */

L.CircleMarker.include(!L.Path.CANVAS ? {} : {
	_updateStyle: function () {
		L.Path.prototype._updateStyle.call(this);
	}
});


/*
 * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
 */

L.GeoJSON = L.FeatureGroup.extend({

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// Only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(features[i]);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	resetStyle: function (layer) {
		var style = this.options.style;
		if (style) {
			// reset any custom styles
			L.Util.extend(layer.options, layer.defaultOptions);

			this._setLayerStyle(layer, style);
		}
	},

	setStyle: function (style) {
		this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

L.extend(L.GeoJSON, {
	geometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry.coordinates,
		    layers = [],
		    latlng, latlngs, i, len;

		coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
			latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
			return new L.Polyline(latlngs, vectorOptions);

		case 'Polygon':
			if (coords.length === 2 && !coords[1].length) {
				throw new Error('Invalid GeoJSON object.');
			}
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.Polygon(latlngs, vectorOptions);

		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.MultiPolyline(latlngs, vectorOptions);

		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
			return new L.MultiPolygon(latlngs, vectorOptions);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {

				layers.push(this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, pointToLayer, coordsToLatLng, vectorOptions));
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	coordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
		var latlng, i, len,
		    latlngs = [];

		for (i = 0, len = coords.length; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	latLngToCoords: function (latlng) {
		var coords = [latlng.lng, latlng.lat];

		if (latlng.alt !== undefined) {
			coords.push(latlng.alt);
		}
		return coords;
	},

	latLngsToCoords: function (latLngs) {
		var coords = [];

		for (var i = 0, len = latLngs.length; i < len; i++) {
			coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);
	},

	asFeature: function (geoJSON) {
		if (geoJSON.type === 'Feature') {
			return geoJSON;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geoJSON
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);

L.Polyline.include({
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'LineString',
			coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
		});
	}
});

L.Polygon.include({
	toGeoJSON: function () {
		var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
		    i, len, hole;

		coords[0].push(coords[0][0]);

		if (this._holes) {
			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
				hole.push(hole[0]);
				coords.push(hole);
			}
		}

		return L.GeoJSON.getFeature(this, {
			type: 'Polygon',
			coordinates: coords
		});
	}
});

(function () {
	function multiToGeoJSON(type) {
		return function () {
			var coords = [];

			this.eachLayer(function (layer) {
				coords.push(layer.toGeoJSON().geometry.coordinates);
			});

			return L.GeoJSON.getFeature(this, {
				type: type,
				coordinates: coords
			});
		};
	}

	L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});
	L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});

	L.LayerGroup.include({
		toGeoJSON: function () {

			var geometry = this.feature && this.feature.geometry,
				jsons = [],
				json;

			if (geometry && geometry.type === 'MultiPoint') {
				return multiToGeoJSON('MultiPoint').call(this);
			}

			var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';

			this.eachLayer(function (layer) {
				if (layer.toGeoJSON) {
					json = layer.toGeoJSON();
					jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
				}
			});

			if (isGeometryCollection) {
				return L.GeoJSON.getFeature(this, {
					geometries: jsons,
					type: 'GeometryCollection'
				});
			}

			return {
				type: 'FeatureCollection',
				features: jsons
			};
		}
	});
}());

L.geoJson = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};


/*
 * L.DomEvent contains functions for working with DOM events.
 */

L.DomEvent = {
	/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
	addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler, originalHandler, newType;

		if (obj[key]) { return this; }

		handler = function (e) {
			return fn.call(context || obj, e || L.DomEvent._getEvent());
		};

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			return this.addPointerListener(obj, type, handler, id);
		}
		if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);
		}

		if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('DOMMouseScroll', handler, false);
				obj.addEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {

				originalHandler = handler;
				newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

				handler = function (e) {
					if (!L.DomEvent._checkMouse(obj, e)) { return; }
					return originalHandler(e);
				};

				obj.addEventListener(newType, handler, false);

			} else if (type === 'click' && L.Browser.android) {
				originalHandler = handler;
				handler = function (e) {
					return L.DomEvent._filterClick(e, originalHandler);
				};

				obj.addEventListener(type, handler, false);
			} else {
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[key] = handler;

		return this;
	},

	removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler = obj[key];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);
		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('DOMMouseScroll', handler, false);
				obj.removeEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
			} else {
				obj.removeEventListener(type, handler, false);
			}
		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[key] = null;

		return this;
	},

	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	disableScrollPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		return L.DomEvent
			.on(el, 'mousewheel', stop)
			.on(el, 'MozMousePixelScroll', stop);
	},

	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(el, L.Draggable.START[i], stop);
		}

		return L.DomEvent
			.on(el, 'click', L.DomEvent._fakeStop)
			.on(el, 'dblclick', stop);
	},

	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	getWheelDelta: function (e) {

		var delta = 0;

		if (e.wheelDelta) {
			delta = e.wheelDelta / 120;
		}
		if (e.detail) {
			delta = -e.detail / 3;
		}
		return delta;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_checkMouse: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	_getEvent: function () { // evil magic for IE
		/*jshint noarg:false */
		var e = window.event;
		if (!e) {
			var caller = arguments.callee.caller;
			while (caller) {
				e = caller['arguments'][0];
				if (e && window.Event === e.constructor) {
					break;
				}
				caller = caller.caller;
			}
		}
		return e;
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
			elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 1000ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 1000) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		return handler(e);
	}
};

L.DomEvent.on = L.DomEvent.addListener;
L.DomEvent.off = L.DomEvent.removeListener;


/*
 * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
 */

L.Draggable = L.Class.extend({
	includes: L.Mixin.Events,

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	initialize: function (element, dragStartTarget) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
	},

	enable: function () {
		if (this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = true;
	},

	disable: function () {
		if (!this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		this._moved = false;

		if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

		L.DomEvent.stopPropagation(e);

		if (L.Draggable._disabled) { return; }

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);
		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

		L.DomEvent
		    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
		    .on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');
			L.DomUtil.addClass((e.target || e.srcElement), 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
	},

	_updatePosition: function () {
		this.fire('predrag');
		L.DomUtil.setPosition(this._element, this._newPos);
		this.fire('drag');
	},

	_onUp: function (e) {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');
		L.DomUtil.removeClass((e.target || e.srcElement), 'leaflet-drag-target');

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
			    .off(document, L.Draggable.MOVE[i], this._onMove)
			    .off(document, L.Draggable.END[i], this._onUp);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
	}
});


/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	enable: function () {
		if (this._enabled) { return; }

		this._enabled = true;
		this.addHooks();
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._enabled = false;
		this.removeHooks();
	},

	enabled: function () {
		return !!this._enabled;
	}
});


/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

L.Map.mergeOptions({
	dragging: true,

	inertia: !L.Browser.android23,
	inertiaDeceleration: 3400, // px/s^2
	inertiaMaxSpeed: Infinity, // px/s
	inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
	easeLinearity: 0.25,

	// TODO refactor, move to CRS
	worldCopyJump: false
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				'dragstart': this._onDragStart,
				'drag': this._onDrag,
				'dragend': this._onDragEnd
			}, this);

			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDrag, this);
				map.on('viewreset', this._onViewReset, this);

				map.whenReady(this._onViewReset, this);
			}
		}
		this._draggable.enable();
	},

	removeHooks: function () {
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		var map = this._map;

		if (map._panAnim) {
			map._panAnim.stop();
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function () {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 200) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move')
		    .fire('drag');
	},

	_onViewReset: function () {
		// TODO fix hardcoded Earth values
		var pxCenter = this._map.getSize()._divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.project([0, 180]).x;
	},

	_onPreDrag: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,
		    delay = +new Date() - this._lastTime,

		    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime + delay - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x || !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true
					});
				});
			}
		}
	}
});

L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

L.Map.mergeOptions({
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

L.Map.mergeOptions({
	scrollWheelZoom: true
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
		L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
		L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(40 - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.preventDefault(e);
		L.DomEvent.stopPropagation(e);
	},

	_performZoom: function () {
		var map = this._map,
		    delta = this._delta,
		    zoom = map.getZoom();

		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
		delta = Math.max(Math.min(delta, 4), -4);
		delta = map._limitZoom(zoom + delta) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last,
		    doubleTap = false,
		    delay = 250,
		    touch,
		    pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend,
		    trackedTouches = [];

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				trackedTouches.push(e.pointerId);
				count = trackedTouches.length;
			} else {
				count = e.touches.length;
			}
			if (count > 1) {
				return;
			}

			var now = Date.now(),
				delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (L.Browser.pointer) {
				var idx = trackedTouches.indexOf(e.pointerId);
				if (idx === -1) {
					return;
				}
				trackedTouches.splice(idx, 1);
			}

			if (doubleTap) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = { },
						prop;

					// jshint forin:false
					for (var i in touch) {
						prop = touch[i];
						if (typeof prop === 'function') {
							newTouch[i] = prop.bind(touch);
						} else {
							newTouch[i] = prop;
						}
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}
		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;

		// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
		// will not come through to us, so we will lose track of how many touches are ongoing
		var endElement = L.Browser.pointer ? document.documentElement : obj;

		obj.addEventListener(touchstart, onTouchStart, false);
		endElement.addEventListener(touchend, onTouchEnd, false);

		if (L.Browser.pointer) {
			endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_';

		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
		(L.Browser.pointer ? document.documentElement : obj).removeEventListener(
		        this._touchend, obj[pre + this._touchend + id], false);

		if (L.Browser.pointer) {
			document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],
				false);
		}

		return this;
	}
});


/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	//static
	POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
	POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
	POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

	_pointers: [],
	_pointerDocumentListener: false,

	// Provides a touch events wrapper for (ms)pointer events.
	// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
	//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		switch (type) {
		case 'touchstart':
			return this.addPointerListenerStart(obj, type, handler, id);
		case 'touchend':
			return this.addPointerListenerEnd(obj, type, handler, id);
		case 'touchmove':
			return this.addPointerListenerMove(obj, type, handler, id);
		default:
			throw 'Unknown touch event type';
		}
	},

	addPointerListenerStart: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    pointers = this._pointers;

		var cb = function (e) {

			L.DomEvent.preventDefault(e);

			var alreadyInArray = false;
			for (var i = 0; i < pointers.length; i++) {
				if (pointers[i].pointerId === e.pointerId) {
					alreadyInArray = true;
					break;
				}
			}
			if (!alreadyInArray) {
				pointers.push(e);
			}

			e.touches = pointers.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchstart' + id] = cb;
		obj.addEventListener(this.POINTER_DOWN, cb, false);

		// need to also listen for end events to keep the _pointers list accurate
		// this needs to be on the body and never go away
		if (!this._pointerDocumentListener) {
			var internalCb = function (e) {
				for (var i = 0; i < pointers.length; i++) {
					if (pointers[i].pointerId === e.pointerId) {
						pointers.splice(i, 1);
						break;
					}
				}
			};
			//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
			document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);

			this._pointerDocumentListener = true;
		}

		return this;
	},

	addPointerListenerMove: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		function cb(e) {

			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches[i] = e;
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		}

		obj[pre + 'touchmove' + id] = cb;
		obj.addEventListener(this.POINTER_MOVE, cb, false);

		return this;
	},

	addPointerListenerEnd: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		var cb = function (e) {
			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches.splice(i, 1);
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchend' + id] = cb;
		obj.addEventListener(this.POINTER_UP, cb, false);
		obj.addEventListener(this.POINTER_CANCEL, cb, false);

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var pre = '_leaflet_',
		    cb = obj[pre + type + id];

		switch (type) {
		case 'touchstart':
			obj.removeEventListener(this.POINTER_DOWN, cb, false);
			break;
		case 'touchmove':
			obj.removeEventListener(this.POINTER_MOVE, cb, false);
			break;
		case 'touchend':
			obj.removeEventListener(this.POINTER_UP, cb, false);
			obj.removeEventListener(this.POINTER_CANCEL, cb, false);
			break;
		}

		return this;
	}
});


/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

L.Map.mergeOptions({
	touchZoom: L.Browser.touch && !L.Browser.android23,
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]),
		    viewCenter = map._getCenterLayerPoint();

		this._startCenter = p1.add(p2)._divideBy(2);
		this._startDist = p1.distanceTo(p2);

		this._moved = false;
		this._zooming = true;

		this._centerOffset = viewCenter.subtract(this._startCenter);

		if (map._panAnim) {
			map._panAnim.stop();
		}

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]);

		this._scale = p1.distanceTo(p2) / this._startDist;
		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

		if (this._scale === 1) { return; }

		if (!map.options.bounceAtZoomLimits) {
			if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
			    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }
		}

		if (!this._moved) {
			L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

			map
			    .fire('movestart')
			    .fire('zoomstart');

			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(
		        this._updateOnMove, this, true, this._map._container);

		L.DomEvent.preventDefault(e);
	},

	_updateOnMove: function () {
		var map = this._map,
		    origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),
		    zoom = map.getScaleZoom(this._scale);

		map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		var map = this._map;

		this._zooming = false;
		L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		var origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),

		    oldZoom = map.getZoom(),
		    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
		    roundZoomDelta = (floatZoomDelta > 0 ?
		            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),

		    zoom = map._limitZoom(oldZoom + roundZoomDelta),
		    scale = map.getZoomScale(zoom) / this._scale;

		map._animateZoom(center, zoom, origin, scale);
	},

	_getScaleOrigin: function () {
		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
		return this._startCenter.add(centerOffset);
	}
});

L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

L.Map.mergeOptions({
	tap: true,
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		L.DomEvent
			.on(document, 'touchmove', this._onMove, this)
			.on(document, 'touchend', this._onUp, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent
			.off(document, 'touchmove', this._onMove, this)
			.off(document, 'touchend', this._onUp, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}


/*
 * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
  * (zoom to a selected bounding box), enabled by default.
 */

L.Map.mergeOptions({
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._moved = false;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
		this._moved = false;
	},

	moved: function () {
		return this._moved;
	},

	_onMouseDown: function (e) {
		this._moved = false;

		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startLayerPoint = this._map.mouseEventToLayerPoint(e);

		L.DomEvent
		    .on(document, 'mousemove', this._onMouseMove, this)
		    .on(document, 'mouseup', this._onMouseUp, this)
		    .on(document, 'keydown', this._onKeyDown, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
			L.DomUtil.setPosition(this._box, this._startLayerPoint);

			//TODO refactor: move cursor to styles
			this._container.style.cursor = 'crosshair';
			this._map.fire('boxzoomstart');
		}

		var startPoint = this._startLayerPoint,
		    box = this._box,

		    layerPoint = this._map.mouseEventToLayerPoint(e),
		    offset = layerPoint.subtract(startPoint),

		    newPos = new L.Point(
		        Math.min(layerPoint.x, startPoint.x),
		        Math.min(layerPoint.y, startPoint.y));

		L.DomUtil.setPosition(box, newPos);

		this._moved = true;

		// TODO refactor: remove hardcoded 4 pixels
		box.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
		box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
	},

	_finish: function () {
		if (this._moved) {
			this._pane.removeChild(this._box);
			this._container.style.cursor = '';
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent
		    .off(document, 'mousemove', this._onMouseMove)
		    .off(document, 'mouseup', this._onMouseUp)
		    .off(document, 'keydown', this._onKeyDown);
	},

	_onMouseUp: function (e) {

		this._finish();

		var map = this._map,
		    layerPoint = map.mouseEventToLayerPoint(e);

		if (this._startLayerPoint.equals(layerPoint)) { return; }

		var bounds = new L.LatLngBounds(
		        map.layerPointToLatLng(this._startLayerPoint),
		        map.layerPointToLatLng(layerPoint));

		map.fitBounds(bounds);

		map.fire('boxzoomend', {
			boxZoomBounds: bounds
		});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

L.Map.mergeOptions({
	keyboard: true,
	keyboardPanOffset: 80,
	keyboardZoomOffset: 1
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanOffset(map.options.keyboardPanOffset);
		this._setZoomOffset(map.options.keyboardZoomOffset);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex === -1) {
			container.tabIndex = '0';
		}

		L.DomEvent
		    .on(container, 'focus', this._onFocus, this)
		    .on(container, 'blur', this._onBlur, this)
		    .on(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .on('focus', this._addHooks, this)
		    .on('blur', this._removeHooks, this);
	},

	removeHooks: function () {
		this._removeHooks();

		var container = this._map._container;

		L.DomEvent
		    .off(container, 'focus', this._onFocus, this)
		    .off(container, 'blur', this._onBlur, this)
		    .off(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .off('focus', this._addHooks, this)
		    .off('blur', this._removeHooks, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanOffset: function (pan) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * pan, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [pan, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, pan];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * pan];
		}
	},

	_setZoomOffset: function (zoom) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoom;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoom;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		var key = e.keyCode,
		    map = this._map;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			map.panBy(this._panKeys[key]);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + this._zoomKeys[key]);

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;
		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon);
		}

		this._draggable
			.on('dragstart', this._onDragStart, this)
			.on('drag', this._onDrag, this)
			.on('dragend', this._onDragEnd, this);
		this._draggable.enable();
		L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable
			.off('dragstart', this._onDragStart, this)
			.off('drag', this._onDrag, this)
			.off('dragend', this._onDragEnd, this);

		this._draggable.disable();
		L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function () {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;

		marker
		    .fire('move', {latlng: latlng})
		    .fire('drag');
	},

	_onDragEnd: function (e) {
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});


/*
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	options: {
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	getPosition: function () {
		return this.options.position;
	},

	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	getContainer: function () {
		return this._container;
	},

	addTo: function (map) {
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	removeFrom: function (map) {
		var pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		corner.removeChild(this._container);
		this._map = null;

		if (this.onRemove) {
			this.onRemove(map);
		}

		return this;
	},

	_refocusOnMap: function () {
		if (this._map) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};


// adds control-related methods to L.Map

L.Map.include({
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	removeControl: function (control) {
		control.removeFrom(this);
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		this._container.removeChild(this._controlContainer);
	}
});


/*
 * L.Control.Zoom is used for the default zoom buttons on the map.
 */

L.Control.Zoom = L.Control.extend({
	options: {
		position: 'topleft',
		zoomInText: '+',
		zoomInTitle: 'Zoom in',
		zoomOutText: '-',
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');

		this._map = map;

		this._zoomInButton  = this._createButton(
		        this.options.zoomInText, this.options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn,  this);
		this._zoomOutButton = this._createButton(
		        this.options.zoomOutText, this.options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut, this);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	_zoomIn: function (e) {
		this._map.zoomIn(e.shiftKey ? 3 : 1);
	},

	_zoomOut: function (e) {
		this._map.zoomOut(e.shiftKey ? 3 : 1);
	},

	_createButton: function (html, title, className, container, fn, context) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		var stop = L.DomEvent.stopPropagation;

		L.DomEvent
		    .on(link, 'click', stop)
		    .on(link, 'mousedown', stop)
		    .on(link, 'dblclick', stop)
		    .on(link, 'click', L.DomEvent.preventDefault)
		    .on(link, 'click', fn, context)
		    .on(link, 'click', this._refocusOnMap, context);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * L.Control.Attribution is used for displaying attribution on the map (added by default).
 */

L.Control.Attribution = L.Control.extend({
	options: {
		position: 'bottomright',
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		L.DomEvent.disableClickPropagation(this._container);

		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}
		
		map
		    .on('layeradd', this._onLayerAdd, this)
		    .on('layerremove', this._onLayerRemove, this);

		this._update();

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerAdd)
		    .off('layerremove', this._onLayerRemove);

	},

	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	addAttribution: function (text) {
		if (!text) { return; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	removeAttribution: function (text) {
		if (!text) { return; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	},

	_onLayerAdd: function (e) {
		if (e.layer.getAttribution) {
			this.addAttribution(e.layer.getAttribution());
		}
	},

	_onLayerRemove: function (e) {
		if (e.layer.getAttribution) {
			this.removeAttribution(e.layer.getAttribution());
		}
	}
});

L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		this.attributionControl = (new L.Control.Attribution()).addTo(this);
	}
});

L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};


/*
 * L.Control.Scale is used for displaying metric/imperial scale on the map.
 */

L.Control.Scale = L.Control.extend({
	options: {
		position: 'bottomleft',
		maxWidth: 100,
		metric: true,
		imperial: true,
		updateWhenIdle: false
	},

	onAdd: function (map) {
		this._map = map;

		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className, container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className + '-line', container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className + '-line', container);
		}
	},

	_update: function () {
		var bounds = this._map.getBounds(),
		    centerLat = bounds.getCenter().lat,
		    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
		    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,

		    size = this._map.getSize(),
		    options = this.options,
		    maxMeters = 0;

		if (size.x > 0) {
			maxMeters = dist * (options.maxWidth / size.x);
		}

		this._updateScales(options, maxMeters);
	},

	_updateScales: function (options, maxMeters) {
		if (options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}

		if (options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters);

		this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
		this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    scale = this._iScale,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);

			scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
			scale.innerHTML = miles + ' mi';

		} else {
			feet = this._getRoundNum(maxFeet);

			scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
			scale.innerHTML = feet + ' ft';
		}
	},

	_getScaleWidth: function (ratio) {
		return Math.round(this.options.maxWidth * ratio) - 10;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

L.control.scale = function (options) {
	return new L.Control.Scale(options);
};


/*
 * L.Control.Layers is a control to allow users to switch between different layers on the map.
 */

L.Control.Layers = L.Control.extend({
	options: {
		collapsed: true,
		position: 'topright',
		autoZIndex: true
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = {};
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		map
		    .on('layeradd', this._onLayerChange, this)
		    .on('layerremove', this._onLayerChange, this);

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerChange)
		    .off('layerremove', this._onLayerChange);
	},

	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		this._update();
		return this;
	},

	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		this._update();
		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);
		delete this._layers[id];
		this._update();
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		if (!L.Browser.touch) {
			L.DomEvent
				.disableClickPropagation(container)
				.disableScrollPropagation(container);
		} else {
			L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent
				    .on(container, 'mouseover', this._expand, this)
				    .on(container, 'mouseout', this._collapse, this);
			}
			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this._expand, this);
			}
			else {
				L.DomEvent.on(link, 'focus', this._expand, this);
			}
			//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this._collapse, this);
			// TODO keyboard accessibility
		} else {
			this._expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_addLayer: function (layer, name, overlay) {
		var id = L.stamp(layer);

		this._layers[id] = {
			layer: layer,
			name: name,
			overlay: overlay
		};

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) {
			return;
		}

		this._baseLayersList.innerHTML = '';
		this._overlaysList.innerHTML = '';

		var baseLayersPresent = false,
		    overlaysPresent = false,
		    i, obj;

		for (i in this._layers) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
	},

	_onLayerChange: function (e) {
		var obj = this._layers[L.stamp(e.layer)];

		if (!obj) { return; }

		if (!this._handlingClick) {
			this._update();
		}

		var type = obj.overlay ?
			(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'layeradd' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
		if (checked) {
			radioHtml += ' checked="checked"';
		}
		radioHtml += '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    input,
		    checked = this._map.hasLayer(obj.layer);

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		label.appendChild(input);
		label.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		return label;
	},

	_onInputClick: function () {
		var i, input, obj,
		    inputs = this._form.getElementsByTagName('input'),
		    inputsLen = inputs.length;

		this._handlingClick = true;

		for (i = 0; i < inputsLen; i++) {
			input = inputs[i];
			obj = this._layers[input.layerId];

			if (input.checked && !this._map.hasLayer(obj.layer)) {
				this._map.addLayer(obj.layer);

			} else if (!input.checked && this._map.hasLayer(obj.layer)) {
				this._map.removeLayer(obj.layer);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
	},

	_collapse: function () {
		this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
	}
});

L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};


/*
 * L.PosAnimation is used by Leaflet internally for pan animations.
 */

L.PosAnimation = L.Class.extend({
	includes: L.Mixin.Events,

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._newPos = newPos;

		this.fire('start');

		el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
		        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

		L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
		L.DomUtil.setPosition(el, newPos);

		// toggle reflow, Chrome flickers for some reason if you don't do this
		L.Util.falseFn(el.offsetWidth);

		// there's no native way to track value updates of transitioned properties, so we imitate this
		this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
	},

	stop: function () {
		if (!this._inProgress) { return; }

		// if we just removed the transition property, the element would jump to its final position,
		// so we need to make it stay at the current position

		L.DomUtil.setPosition(this._el, this._getPos());
		this._onTransitionEnd();
		L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
	},

	_onStep: function () {
		var stepPos = this._getPos();
		if (!stepPos) {
			this._onTransitionEnd();
			return;
		}
		// jshint camelcase: false
		// make L.DomUtil.getPosition return intermediate position value during animation
		this._el._leaflet_pos = stepPos;

		this.fire('step');
	},

	// you can't easily get intermediate values of properties animated with CSS3 Transitions,
	// we need to parse computed style (in case of transform it returns matrix string)

	_transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,

	_getPos: function () {
		var left, top, matches,
		    el = this._el,
		    style = window.getComputedStyle(el);

		if (L.Browser.any3d) {
			matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
			if (!matches) { return; }
			left = parseFloat(matches[1]);
			top  = parseFloat(matches[2]);
		} else {
			left = parseFloat(style.left);
			top  = parseFloat(style.top);
		}

		return new L.Point(left, top, true);
	},

	_onTransitionEnd: function () {
		L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

		if (!this._inProgress) { return; }
		this._inProgress = false;

		this._el.style[L.DomUtil.TRANSITION] = '';

		// jshint camelcase: false
		// make sure L.DomUtil.getPosition returns the final position value after animation
		this._el._leaflet_pos = this._newPos;

		clearInterval(this._stepTimer);

		this.fire('step').fire('end');
	}

});


/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		if (this._panAnim) {
			this._panAnim.stop();
		}

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate}, options.pan);
			}

			// try animating pan or zoom
			var animated = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (animated) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset);
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});


/*
 * L.PosAnimation fallback implementation that powers Leaflet pan animations
 * in browsers that don't support CSS3 Transitions.
 */

L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		this.fire('start');

		this._animate();
	},

	stop: function () {
		if (!this._inProgress) { return; }

		this._step();
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function () {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration));
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		L.DomUtil.setPosition(this._el, pos);

		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});


/*
 * Extends L.Map to handle zoom animations.
 */

L.Map.mergeOptions({
	zoomAnimation: true,
	zoomAnimationThreshold: 4
});

if (L.DomUtil.TRANSITION) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&
				L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!L.DomUtil.TRANSITION ? {} : {

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
			origin = this._getCenterLayerPoint()._add(offset);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		this
		    .fire('movestart')
		    .fire('zoomstart');

		this._animateZoom(center, zoom, origin, scale, null, true);

		return true;
	},

	_animateZoom: function (center, zoom, origin, scale, delta, backwards) {

		this._animatingZoom = true;

		// put transform transition on all layers with leaflet-zoom-animated class
		L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');

		// remember what center/zoom to set after animation
		this._animateToCenter = center;
		this._animateToZoom = zoom;

		// disable any dragging during animation
		if (L.Draggable) {
			L.Draggable._disabled = true;
		}

		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			origin: origin,
			scale: scale,
			delta: delta,
			backwards: backwards
		});
	},

	_onZoomTransitionEnd: function () {

		this._animatingZoom = false;

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._resetView(this._animateToCenter, this._animateToZoom, true, true);

		if (L.Draggable) {
			L.Draggable._disabled = false;
		}
	}
});


/*
	Zoom animation logic for L.TileLayer.
*/

L.TileLayer.include({
	_animateZoom: function (e) {
		if (!this._animating) {
			this._animating = true;
			this._prepareBgBuffer();
		}

		var bg = this._bgBuffer,
		    transform = L.DomUtil.TRANSFORM,
		    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
		    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);

		bg.style[transform] = e.backwards ?
				scaleStr + ' ' + initialTransform :
				initialTransform + ' ' + scaleStr;
	},

	_endZoomAnim: function () {
		var front = this._tileContainer,
		    bg = this._bgBuffer;

		front.style.visibility = '';
		front.parentNode.appendChild(front); // Bring to fore

		// force reflow
		L.Util.falseFn(bg.offsetWidth);

		this._animating = false;
	},

	_clearBgBuffer: function () {
		var map = this._map;

		if (map && !map._animatingZoom && !map.touchZoom._zooming) {
			this._bgBuffer.innerHTML = '';
			this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
		}
	},

	_prepareBgBuffer: function () {

		var front = this._tileContainer,
		    bg = this._bgBuffer;

		// if foreground layer doesn't have many tiles but bg layer does,
		// keep the existing bg layer and just zoom it some more

		var bgLoaded = this._getLoadedTilesPercentage(bg),
		    frontLoaded = this._getLoadedTilesPercentage(front);

		if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

			front.style.visibility = 'hidden';
			this._stopLoadingImages(front);
			return;
		}

		// prepare the buffer to become the front tile pane
		bg.style.visibility = 'hidden';
		bg.style[L.DomUtil.TRANSFORM] = '';

		// switch out the current layer to be the new bg layer (and vice-versa)
		this._tileContainer = bg;
		bg = this._bgBuffer = front;

		this._stopLoadingImages(bg);

		//prevent bg buffer from clearing right after zoom
		clearTimeout(this._clearBgBufferTimer);
	},

	_getLoadedTilesPercentage: function (container) {
		var tiles = container.getElementsByTagName('img'),
		    i, len, count = 0;

		for (i = 0, len = tiles.length; i < len; i++) {
			if (tiles[i].complete) {
				count++;
			}
		}
		return count / len;
	},

	// stops loading all tiles in the background layer
	_stopLoadingImages: function (container) {
		var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
		    i, len, tile;

		for (i = 0, len = tiles.length; i < len; i++) {
			tile = tiles[i];

			if (!tile.complete) {
				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;
				tile.src = L.Util.emptyImageUrl;

				tile.parentNode.removeChild(tile);
			}
		}
	}
});


/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

L.Map.include({
	_defaultLocateOptions: {
		watch: false,
		setView: false,
		maxZoom: Infinity,
		timeout: 10000,
		maximumAge: 0,
		enableHighAccuracy: false
	},

	locate: function (/*Object*/ options) {

		options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

		if (!navigator.geolocation) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
			onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	stopLocate: function () {
		if (navigator.geolocation) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),

		    latAccuracy = 180 * pos.coords.accuracy / 40075017,
		    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),

		    bounds = L.latLngBounds(
		            [lat - latAccuracy, lng - lngAccuracy],
		            [lat + latAccuracy, lng + lngAccuracy]),

		    options = this._locateOptions;

		if (options.setView) {
			var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
			this.setView(latlng, zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		this.fire('locationfound', data);
	}
});


}(window, document));
/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/geo/geopicker',[ 'jquery', 'enketo-js/Widget', 'text!enketo-config', 'leaflet' ],
    function( $, Widget, configStr, L ) {
        

        var pluginName = 'geopicker',
            config = JSON.parse( configStr ),
            //defaultView = [ 39.7334, -104.9926 ],
            defaultZoom = 15,
            tile = ( config && config.tile && config.tile.source ) ? config.tile : {
                "source": "http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                "attribution": 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
            },
            searchSource = "https://maps.googleapis.com/maps/api/geocode/json?address={address}&sensor=true&key={api_key}",
            iconSingle = L.divIcon( {
                iconSize: 24,
                className: 'enketo-geopoint-marker'
            } ),
            iconMulti = L.divIcon( {
                iconSize: 16,
                className: 'enketo-geopoint-circle-marker'
            } ),
            iconMultiActive = L.divIcon( {
                iconSize: 16,
                className: 'enketo-geopoint-circle-marker-active'
            } );

        /**
         * Geotrace widget Class
         * @constructor
         * @param {Element} element [description]
         * @param {(boolean|{touch: boolean, repeat: boolean})} options options
         * @param {*=} e     event
         */

        function Geopicker( element, options ) {
            var that = this;
            this.namespace = pluginName;
            // call the super class constructor
            Widget.call( this, element, options );

            this._init();
        }

        // copy the prototype functions from the Widget super class
        Geopicker.prototype = Object.create( Widget.prototype );

        // ensure the constructor is the new one
        Geopicker.prototype.constructor = Geopicker;

        /**
         * Initializes the picker
         */
        Geopicker.prototype._init = function() {
            var loadedVal = $( this.element ).val().trim(),
                that = this,
                defaultLatLng = [ 16.8164, -3.0171 ];

            this.mapId = Math.round( Math.random() * 10000000 );
            this.props = this._getProps();

            this._addDomElements();
            this.currentIndex = 0;
            this.points = [];
            // load default value
            if ( loadedVal ) {
                $( this.element ).val().trim().split( ';' ).forEach( function( el, i ) {
                    console.log( 'adding loaded point', el.trim().split( ' ' ) );
                    that.points[ i ] = el.trim().split( ' ' );
                    that.points[ i ].forEach( function( str, i, arr ) {
                        arr[ i ] = Number( str );
                    } );
                } );
            }

            this.$widget.find( 'input:not([name="search"])' ).on( 'change change.bymap change.bysearch', function( event ) {
                var lat = that.$lat.val() ? Number( that.$lat.val() ) : "",
                    lng = that.$lng.val() ? Number( that.$lng.val() ) : "",
                    // we need to avoid a missing alt in case acc is not empty!
                    alt = that.$alt.val() ? Number( that.$alt.val() ) : "",
                    acc = that.$acc.val() ? Number( that.$acc.val() ) : "";

                event.stopImmediatePropagation();

                that._editPoint( [ lat, lng, alt, acc ] );

                if ( event.namespace !== 'bysearch' && that.$search ) {
                    that.$search.val( '' );
                }
            } );

            this.$points.on( 'click', '.point', function() {
                that._setCurrent( that.$points.find( '.point' ).index( $( this ) ) );
                return false;
            } );

            this.$points.find( '.addpoint' ).on( 'click', function() {
                that._addPoint();
                return false;
            } );

            this.$widget.find( '.close-chain-btn' ).on( 'click', function() {
                that._closePolygon();
                return false;
            } );

            this.$widget.find( '.btn-remove' ).on( 'click', function() {
                if ( that.points.length < 2 ) {
                    that._updateInputs( [] );
                } else if ( window.confirm( 'This will completely remove the current geopoint from the list of geopoints and cannot be undone. Are you sure you want to do this?' ) ) {
                    that._removePoint();
                }
            } );

            this.$map.find( '.show-map-btn' ).on( 'click', function() {
                that.$widget.find( '.search-bar' ).removeClass( 'hide-search' );
                that.$widget.addClass( 'full-screen' );
                that._updateMap();
                return false;
            } );

            this.$widget.find( '.hide-map-btn' ).on( 'click', function() {
                that.$widget.find( '.search-bar' ).addClass( 'hide-search' );
                that.$widget.removeClass( 'full-screen' ).find( '.map-canvas' ).removeClass( 'leaflet-container' );
                if ( that.map ) {
                    that.map.remove();
                    that.map = null;
                    that.polygon = null;
                    that.polyline = null;
                }
                return false;
            } );

            this.$widget.on( 'focus blur', 'input', function( event ) {
                $( that.element ).trigger( event.type );
            } );

            // enable search
            if ( this.props.search ) {
                this._enableSearch();
            }

            // enable detection
            if ( this.props.detect ) {
                this._enableDetection();
            }

            // creating "point buttons"
            if ( loadedVal ) {
                this.points.forEach( function( el, i ) {
                    that._addPointBtn( i + 1 );
                } );
            } else {
                this._addPoint();
            }

            // setting map location on load
            if ( !loadedVal ) {
                // set worldview in case permissions take too long (e.g. in FF);
                this._updateMap( [ 0, 0 ], 1 );
                if ( this.props.detect ) {
                    navigator.geolocation.getCurrentPosition( function( position ) {
                        console.log( 'tracepicker found it', position );
                        that._updateMap( [ position.coords.latitude, position.coords.longitude ], defaultZoom );
                    } );
                }
            } else {
                this._updateMap();
                this._setCurrent( this.currentIndex );
            }
        };

        /**
         * Gets the widget properties and features.
         *
         * @return {{search: boolean, detect: boolean, map: boolean, updateMapFn: string, type: string}} The widget properties object
         */
        Geopicker.prototype._getProps = function() {
            var map = this.options.touch !== true || ( this.options.touch === true && $( this.element ).closest( '.or-appearance-maps' ).length > 0 );
            return {
                detect: !!navigator.geolocation,
                map: map,
                search: map,
                //updateMapFn: map ? ( this.options.touch ? "_updateStaticMap" : "_updateDynamicMap" ) : null,
                type: this.element.attributes[ 'data-type-xml' ].textContent,
                touch: this.options.touch
            };
        };

        /**
         * Adds a point button in the point navigation bar
         * @param {string} label The label to show on the button.
         */
        Geopicker.prototype._addPointBtn = function( label ) {
            this.$points.find( '.addpoint' ).before( '<a href="#" class="point"> </a>' );
        };

        /**
         * Adds the DOM elements
         */
        Geopicker.prototype._addDomElements = function() {
            var map = '<div class="map-canvas-wrapper"><div class=map-canvas id="map' + this.mapId + '"></div></div>',
                points = '<div class="points"><button class="addpoint">+</button></div>',
                close = '<button class="close-chain-btn btn btn-default btn-xs">close polygon</button>',
                mapBtn = '<a href="#" class="show-map-btn btn btn-default">Map</a>';

            this.$widget = $(
                '<div class="geopicker widget">' +
                '<div class="search-bar hide-search no-map no-detect">' +
                '<a href="#" class="hide-map-btn btn btn-default"><span class="glyphicon glyphicon-arrow-left"> </span></a>' +
                '<button name="geodetect" type="button" class="btn btn-default" title="detect current location" data-placement="top">' +
                '<span class="glyphicon glyphicon-screenshot"> </span></button>' +
                '<div class="input-group">' +
                '<input class="geo ignore" name="search" type="text" placeholder="search for place or address" disabled="disabled"/>' +
                '<span class="input-group-btn"><button class="btn btn-default"><i class="glyphicon glyphicon-search"> </i></button></span>' +
                '</div>' +
                '</div>' +
                '<div class="geo-inputs">' +
                '<label class="geo">latitude (x.y &deg;)<input class="ignore" name="lat" type="number" step="0.0001" min="-90" max="90"/></label>' +
                '<label class="geo">longitude (x.y &deg;)<input class="ignore" name="long" type="number" step="0.0001" min="-180" max="180"/></label>' +
                '<label class="geo">altitude (m)<input class="ignore" name="alt" type="number" step="0.1" /></label>' +
                '<label class="geo">accuracy (m)<input class="ignore" name="acc" type="number" step="0.1" /></label>' +
                '<button class="btn-remove"><span class="glyphicon glyphicon-trash"> </span></button>' +
                '</div>' +
                '</div>'
            );

            // add the detection button
            if ( this.props.detect ) {
                this.$widget.find( '.search-bar' ).removeClass( 'no-detect' );
                this.$detect = this.$widget.find( 'button[name="geodetect"]' );
            }

            this.$search = this.$widget.find( '[name="search"]' );

            // add the map canvas
            if ( this.props.map ) {
                this.$widget.find( '.search-bar' ).removeClass( 'no-map' ).after( map );
                this.$map = this.$widget.find( '.map-canvas' );
            } else {
                this.$map = $();
            }

            // touchscreen maps
            if ( this.props.touch && this.props.map ) {
                this.$map.append( mapBtn );
            }

            if ( !this.props.touch ) {
                this.$widget.find( '.search-bar' ).removeClass( 'hide-search' );
            }

            // if points bar is required
            if ( this.props.type !== 'geopoint' ) {
                this.$points = $( points );
                if ( this.props.type === 'geoshape' ) {
                    this.$widget.find( '.geo-inputs' ).append( close );
                }
                this.$widget.prepend( this.$points );
            } else {
                this.$points = $();
            }

            this.$lat = this.$widget.find( '[name="lat"]' );
            this.$lng = this.$widget.find( '[name="long"]' );
            this.$alt = this.$widget.find( '[name="alt"]' );
            this.$acc = this.$widget.find( '[name="acc"]' );


            $( this.element ).hide().after( this.$widget ).parent().addClass( 'clearfix' );
        };

        /**
         * Updates the value in the original input element.
         *
         * @return {Boolean} Whether the value was changed.
         */
        Geopicker.prototype._updateValue = function() {
            var oldGeoTraceValue = $( this.element ).val(),
                newGeoTraceValue = '',
                that = this;

            this._markAsValid();

            // all points should be valid geopoints and only the last item may be empty
            this.points.forEach( function( point, index, array ) {
                var geopoint,
                    lat = typeof point[ 0 ] === 'number' ? point[ 0 ] : ( typeof point.lat === 'number' ? point.lat : null ),
                    lng = typeof point[ 1 ] === 'number' ? point[ 1 ] : ( typeof point.lng === 'number' ? point.lng : null ),
                    alt = typeof point[ 2 ] === 'number' ? point[ 2 ] : 0.0,
                    acc = typeof point[ 3 ] === 'number' ? point[ 3 ] : 0.0;

                geopoint = ( lat && lng ) ? lat + ' ' + lng + ' ' + alt + ' ' + acc : "";

                //only last item may be empty
                if ( !that._isValidGeopoint( geopoint ) && !( geopoint === '' && index === array.length - 1 ) ) {
                    that._markAsInvalid( index );
                }
                //newGeoTraceValue += geopoint;
                if ( !( geopoint === '' && index === array.length - 1 ) ) {
                    newGeoTraceValue += geopoint;
                    if ( index !== array.length - 1 ) {
                        newGeoTraceValue += ';';
                    }
                } else {
                    // remove trailing semi-colon
                    newGeoTraceValue = newGeoTraceValue.substring( 0, newGeoTraceValue.lastIndexOf( ';' ) );
                }
            } );

            console.log( 'updating value by joining', this.points, 'old value', oldGeoTraceValue, 'new value', newGeoTraceValue );

            if ( oldGeoTraceValue !== newGeoTraceValue ) {
                $( this.element ).val( newGeoTraceValue ).trigger( 'change' );
                return true;
            } else {
                return false;
            }
        };

        /**
         * Checks an Openrosa geopoint for validity. This function is used to provide more detailed
         * error feedback than provided by the form controller. This can be used to pinpoint the exact
         * invalid geopoints in a list of geopoint (the form controller only validates the total list).
         *
         * @param  {string}  geopoint [description]
         * @return {Boolean}          [description]
         */
        Geopicker.prototype._isValidGeopoint = function( geopoint ) {
            var coords;

            if ( !geopoint ) {
                return false;
            }

            coords = geopoint.toString().split( ' ' );
            return (
                ( coords[ 0 ] !== '' && coords[ 0 ] >= -90 && coords[ 0 ] <= 90 ) &&
                ( coords[ 1 ] !== '' && coords[ 1 ] >= -180 && coords[ 1 ] <= 180 ) &&
                ( typeof coords[ 2 ] == 'undefined' || !isNaN( coords[ 2 ] ) ) &&
                ( typeof coords[ 3 ] == 'undefined' || ( !isNaN( coords[ 3 ] ) && coords[ 3 ] >= 0 ) )
            );
        };

        /**
         * Validates a list of latLng Arrays or Objects
         * @param  {Array.((Array.<number|string>|{lat: number, long:number}))}  latLngs Array of latLng objects or arrays
         * @return {Boolean}         Whether list is valid or not
         */
        Geopicker.prototype._isValidLatLngList = function( latLngs ) {
            var that = this;

            return latLngs.every( function( latLng, index, array ) {
                return that._isValidLatLng( latLng ) || ( latLng.join() === '' && index === array.length - 1 );
            } );
        };

        /**
         * Validates an individual latlng Array or Object
         * @param  {(Array.<number|string>|{lat: number, long:number})}  latLng latLng object or array
         * @return {Boolean}        Whether latLng is valid or not
         */
        Geopicker.prototype._isValidLatLng = function( latLng ) {
            console.log( 'checking validity of latLng', latLng );
            var lat, lng;

            lat = ( typeof latLng[ 0 ] === 'number' ) ? latLng[ 0 ] : ( typeof latLng.lat === 'number' ) ? latLng.lat : null;
            lng = ( typeof latLng[ 1 ] === 'number' ) ? latLng[ 1 ] : ( typeof latLng.lng === 'number' ) ? latLng.lng : null;

            return ( lat !== null && lng !== null && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180 );
        };

        /**
         * Marks a point as invalid in the points navigation bar
         * @param  {number} index Index of point
         */
        Geopicker.prototype._markAsInvalid = function( index ) {
            this.$points.find( '.point' ).eq( index ).addClass( 'has-error' );
        };

        /**
         * Marks all points as valid in the points navigation bar
         */
        Geopicker.prototype._markAsValid = function() {
            this.$points.find( '.point' ).removeClass( 'has-error' );
        };

        /**
         * Changes the current point in the list of points
         */
        Geopicker.prototype._setCurrent = function( index ) {
            this.currentIndex = index;
            this.$points.find( '.point' ).removeClass( 'active' ).eq( index ).addClass( 'active' );
            this._updateInputs( this.points[ index ], '' );
            // make sure that the current marker is marked as active
            if ( !this.props.touch || this._inFullScreenMode() ) {
                this._updateMarkers();
            }
            console.log( 'set current index to ', this.currentIndex );
        };

        /**
         * Enables geo detection using the built-in browser geoLocation functionality
         */
        Geopicker.prototype._enableDetection = function() {
            var that = this,
                options = {
                    enableHighAccuracy: true
                };
            this.$detect.click( function( event ) {
                event.preventDefault();
                navigator.geolocation.getCurrentPosition( function( position ) {
                    //that.points[that.currentIndex] = [ position.coords.latitude, position.coords.longitude ];
                    //that._updateMap( );
                    that._updateInputs( [ position.coords.latitude, position.coords.longitude, position.coords.altitude, position.coords.accuracy ] );
                    // if current index is last of points, automatically create next point
                    if ( that.currentIndex === that.points.length - 1 && that.props.type !== 'geopoint' ) {
                        that._addPoint();
                    }
                }, function() {
                    console.error( 'error occurred trying to obtain position' );
                }, options );
                return false;
            } );
        };

        /**
         * Enables search functionality using the Google Maps API v3
         */
        Geopicker.prototype._enableSearch = function() {
            var that = this;

            if ( config[ 'google_api_key' ] ) {
                searchSource = searchSource.replace( '{api_key}', config[ 'google_api_key' ] );
            } else {
                searchSource = searchSource.replace( '&key={api_key}', '' );
            }

            this.$search
                .prop( 'disabled', false )
                .on( 'change', function( event ) {
                    var address = $( this ).val();
                    event.stopImmediatePropagation();

                    if ( address ) {
                        address = address.split( /\s+/ ).join( '+' );
                        $.get( searchSource.replace( '{address}', address ), function( response ) {
                            var location;
                            if ( response.results && response.results.length > 0 && response.results[ 0 ].geometry && response.results[ 0 ].geometry.location ) {
                                location = response.results[ 0 ].geometry.location;
                                that._updateMap( [ location.lat, location.lng ], defaultZoom );
                                that.$search.closest( '.input-group' ).removeClass( 'has-error' );
                            } else {
                                //TODO: add error message
                                that.$search.closest( '.input-group' ).addClass( 'has-error' );
                                console.log( "Location '" + address + "' not found" );
                            }
                        }, 'json' )
                            .fail( function() {
                                //TODO: add error message
                                that.$search.closest( '.input-group' ).addClass( 'has-error' );
                                console.log( "Error. Geocoding service may not be available or app is offline" );
                            } )
                            .always( function() {

                            } );
                        /*$.get( "http://nominatim.openstreetmap.org/search/" + address + "?format=json", function( response ) {
                            var location = response[ 0 ] || null;
                            if ( location && location.lat && location.lon ) {
                                that._updateMap( [ location.lat, location.lon ], defaultZoom );
                                that.$search.closest( '.input-group' ).removeClass( 'has-error' );
                            } else {
                                //TODO: add error message
                                that.$search.closest( '.input-group' ).addClass( 'has-error' );
                                console.log( "Location '" + address + "' not found" );
                            }
                        }, 'json' )
                            .fail( function() {
                                //TODO: add error message
                                that.$search.closest( '.input-group' ).addClass( 'has-error' );
                                console.log( "Error. Geocoding service may not be available or app is offline" );
                            } )
                            .always( function() {

                            } );
                        */
                    } else {

                    }
                } );
        };

        /**
         * Determines whether map is available for manipulation.
         */
        Geopicker.prototype._dynamicMapAvailable = function() {
            return !!this.map;
        };

        Geopicker.prototype._inFullScreenMode = function() {
            return this.$widget.hasClass( 'full-screen' );
        };

        /**
         * Calls the appropriate map update function.
         *
         * @param  @param  {Array.<number>|{lat: number, lng: number}} latLng  latitude and longitude coordinates
         * @param  {number=} zoom zoom level
         * @return {Function} Returns call to function
         */
        Geopicker.prototype._updateMap = function( latLng, zoom ) {
            console.log( 'trace update map', 'latLng', latLng, 'zoom', zoom, 'points', this.points );
            if ( !this.props.map ) {
                return;
            }

            if ( !zoom ) {
                if ( this.map ) {
                    // note: there are conditions where getZoom returns undefined!
                    zoom = this.map.getZoom() || defaultZoom;
                } else {
                    zoom = defaultZoom;
                }
            }

            // serves to remember last requested map coordinates to initiate map in mobile view
            if ( latLng ) {
                this.lastLatLng = latLng;
                this.lastZoom = zoom;
            }
            console.log( 'stored lastLatLng', this.lastLatLng, this.lastZoom );

            if ( !this.props.touch || this._inFullScreenMode() ) {
                this._updateDynamicMap( latLng, zoom );
            }
        };



        /**
         * Loads a static map. (No markers due to difficult of determining zoom level that would show all of them)
         *
         * @param  @param  {Array.<number>|{lat: number, lng: number}} latLng  latitude and longitude coordinates
         * @param  {number} zoom zoom level
         */
        /*Geopicker.prototype._updateStaticMap = function( latLng, zoom ) {
            var lat, lng, width, height,
                markers = '';

            if ( !this.props.map ) {
                return;
            }

            latLng = latLng || this.points[ 0 ] || defaultLatLng;

            lat = latLng[ 0 ] || latLng.lat || 0;
            lng = latLng[ 1 ] || latLng.lng || 0;
            width = Math.round( this.$map.width() );
            height = Math.round( this.$map.height() );

            this.$map.addClass( 'static' ).empty().append(
                '<img src="' + tile[ "static" ][ "source" ].replace( '{markers}/', '' ).replace( '{lat}', lat ).replace( '{lon}', lng ).replace( '{z}', defaultZoom ).replace( '{width}', width ).replace( '{height}', height ) + '"/>' +
                '<div class="attribution">' + tile[ "static" ][ "attribution" ] + '</div>'
            );
        };*/

        /**
         * Updates the dynamic map to either show the provided coordinates (in the center), with the provided zoom level
         * or updates any markers, polylines, polygons
         *
         * @param  {Array.<number>|{lat: number, lng: number}} latLng  latitude and longitude coordinates
         * @param  {number} zoom zoom
         */
        Geopicker.prototype._updateDynamicMap = function( latLng, zoom ) {
            var z, that = this;

            console.log( 'dynamic map to be updated with latLng', latLng );
            if ( !this.map ) {
                console.log( 'no map yet, creating it' );
                this.map = L.map( 'map' + this.mapId )
                    .on( 'click', function( e ) {
                        console.log( 'clicked on map', e.latlng );
                        // do nothing if the field has a current marker
                        // instead the user will have to drag to change it by map
                        if ( !that.$lat.val() || !that.$lng.val() || that.props.type === 'geopoint' ) {
                            that._updateInputs( e.latlng, 'change.bymap' );
                        } else if ( that.$lat.val() && that.$lng.val() && that.props.type !== 'geopoint' ) {
                            that._addPoint();
                            that._updateInputs( e.latlng, 'change.bymap' );
                        }
                    } );

                L.tileLayer( tile[ "source" ], {
                    attribution: tile[ "attribution" ],
                    maxZoom: 18
                } ).addTo( this.map );

                // watch out, default "Leaflet" link clicks away from page, loosing all data
                this.map.attributionControl.setPrefix( '' );
            }

            if ( !latLng ) {
                this._updatePolyline();
                this._updateMarkers();
                if ( this.points.length === 1 && this.points[ 0 ].toString() === '' ) {
                    if ( this.lastLatLng ) {
                        z = this.lastZoom || defaultZoom;
                        console.log( 'loading last', this.lastLatLng, this.lastZoom );
                        this.map.setView( this.lastLatLng, z );
                    } else {
                        this.map.setView( 0, 0, 18 );
                    }

                }
            } else {
                console.log( 'setting map view with center', latLng );
                this.map.setView( latLng, zoom );
            }
        };

        /**
         * Updates the markers on the dynamic map from the current list of points.
         */
        Geopicker.prototype._updateMarkers = function() {
            var coords = [],
                markers = [],
                that = this;

            console.log( 'updateing markers', this.points );

            if ( this.markerLayer ) {
                this.markerLayer.clearLayers();
            }

            if ( this.points.length < 2 && this.points[ 0 ].join() === '' ) {
                return;
            }

            this.points.forEach( function( latLng, index ) {
                var icon = that.props.type === 'geopoint' ? iconSingle : ( index === that.currentIndex ? iconMultiActive : iconMulti );
                if ( that._isValidLatLng( latLng ) ) {
                    coords.push( latLng );
                    markers.push( L.marker( latLng, {
                            icon: icon,
                            clickable: true,
                            draggable: true,
                            alt: index,
                            opacity: 0.9
                        } ).on( 'click', function( e ) {
                            console.log( 'clicked marker', e );
                            if ( e.target.options.alt === 0 && that.props.type === 'geoshape' ) {
                                that._closePolygon();
                            } else {
                                that._setCurrent( e.target.options.alt );
                            }
                        } ).on( 'dragend', function( e ) {
                            var latLng = e.target.getLatLng();
                            // first set the current index the point dragged
                            that._setCurrent( e.target.options.alt );
                            that._updateInputs( latLng, 'change.bymap' );
                            that._updateMap();
                        } )
                        /*.on( 'mouseover', function( e ) {
                        console.log( 'mousover!', e );
                        if ( e.target.options.alt === 0 && that.props.type === 'geoshape' ) {
                            var popup = L.popup()
                                .setLatLng( e.latlng )
                                .setContent( 'click point to close the shape' )
                                .openOn( that.map );
                        }
                    } )*/
                    );
                } else {
                    console.log( 'this latLng was not considered valid', latLng );
                }
            } );

            console.log( 'markers to update', markers );

            if ( markers.length > 0 ) {
                this.markerLayer = L.layerGroup( markers ).addTo( this.map );
                // change the view to fit all the markers
                // don't use this for multiple markers, it messed up map clicks to place points
                if ( this.points.length === 1 || !this._isValidLatLngList( this.points ) ) {
                    this.map.fitBounds( coords );
                }
            }

            console.log( 'redrawn all markers' );
        };

        /**
         * Updates the polyline on the dynamic map from the current list of points
         */
        Geopicker.prototype._updatePolyline = function() {
            var polylinePoints;

            if ( this.props.type === 'geopoint' ) {
                return;
            }

            console.log( 'updating polyline' );
            if ( this.points.length < 2 || !this._isValidLatLngList( this.points ) ) {
                // remove quirky line remainder
                if ( this.map ) {
                    if ( this.polyline ) {
                        this.map.removeLayer( this.polyline );
                    }
                    if ( this.polygon ) {
                        this.map.removeLayer( this.polygon );
                    }
                }
                this.polyline = null;
                this.polygon = null;
                console.log( 'list of points invalid' );
                return;
            }

            // polyline and polygon are mutually exclusive
            if ( this.props.type === 'geoshape' ) {
                /*console.log( 'detected that this polyline is a polygon' );
                if ( this.polyline ) {
                    if ( this.map ) {
                        this.map.removeLayer( this.polyline );
                    }
                    this.polyline = null;
                }*/

                this._updatePolygon();
                //return;
            }
            /*else if ( this.polygon ) {
                if ( this.map ) {
                    this.map.removeLayer( this.polygon );
                }
                this.polygon = null;
            }*/

            polylinePoints = ( this.points[ this.points.length - 1 ].join( '' ) !== '' ) ? this.points : this.points.slice( 0, this.points.length - 1 );

            if ( !this.polyline ) {
                this.polyline = L.polyline( polylinePoints, {
                    color: 'red'
                } );
                this.map.addLayer( this.polyline );
            } else {
                this.polyline.setLatLngs( polylinePoints );
            }
            this.map.fitBounds( this.polyline.getBounds() );
            console.log( 'done updating polyline' );
        };


        /**
         * Updates the polygon on the dynamic map from the current list of points.
         * A polygon is a type of polyline. This function is ALWAYS called by _updatePolyline.
         */
        Geopicker.prototype._updatePolygon = function() {
            var polygonPoints;

            if ( this.props.type === 'geopoint' || this.props.type === 'geotrace' ) {
                return;
            }

            console.log( 'updating polygon' );

            polygonPoints = ( this.points[ this.points.length - 1 ].join( '' ) !== '' ) ? this.points : this.points.slice( 0, this.points.length - 1 );

            if ( !this.polygon ) {
                console.log( 'creating new polygon' );
                this.polygon = L.polygon( polygonPoints, {
                    color: 'red',
                    stroke: false
                } );
                this.map.addLayer( this.polygon );
            } else {
                console.log( 'updating existing polygon', this.points );
                this.polygon.setLatLngs( polygonPoints );
            }
            //this.map.fitBounds( this.polygon.getBounds() );
            console.log( 'done updating polygon' );
        };

        /*Geopicker.prototype._isPolygon = function( latLngs ) {
            // no need to check for validaty of latLngs. This already happened in _updatePolyline.
            return this.props.type === 'geoshape' && latLngs.length >= 4 && JSON.stringify( latLngs[ 0 ] ) === JSON.stringify( latLngs[ latLngs.length - 1 ] );
        };*/


        Geopicker.prototype._addPoint = function() {
            this._addPointBtn( this.points.length + 1 );
            this.points.push( [] );
            this._setCurrent( this.points.length - 1 );
            this._updateValue();
        };

        /**
         * Edits a point in the list of points
         * @param  {Array.<number>|{lat: number, lng: number, alt: number, acc: number}} latLng LatLng object or array
         * @return {Boolean]}        Whether point changed.
         */
        Geopicker.prototype._editPoint = function( latLng ) {
            var changed,
                oldVal = this.points[ this.currentIndex ];
            this.points[ this.currentIndex ] = latLng;
            // this comparison is not completely accurate
            // e.g. [50,1] should be equal to {lat: 50, lng: 1}
            // but this should not cause errors
            //return JSON.stringify( oldVal ) !== JSON.stringify( latLng );

            changed = this._updateValue();

            if ( changed ) {
                this._updateMap();
            }
            return changed;
        };

        /**
         * Removes the current point
         */
        Geopicker.prototype._removePoint = function() {
            var newIndex = this.currentIndex;
            this.points.splice( this.currentIndex, 1 );
            this._updateValue();
            this.$points.find( '.point' ).eq( this.currentIndex ).remove();
            if ( typeof this.points[ this.currentIndex ] === 'undefined' ) {
                newIndex = this.currentIndex - 1;
            }
            this._setCurrent( newIndex );
            // this will call updateMarkers for the second time which is not so efficient
            this._updateMap();
        };

        Geopicker.prototype._closePolygon = function() {
            var lastPoint = this.points[ this.points.length - 1 ];
            console.log( 'closing polygon' );
            // check if chain can be closed
            if ( this.points.length < 3 || ( this.points.length === 3 && !this._isValidLatLng( this.points[ 2 ] ) ) || ( JSON.stringify( this.points[ 0 ] ) === JSON.stringify( lastPoint ) ) ) {
                return;
            }

            // determine which point the make the closing point
            // if the last point is not a valid point, assume the user wants to use this to close
            // otherwise create a new point.
            if ( !this._isValidLatLng( lastPoint ) ) {
                console.log( 'current last point is not a valid point, so will use this as closing point' );
                this.currentIndex = this.points.length - 1;
            } else {
                console.log( 'current last point is valid, so will create a new one to use to close' );
                this._addPoint();
            }

            this._updateInputs( this.points[ 0 ] );
        };

        /**
         * Updates the (fake) input element for latitude, longitude, altitude and accuracy
         *
         * @param  @param  {Array.<number>|{lat: number, lng: number, alt: number, acc: number}} coords latitude, longitude, altitude and accuracy
         * @param  {string=} ev  [description]
         */
        Geopicker.prototype._updateInputs = function( coords, ev ) {
            var lat = coords[ 0 ] || coords.lat || '',
                lng = coords[ 1 ] || coords.lng || '',
                alt = coords[ 2 ] || coords.alt || '',
                acc = coords[ 3 ] || coords.acc || '';

            ev = ( typeof ev !== 'undefined' ) ? ev : 'change';

            this.$lat.val( Math.round( lat * 10000 ) / 10000 || '' );
            this.$lng.val( Math.round( lng * 10000 ) / 10000 || '' );
            this.$alt.val( Math.round( alt * 10 ) / 10 || '' );
            this.$acc.val( Math.round( acc * 10 ) / 10 || '' ).trigger( ev );
        };

        /**
         * Disables the widget
         */
        Geopicker.prototype.disable = function() {
            this.$map.hide();
            this.$widget.find( '.btn' ).addClass( 'disabled' );
        };

        /**
         * Enables a disabled widget
         */
        Geopicker.prototype.enable = function() {
            this.$map.show();
            this.$widget.find( '.btn' ).removeClass( 'disabled' );
        };


        $.fn[ pluginName ] = function( options, event ) {

            return this.each( function() {
                var $this = $( this ),
                    data = $( this ).data( pluginName );

                options = options || {};

                if ( !data && typeof options === 'object' ) {
                    $this.data( pluginName, ( data = new Geopicker( this, options, event ) ) );
                } else if ( data && typeof options == 'string' ) {
                    //pass the context, used for destroy() as this method is called on a cloned widget
                    data[ options ]( this );
                }
            } );
        };

    } );

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/table/tablewidget',[ 'enketo-js/Widget', 'jquery', 'enketo-js/plugins' ], function( Widget, $ ) {
    

    var pluginName = 'tablewidget';

    /**
     * Takes care of fixing awkward header XML produced with PYXForm appearance="table-list"
     * This js file can hopefully be removed in the future.
     *
     * See https://github.com/SEL-Columbia/pyxform/issues/72
     *
     * @constructor
     * @param {Element} element Element to apply widget to.
     * @param {(boolean|{touch: boolean})} options options
     * @param {*=} event     event
     */

    function Tablewidget( element, options, event ) {
        this.namespace = pluginName;
        Widget.call( this, element, options );
        this.init();
    }

    //copy the prototype functions from the Widget super class
    Tablewidget.prototype = Object.create( Widget.prototype );

    //ensure the constructor is the new one
    Tablewidget.prototype.constructor = Tablewidget;

    Tablewidget.prototype.init = function() {
        this.fixXlsFormShortcutMarkup();
    };

    Tablewidget.prototype.fixXlsFormShortcutMarkup = function() {
        var $labels, $hints, $note, $h4,
            that = this;
        $( this.element ).parent().parent()
            .find( '.or-appearance-field-list .or-appearance-label' )
            .prev( '.note' ).each( function() {
                $note = $( this );
                $labels = $note.find( '.question-label' );
                $hints = $note.find( '.or-hint' );
                // add a proper h4 element and append the labels and hints
                $( '<h4></h4>' ).insertAfter( $note ).append( $labels ).append( $hints );

                // remove the original note
                $note.remove();
            } );
    };

    /**
     * Override default destroy method to do nothing
     *
     * @param  {Element} element The element (not) to destroy the widget on ;)
     */
    Tablewidget.prototype.destroy = function( element ) {
        //nothing to do
        console.debug( pluginName, 'destroy called' );
    };

    $.fn[ pluginName ] = function( options, event ) {

        options = options || {};

        return this.each( function() {
            var $this = $( this ),
                data = $this.data( pluginName );

            if ( !data && typeof options === 'object' ) {
                $this.data( pluginName, ( data = new Tablewidget( this, options, event ) ) );
            } else if ( data && typeof options == 'string' ) {
                data[ options ]( this );
            }
        } );
    };

} );

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/radio/radiopicker',[ 'enketo-js/Widget', 'jquery', 'enketo-js/plugins' ], function( Widget, $ ) {
    

    var $lastFocused = null,
        pluginName = 'radiopicker';

    /**
     * Enhances radio buttons
     *
     * @constructor
     * @param {Element} element Element to apply widget to.
     * @param {(boolean|{touch: boolean})} options options
     * @param {*=} event     event
     */

    function Radiopicker( element, options, event ) {
        this.namespace = pluginName;
        Widget.call( this, element, options );
        this._init();
    }

    //copy the prototype functions from the Widget super class
    Radiopicker.prototype = Object.create( Widget.prototype );

    //ensure the constructor is the new one
    Radiopicker.prototype.constructor = Radiopicker;

    /**
     * Initialize
     */
    Radiopicker.prototype._init = function() {
        this._setDelegatedHandlers();
    };

    /**
     * Set delegated event handlers
     */
    Radiopicker.prototype._setDelegatedHandlers = function() {
        var $label,
            $form = $( this.element );

        //applies a data-checked attribute to the parent label of a checked checkbox and radio button
        $form.on( 'click', 'input[type="radio"]:checked', function( event ) {
            $( this ).parent( 'label' ).siblings().removeAttr( 'data-checked' ).end().attr( 'data-checked', 'true' );
        } );

        $form.on( 'click', 'input[type="checkbox"]', function( event ) {
            $label = $( this ).parent( 'label' );
            if ( $( this ).is( ':checked' ) ) $label.attr( 'data-checked', 'true' );
            else $label.removeAttr( 'data-checked' );
        } );

        // new radiobutton/checkbox icons don't trigger focus event, which is necessary for 
        // progress update and subtle "required" message
        // we need to unfocus the previously focused elemnt
        $form.on( 'click', 'input[type="radio"], input[type="checkbox"]', function( event ) {
            if ( $lastFocused ) {
                $lastFocused.trigger( 'fakeblur' );
            }
            $lastFocused = $( this ).trigger( 'fakefocus' );
        } );
        // clear last focused element when a non-radio/checkbox element gets focus
        $form.on( 'focusin fakefocus', 'input:not([type="radio"], [type="checkbox"]), textarea, select', function( event ) {
            if ( $lastFocused ) {
                $lastFocused.trigger( 'fakeblur' );
            }
            $lastFocused = null;
        } );

        //defaults
        $form.find( 'input[type="radio"]:checked, input[type="checkbox"]:checked' ).parent( 'label' ).attr( 'data-checked', 'true' );

        //add unselect functionality
        $form.on( 'click', '[data-checked]>input[type="radio"]', function( event ) {
            $( this ).prop( 'checked', false ).trigger( 'change' ).parent().removeAttr( 'data-checked' );
        } );
    };

    /**
     * Override default destroy method to do nothing
     *
     * @param  {Element} element The element (not) to destroy the widget on ;)
     */
    Radiopicker.prototype.destroy = function( element ) {
        //all handlers are global and deep copies of repeats should keep functionality intact
        console.debug( pluginName, 'destroy called' );
    };


    $.fn[ pluginName ] = function( options, event ) {
        //this widget works globally, and only needs to be instantiated once per form
        var $this = $( this ),
            data = $this.data( pluginName );

        options = options || {};

        if ( !data && typeof options === 'object' ) {
            $this.data( pluginName, ( data = new Radiopicker( $this[ 0 ], options, event ) ) );
        } else if ( data && typeof options == 'string' ) {
            data[ options ]( this );
        }

        return this;
    };

} );

/* =========================================================
 * bootstrap-datepicker.js
 * Repo: https://github.com/eternicode/bootstrap-datepicker/
 * Demo: http://eternicode.github.io/bootstrap-datepicker/
 * Docs: http://bootstrap-datepicker.readthedocs.org/
 * Forked from http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Started by Stefan Petre; improvements by Andrew Rowls + contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

(function($, undefined) {

	var $window = $(window);

	function UTCDate(){
		return new Date(Date.UTC.apply(Date, arguments));
	}
	function UTCToday(){
		var today = new Date();
		return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
	}
	function alias(method){
		return function(){
			return this[method].apply(this, arguments);
		}
	}

	var DateArray = (function(){
		var extras = {
			get: function(i){
				return this.slice(i)[0];
			},
			contains: function(d){
				// Array.indexOf is not cross-browser;
				// $.inArray doesn't work with Dates
				var val = d && d.valueOf();
				for (var i=0, l=this.length; i<l; i++)
					if (this[i].valueOf() === val)
						return i;
				return -1;
			},
			remove: function(i){
				this.splice(i,1);
			},
			replace: function(new_array){
				if (!new_array)
					return;
				if (!$.isArray(new_array))
					new_array = [new_array];
				this.clear();
				this.push.apply(this, new_array);
			},
			clear: function(){
				this.splice(0);
			},
			copy: function(){
				var a = new DateArray();
				a.replace(this);
				return a;
			}
		};

		return function(){
			var a = [];
			a.push.apply(a, arguments);
			$.extend(a, extras);
			return a;
		}
	})();


	// Picker object

	var Datepicker = function(element, options) {
		this.dates = new DateArray();
		this.viewDate = UTCToday();
		this.focusDate = null;

		this._process_options(options);

		this.element = $(element);
		this.isInline = false;
		this.isInput = this.element.is('input');
		this.component = this.element.is('.date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
		this.hasInput = this.component && this.element.find('input').length;
		if(this.component && this.component.length === 0)
			this.component = false;

		this.picker = $(DPGlobal.template);
		this._buildEvents();
		this._attachEvents();

		if(this.isInline) {
			this.picker.addClass('datepicker-inline').appendTo(this.element);
		} else {
			this.picker.addClass('datepicker-dropdown dropdown-menu');
		}

		if (this.o.rtl){
			this.picker.addClass('datepicker-rtl');
		}

		this.viewMode = this.o.startView;

		if (this.o.calendarWeeks)
			this.picker.find('tfoot th.today')
						.attr('colspan', function(i, val){
							return parseInt(val) + 1;
						});

		this._allow_update = false;

		this.setStartDate(this._o.startDate);
		this.setEndDate(this._o.endDate);
		this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);

		this.fillDow();
		this.fillMonths();

		this._allow_update = true;

		this.update();
		this.showMode();

		if(this.isInline) {
			this.show();
		}
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		_process_options: function(opts){
			// Store raw options for reference
			this._o = $.extend({}, this._o, opts);
			// Processed options
			var o = this.o = $.extend({}, this._o);

			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			var lang = o.language;
			if (!dates[lang]) {
				lang = lang.split('-')[0];
				if (!dates[lang])
					lang = defaults.language;
			}
			o.language = lang;

			switch(o.startView){
				case 2:
				case 'decade':
					o.startView = 2;
					break;
				case 1:
				case 'year':
					o.startView = 1;
					break;
				default:
					o.startView = 0;
			}

			switch (o.minViewMode) {
				case 1:
				case 'months':
					o.minViewMode = 1;
					break;
				case 2:
				case 'years':
					o.minViewMode = 2;
					break;
				default:
					o.minViewMode = 0;
			}

			o.startView = Math.max(o.startView, o.minViewMode);

			// true, false, or Number > 0
			if (o.multidate !== true){
				o.multidate = Number(o.multidate) || false;
				if (o.multidate !== false)
					o.multidate = Math.max(0, o.multidate);
				else
					o.multidate = 1;
			}
			o.multidateSeparator = String(o.multidateSeparator);

			o.weekStart %= 7;
			o.weekEnd = ((o.weekStart + 6) % 7);

			var format = DPGlobal.parseFormat(o.format);
			if (o.startDate !== -Infinity) {
				if (!!o.startDate) {
					if (o.startDate instanceof Date)
						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
					else
						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);
				} else {
					o.startDate = -Infinity;
				}
			}
			if (o.endDate !== Infinity) {
				if (!!o.endDate) {
					if (o.endDate instanceof Date)
						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
					else
						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);
				} else {
					o.endDate = Infinity;
				}
			}

			o.daysOfWeekDisabled = o.daysOfWeekDisabled||[];
			if (!$.isArray(o.daysOfWeekDisabled))
				o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\s]*/);
			o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function (d) {
				return parseInt(d, 10);
			});

			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
				_plc = o.orientation.toLowerCase();
			plc = $.grep(plc, function(word){
				return (/^auto|left|right|top|bottom$/).test(word);
			});
			o.orientation = {x: 'auto', y: 'auto'};
			if (!_plc || _plc === 'auto')
				; // no action
			else if (plc.length === 1){
				switch(plc[0]){
					case 'top':
					case 'bottom':
						o.orientation.y = plc[0];
						break;
					case 'left':
					case 'right':
						o.orientation.x = plc[0];
						break;
				}
			}
			else {
				_plc = $.grep(plc, function(word){
					return (/^left|right$/).test(word);
				});
				o.orientation.x = _plc[0] || 'auto';

				_plc = $.grep(plc, function(word){
					return (/^top|bottom$/).test(word);
				});
				o.orientation.y = _plc[0] || 'auto';
			}
		},
		_events: [],
		_secondaryEvents: [],
		_applyEvents: function(evs){
			for (var i=0, el, ch, ev; i<evs.length; i++){
				el = evs[i][0];
				if (evs[i].length == 2){
					ch = undefined;
					ev = evs[i][1];
				}
				else if (evs[i].length == 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.on(ev, ch);
			}
		},
		_unapplyEvents: function(evs){
			for (var i=0, el, ev; i<evs.length; i++){
				el = evs[i][0];
				if (evs[i].length == 2){
					ch = undefined;
					ev = evs[i][1];
				}
				else if (evs[i].length == 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.off(ev, ch);
			}
		},
		_buildEvents: function(){
			if (this.isInput) { // single input
				this._events = [
					[this.element, {
						focus: $.proxy(this.show, this),
						keyup: $.proxy(function(e){
							if ($.inArray(e.keyCode, [27,37,39,38,40,32,13,9]) === -1)
								this.update();
						}, this),
						keydown: $.proxy(this.keydown, this)
					}]
				];
			}
			else if (this.component && this.hasInput){ // component: input + button
				this._events = [
					// For components that are not readonly, allow keyboard nav
					[this.element.find('input'), {
						focus: $.proxy(this.show, this),
						keyup: $.proxy(function(e){
							if ($.inArray(e.keyCode, [27,37,39,38,40,32,13,9]) === -1)
								this.update()
						}, this),
						keydown: $.proxy(this.keydown, this)
					}],
					[this.component, {
						click: $.proxy(this.show, this)
					}]
				];
			}
			else if (this.element.is('div')) {  // inline datepicker
				this.isInline = true;
			}
			else {
				this._events = [
					[this.element, {
						click: $.proxy(this.show, this)
					}]
				];
			}
			this._events.push(
				// Component: listen for blur on element descendants
				[this.element, '*', {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}],
				// Input: listen for blur on element
				[this.element, {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}]
			);

			this._secondaryEvents = [
				[this.picker, {
					click: $.proxy(this.click, this)
				}],
				[$(window), {
					resize: $.proxy(this.place, this)
				}],
				[$(document), {
					'mousedown touchstart': $.proxy(function (e) {
						// Clicked outside the datepicker, hide it
						if (!(
							this.element.is(e.target) ||
							this.element.find(e.target).length ||
							this.picker.is(e.target) ||
							this.picker.find(e.target).length
						)) {
							this.hide();
						}
					}, this)
				}]
			];
		},
		_attachEvents: function(){
			this._detachEvents();
			this._applyEvents(this._events);
		},
		_detachEvents: function(){
			this._unapplyEvents(this._events);
		},
		_attachSecondaryEvents: function(){
			this._detachSecondaryEvents();
			this._applyEvents(this._secondaryEvents);
		},
		_detachSecondaryEvents: function(){
			this._unapplyEvents(this._secondaryEvents);
		},
		_trigger: function(event, altdate){
			var date = altdate || this.dates.get(-1),
				local_date = this._utc_to_local(date);

			this.element.trigger({
				type: event,
				date: local_date,
				dates: $.map(this.dates, this._utc_to_local),
				format: $.proxy(function(ix, format){
					if (arguments.length === 0){
						ix = this.dates.length - 1;
						format = this.o.format;
					}
					else if (typeof ix == 'string'){
						format = ix;
						ix = this.dates.length - 1;
					}
					format = format || this.o.format;
					var date = this.dates.get(ix);
					return DPGlobal.formatDate(date, format, this.o.language);
				}, this)
			});
		},

		show: function(e) {
			if (!this.isInline)
				this.picker.appendTo('body');
			this.picker.show();
			this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
			this.place();
			this._attachSecondaryEvents();
			this._trigger('show');
		},

		hide: function(){
			if(this.isInline) return;
			if (!this.picker.is(':visible')) return;
			this.focusDate = null;
			this.picker.hide().detach();
			this._detachSecondaryEvents();
			this.viewMode = this.o.startView;
			this.showMode();

			if (
				this.o.forceParse &&
				(
					this.isInput && this.element.val() ||
					this.hasInput && this.element.find('input').val()
				)
			)
				this.setValue();
			this._trigger('hide');
		},

		remove: function() {
			this.hide();
			this._detachEvents();
			this._detachSecondaryEvents();
			this.picker.remove();
			delete this.element.data().datepicker;
			if (!this.isInput) {
				delete this.element.data().date;
			}
		},

		_utc_to_local: function(utc){
			return utc && new Date(utc.getTime() + (utc.getTimezoneOffset()*60000));
		},
		_local_to_utc: function(local){
			return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
		},
		_zero_time: function(local){
			return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
		},
		_zero_utc_time: function(utc){
			return utc && new Date(Date.UTC(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate()));
		},

		getDates: function(){
			return $.map(this.dates, this._utc_to_local);
		},

		getUTCDates: function(){
			return $.map(this.dates, function(d){ return new Date(d); });
		},

		getDate: function() {
			return this._utc_to_local(this.getUTCDate());
		},

		getUTCDate: function() {
			return new Date(this.dates.get(-1));
		},

		setDates: function() {
			this.update.apply(this, arguments);
			this._trigger('changeDate');
			this.setValue();
		},

		setUTCDates: function() {
			this.update.apply(this, $.map(arguments, this._utc_to_local));
			this._trigger('changeDate');
			this.setValue();
		},

		setDate: alias('setDates'),
		setUTCDate: alias('setUTCDates'),

		setValue: function() {
			var formatted = this.getFormattedDate();
			if (!this.isInput) {
				if (this.component){
					this.element.find('input').val(formatted).change();
				}
			} else {
				this.element.val(formatted).change();
			}
		},

		getFormattedDate: function(format) {
			if (format === undefined)
				format = this.o.format;

			var lang = this.o.language;
			return $.map(this.dates, function(d){
				return DPGlobal.formatDate(d, format, lang);
			}).join(this.o.multidateSeparator);
		},

		setStartDate: function(startDate){
			this._process_options({startDate: startDate});
			this.update();
			this.updateNavArrows();
		},

		setEndDate: function(endDate){
			this._process_options({endDate: endDate});
			this.update();
			this.updateNavArrows();
		},

		setDaysOfWeekDisabled: function(daysOfWeekDisabled){
			this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
			this.update();
			this.updateNavArrows();
		},

		place: function(){
						if(this.isInline) return;
			var calendarWidth = this.picker.outerWidth(),
				calendarHeight = this.picker.outerHeight(),
				visualPadding = 10,
				windowWidth = $window.width(),
				windowHeight = $window.height(),
				scrollTop = $window.scrollTop();

			var zIndex = parseInt(this.element.parents().filter(function() {
							return $(this).css('z-index') != 'auto';
						}).first().css('z-index'))+10;
			var offset = this.component ? this.component.parent().offset() : this.element.offset();
			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
			var left = offset.left,
				top = offset.top;

			this.picker.removeClass(
				'datepicker-orient-top datepicker-orient-bottom '+
				'datepicker-orient-right datepicker-orient-left'
			);

			if (this.o.orientation.x !== 'auto') {
				this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
				if (this.o.orientation.x === 'right')
					left -= calendarWidth - width;
			}
			// auto x orientation is best-placement: if it crosses a window
			// edge, fudge it sideways
			else {
				// Default to left
				this.picker.addClass('datepicker-orient-left');
				if (offset.left < 0)
					left -= offset.left - visualPadding;
				else if (offset.left + calendarWidth > windowWidth)
					left = windowWidth - calendarWidth - visualPadding;
			}

			// auto y orientation is best-situation: top or bottom, no fudging,
			// decision based on which shows more of the calendar
			var yorient = this.o.orientation.y,
				top_overflow, bottom_overflow;
			if (yorient === 'auto') {
				top_overflow = -scrollTop + offset.top - calendarHeight;
				bottom_overflow = scrollTop + windowHeight - (offset.top + height + calendarHeight);
				if (Math.max(top_overflow, bottom_overflow) === bottom_overflow)
					yorient = 'top';
				else
					yorient = 'bottom';
			}
			this.picker.addClass('datepicker-orient-' + yorient);
			if (yorient === 'top')
				top += height;
			else
				top -= calendarHeight + parseInt(this.picker.css('padding-top'));

			this.picker.css({
				top: top,
				left: left,
				zIndex: zIndex
			});
		},

		_allow_update: true,
		update: function(){
			if (!this._allow_update) return;

			var oldDates = this.dates.copy(),
				dates = [],
				fromArgs = false;
			if(arguments.length) {
				$.each(arguments, $.proxy(function(i, date){
					if (date instanceof Date)
						date = this._local_to_utc(date);
					dates.push(date);
				}, this));
				fromArgs = true;
			} else {
				dates = this.isInput
						? this.element.val()
						: this.element.data('date') || this.element.find('input').val();
				if (dates && this.o.multidate)
					dates = dates.split(this.o.multidateSeparator);
				else
					dates = [dates];
				delete this.element.data().date;
			}

			dates = $.map(dates, $.proxy(function(date){
				return DPGlobal.parseDate(date, this.o.format, this.o.language);
			}, this));
			dates = $.grep(dates, $.proxy(function(date){
				return (
					date < this.o.startDate ||
					date > this.o.endDate ||
					!date
				);
			}, this), true);
			this.dates.replace(dates);

			if (this.dates.length)
				this.viewDate = new Date(this.dates.get(-1));
			else if (this.viewDate < this.o.startDate)
				this.viewDate = new Date(this.o.startDate);
			else if (this.viewDate > this.o.endDate)
				this.viewDate = new Date(this.o.endDate);

			if (fromArgs) {
				// setting date by clicking
				this.setValue();
			} else if (dates.length) {
				// setting date by typing
				if (String(oldDates) !== String(this.dates))
					this._trigger('changeDate');
			}
			if (!this.dates.length && oldDates.length)
				this._trigger('clearDate');

			this.fill();
		},

		fillDow: function(){
			var dowCnt = this.o.weekStart,
			html = '<tr>';
			if(this.o.calendarWeeks){
				var cell = '<th class="cw">&nbsp;</th>';
				html += cell;
				this.picker.find('.datepicker-days thead tr:first-child').prepend(cell);
			}
			while (dowCnt < this.o.weekStart + 7) {
				html += '<th class="dow">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
		},

		fillMonths: function(){
			var html = '',
			i = 0;
			while (i < 12) {
				html += '<span class="month">'+dates[this.o.language].monthsShort[i++]+'</span>';
			}
			this.picker.find('.datepicker-months td').html(html);
		},

		setRange: function(range){
			if (!range || !range.length)
				delete this.range;
			else
				this.range = $.map(range, function(d){ return d.valueOf(); });
			this.fill();
		},

		getClassNames: function(date){
			var cls = [],
				year = this.viewDate.getUTCFullYear(),
				month = this.viewDate.getUTCMonth(),
				today = new Date();
			if (date.getUTCFullYear() < year || (date.getUTCFullYear() == year && date.getUTCMonth() < month)) {
				cls.push('old');
			} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() == year && date.getUTCMonth() > month)) {
				cls.push('new');
			}
			if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
				cls.push('focused');
			// Compare internal UTC date with local today, not UTC today
			if (this.o.todayHighlight &&
				date.getUTCFullYear() == today.getFullYear() &&
				date.getUTCMonth() == today.getMonth() &&
				date.getUTCDate() == today.getDate()) {
				cls.push('today');
			}
			if (this.dates.contains(date) !== -1)
				cls.push('active');
			if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate ||
				$.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) {
				cls.push('disabled');
			}
			if (this.range){
				if (date > this.range[0] && date < this.range[this.range.length-1]){
					cls.push('range');
				}
				if ($.inArray(date.valueOf(), this.range) != -1){
					cls.push('selected');
				}
			}
			return cls;
		},

		fill: function() {
			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				tooltip, currentYear;
			this.picker.find('.datepicker-days thead th.datepicker-switch')
						.text(dates[this.o.language].months[month]+' '+year);
			this.picker.find('tfoot th.today')
						.text(dates[this.o.language].today)
						.toggle(this.o.todayBtn !== false);
			this.picker.find('tfoot th.clear')
						.text(dates[this.o.language].clear)
						.toggle(this.o.clearBtn !== false);
			this.updateNavArrows();
			this.fillMonths();
			var prevMonth = UTCDate(year, month-1, 28),
				day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
			prevMonth.setUTCDate(day);
			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
			var nextMonth = new Date(prevMonth);
			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
			nextMonth = nextMonth.valueOf();
			var html = [];
			var clsName;
			while(prevMonth.valueOf() < nextMonth) {
				if (prevMonth.getUTCDay() == this.o.weekStart) {
					html.push('<tr>');
					if(this.o.calendarWeeks){
						// ISO 8601: First week contains first thursday.
						// ISO also states week starts on Monday, but we can be more abstract here.
						var
							// Start of current week: based on weekstart/current date
							ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),
							// Thursday of this week
							th = new Date(+ws + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
							// First Thursday of year, year from thursday
							yth = new Date(+(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay())%7*864e5),
							// Calendar week: ms between thursdays, div ms per day, div 7 days
							calWeek =  (th - yth) / 864e5 / 7 + 1;
						html.push('<td class="cw">'+ calWeek +'</td>');

					}
				}
				clsName = this.getClassNames(prevMonth);
				clsName.push('day');

				if (this.o.beforeShowDay !== $.noop){
					var before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
					if (before === undefined)
						before = {};
					else if (typeof(before) === 'boolean')
						before = {enabled: before};
					else if (typeof(before) === 'string')
						before = {classes: before};
					if (before.enabled === false)
						clsName.push('disabled');
					if (before.classes)
						clsName = clsName.concat(before.classes.split(/\s+/));
					if (before.tooltip)
						tooltip = before.tooltip;
				}

				clsName = $.unique(clsName);
				html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + '>'+prevMonth.getUTCDate() + '</td>');
				if (prevMonth.getUTCDay() == this.o.weekEnd) {
					html.push('</tr>');
				}
				prevMonth.setUTCDate(prevMonth.getUTCDate()+1);
			}
			this.picker.find('.datepicker-days tbody').empty().append(html.join(''));

			var months = this.picker.find('.datepicker-months')
						.find('th:eq(1)')
							.text(year)
							.end()
						.find('span').removeClass('active');

			$.each(this.dates, function(i, d){
				if (d.getUTCFullYear() == year)
					months.eq(d.getUTCMonth()).addClass('active');
			});

			if (year < startYear || year > endYear) {
				months.addClass('disabled');
			}
			if (year == startYear) {
				months.slice(0, startMonth).addClass('disabled');
			}
			if (year == endYear) {
				months.slice(endMonth+1).addClass('disabled');
			}

			html = '';
			year = parseInt(year/10, 10) * 10;
			var yearCont = this.picker.find('.datepicker-years')
								.find('th:eq(1)')
									.text(year + '-' + (year + 9))
									.end()
								.find('td');
			year -= 1;
			var years = $.map(this.dates, function(d){ return d.getUTCFullYear(); }),
				classes;
			for (var i = -1; i < 11; i++) {
				classes = ['year'];
				if (i === -1)
					classes.push('old');
				else if (i === 10)
					classes.push('new');
				if ($.inArray(year, years) !== -1)
					classes.push('active');
				if (year < startYear || year > endYear)
					classes.push('disabled');
				html += '<span class="' + classes.join(' ') + '">'+year+'</span>';
				year += 1;
			}
			yearCont.html(html);
		},

		updateNavArrows: function() {
			if (!this._allow_update) return;

			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth();
			switch (this.viewMode) {
				case 0:
					if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()) {
						this.picker.find('.prev').css({visibility: 'hidden'});
					} else {
						this.picker.find('.prev').css({visibility: 'visible'});
					}
					if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()) {
						this.picker.find('.next').css({visibility: 'hidden'});
					} else {
						this.picker.find('.next').css({visibility: 'visible'});
					}
					break;
				case 1:
				case 2:
					if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()) {
						this.picker.find('.prev').css({visibility: 'hidden'});
					} else {
						this.picker.find('.prev').css({visibility: 'visible'});
					}
					if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()) {
						this.picker.find('.next').css({visibility: 'hidden'});
					} else {
						this.picker.find('.next').css({visibility: 'visible'});
					}
					break;
			}
		},

		click: function(e) {
			e.preventDefault();
			var target = $(e.target).closest('span, td, th'),
				year, month, day;
			if (target.length == 1) {
				switch(target[0].nodeName.toLowerCase()) {
					case 'th':
						switch(target[0].className) {
							case 'datepicker-switch':
								this.showMode(1);
								break;
							case 'prev':
							case 'next':
								var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);
								switch(this.viewMode){
									case 0:
										this.viewDate = this.moveMonth(this.viewDate, dir);
										this._trigger('changeMonth', this.viewDate);
										break;
									case 1:
									case 2:
										this.viewDate = this.moveYear(this.viewDate, dir);
										if (this.viewMode === 1)
											this._trigger('changeYear', this.viewDate);
										break;
								}
								this.fill();
								break;
							case 'today':
								var date = new Date();
								date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);

								this.showMode(-2);
								var which = this.o.todayBtn == 'linked' ? null : 'view';
								this._setDate(date, which);
								break;
							case 'clear':
								var element;
								if (this.isInput)
									element = this.element;
								else if (this.component)
									element = this.element.find('input');
								if (element)
									element.val("").change();
								this.update();
								this._trigger('changeDate');
								if (this.o.autoclose)
									this.hide();
								break;
						}
						break;
					case 'span':
						if (!target.is('.disabled')) {
							this.viewDate.setUTCDate(1);
							if (target.is('.month')) {
								day = 1;
								month = target.parent().find('span').index(target);
								year = this.viewDate.getUTCFullYear();
								this.viewDate.setUTCMonth(month);
								this._trigger('changeMonth', this.viewDate);
								if (this.o.minViewMode === 1) {
									this._setDate(UTCDate(year, month, day));
								}
							} else {
								day = 1;
								month = 0;
								year = parseInt(target.text(), 10)||0;
								this.viewDate.setUTCFullYear(year);
								this._trigger('changeYear', this.viewDate);
								if (this.o.minViewMode === 2) {
									this._setDate(UTCDate(year, month, day));
								}
							}
							this.showMode(-1);
							this.fill();
						}
						break;
					case 'td':
						if (target.is('.day') && !target.is('.disabled')){
							day = parseInt(target.text(), 10)||1;
							year = this.viewDate.getUTCFullYear();
							month = this.viewDate.getUTCMonth();
							if (target.is('.old')) {
								if (month === 0) {
									month = 11;
									year -= 1;
								} else {
									month -= 1;
								}
							} else if (target.is('.new')) {
								if (month == 11) {
									month = 0;
									year += 1;
								} else {
									month += 1;
								}
							}
							this._setDate(UTCDate(year, month, day));
						}
						break;
				}
			}
			if (this.picker.is(':visible') && this._focused_from){
				$(this._focused_from).focus();
			}
			delete this._focused_from;
		},

		_toggle_multidate: function( date ) {
			var ix = this.dates.contains(date);
			if (!date){
				this.dates.clear();
			}
			else if (ix !== -1){
				this.dates.remove(ix);
			}
			else{
				this.dates.push(date);
			}
			if (typeof this.o.multidate == 'number')
				while (this.dates.length > this.o.multidate)
					this.dates.remove(0);
		},

		_setDate: function(date, which){
			if (!which || which == 'date')
				this._toggle_multidate(date && new Date(date));
			if (!which || which  == 'view')
				this.viewDate = date && new Date(date);

			this.fill();
			this.setValue();
			this._trigger('changeDate');
			var element;
			if (this.isInput) {
				element = this.element;
			} else if (this.component){
				element = this.element.find('input');
			}
			if (element) {
				element.change();
			}
			if (this.o.autoclose && (!which || which == 'date')) {
				this.hide();
			}
		},

		moveMonth: function(date, dir){
			if (!date) return undefined;
			if (!dir) return date;
			var new_date = new Date(date.valueOf()),
				day = new_date.getUTCDate(),
				month = new_date.getUTCMonth(),
				mag = Math.abs(dir),
				new_month, test;
			dir = dir > 0 ? 1 : -1;
			if (mag == 1){
				test = dir == -1
					// If going back one month, make sure month is not current month
					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
					? function(){ return new_date.getUTCMonth() == month; }
					// If going forward one month, make sure month is as expected
					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
					: function(){ return new_date.getUTCMonth() != new_month; };
				new_month = month + dir;
				new_date.setUTCMonth(new_month);
				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
				if (new_month < 0 || new_month > 11)
					new_month = (new_month + 12) % 12;
			} else {
				// For magnitudes >1, move one month at a time...
				for (var i=0; i<mag; i++)
					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
					new_date = this.moveMonth(new_date, dir);
				// ...then reset the day, keeping it in the new month
				new_month = new_date.getUTCMonth();
				new_date.setUTCDate(day);
				test = function(){ return new_month != new_date.getUTCMonth(); };
			}
			// Common date-resetting loop -- if date is beyond end of month, make it
			// end of month
			while (test()){
				new_date.setUTCDate(--day);
				new_date.setUTCMonth(new_month);
			}
			return new_date;
		},

		moveYear: function(date, dir){
			return this.moveMonth(date, dir*12);
		},

		dateWithinRange: function(date){
			return date >= this.o.startDate && date <= this.o.endDate;
		},

		keydown: function(e){
			if (this.picker.is(':not(:visible)')){
				if (e.keyCode == 27) // allow escape to hide and re-show picker
					this.show();
				return;
			}
			var dateChanged = false,
				dir, newDate, newViewDate,
				focusDate = this.focusDate || this.viewDate;
			switch(e.keyCode){
				case 27: // escape
					if (this.focusDate){
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
					}
					else
						this.hide();
					e.preventDefault();
					break;
				case 37: // left
				case 39: // right
					if (!this.o.keyboardNavigation) break;
					dir = e.keyCode == 37 ? -1 : 1;
					if (e.ctrlKey){
						newDate = this.moveYear(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveYear(focusDate, dir);
						this._trigger('changeYear', this.viewDate);
					} else if (e.shiftKey){
						newDate = this.moveMonth(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveMonth(focusDate, dir);
						this._trigger('changeMonth', this.viewDate);
					} else {
						newDate = new Date(this.dates.get(-1) || UTCToday());
						newDate.setUTCDate(newDate.getUTCDate() + dir);
						newViewDate = new Date(focusDate);
						newViewDate.setUTCDate(focusDate.getUTCDate() + dir);
					}
					if (this.dateWithinRange(newDate)){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 38: // up
				case 40: // down
					if (!this.o.keyboardNavigation) break;
					dir = e.keyCode == 38 ? -1 : 1;
					if (e.ctrlKey){
						newDate = this.moveYear(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveYear(focusDate, dir);
						this._trigger('changeYear', this.viewDate);
					} else if (e.shiftKey){
						newDate = this.moveMonth(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveMonth(focusDate, dir);
						this._trigger('changeMonth', this.viewDate);
					} else {
						newDate = new Date(this.dates.get(-1) || UTCToday());
						newDate.setUTCDate(newDate.getUTCDate() + dir * 7);
						newViewDate = new Date(focusDate);
						newViewDate.setUTCDate(focusDate.getUTCDate() + dir * 7);
					}
					if (this.dateWithinRange(newDate)){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 32: // spacebar
					focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
					this._toggle_multidate(focusDate);
					dateChanged = true;
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.setValue();
					this.fill();
					e.preventDefault();
					break;
				case 13: // enter
					if (this.focusDate){
						this._toggle_multidate(this.focusDate);
						dateChanged = true;
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.setValue();
						this.fill();
					}
					this.hide();
					e.preventDefault();
					break;
				case 9: // tab
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.fill();
					this.hide();
					break;
			}
			if (dateChanged){
				if (this.dates.length)
					this._trigger('changeDate');
				else
					this._trigger('clearDate');
				var element;
				if (this.isInput) {
					element = this.element;
				} else if (this.component){
					element = this.element.find('input');
				}
				if (element) {
					element.change();
				}
			}
		},

		showMode: function(dir) {
			if (dir) {
				this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));
			}
			/*
				vitalets: fixing bug of very special conditions:
				jquery 1.7.1 + webkit + show inline datepicker in bootstrap popover.
				Method show() does not set display css correctly and datepicker is not shown.
				Changed to .css('display', 'block') solve the problem.
				See https://github.com/vitalets/x-editable/issues/37

				In jquery 1.7.2+ everything works fine.
			*/
			//this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();
			this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).css('display', 'block');
			this.updateNavArrows();
		}
	};

	var DateRangePicker = function(element, options){
		this.element = $(element);
		this.inputs = $.map(options.inputs, function(i){ return i.jquery ? i[0] : i; });
		delete options.inputs;

		$(this.inputs)
			.datepicker(options)
			.bind('changeDate', $.proxy(this.dateUpdated, this));

		this.pickers = $.map(this.inputs, function(i){ return $(i).data('datepicker'); });
		this.updateDates();
	};
	DateRangePicker.prototype = {
		updateDates: function(){
			this.dates = $.map(this.pickers, function(i){ return i.getUTCDate(); });
			this.updateRanges();
		},
		updateRanges: function(){
			var range = $.map(this.dates, function(d){ return d.valueOf(); });
			$.each(this.pickers, function(i, p){
				p.setRange(range);
			});
		},
		dateUpdated: function(e){
			// `this.updating` is a workaround for preventing infinite recursion
			// between `changeDate` triggering and `setUTCDate` calling.  Until
			// there is a better mechanism.
			if (this.updating)
				return;
			this.updating = true;

			var dp = $(e.target).data('datepicker'),
				new_date = dp.getUTCDate(),
				i = $.inArray(e.target, this.inputs),
				l = this.inputs.length;
			if (i == -1) return;

			$.each(this.pickers, function(i, p){
				if (!p.getUTCDate())
					p.setUTCDate(new_date);
			});

			if (new_date < this.dates[i]){
				// Date being moved earlier/left
				while (i>=0 && new_date < this.dates[i]){
					this.pickers[i--].setUTCDate(new_date);
				}
			}
			else if (new_date > this.dates[i]){
				// Date being moved later/right
				while (i<l && new_date > this.dates[i]){
					this.pickers[i++].setUTCDate(new_date);
				}
			}
			this.updateDates();

			delete this.updating;
		},
		remove: function(){
			$.map(this.pickers, function(p){ p.remove(); });
			delete this.element.data().datepicker;
		}
	};

	function opts_from_el(el, prefix){
		// Derive options from element data-attrs
		var data = $(el).data(),
			out = {}, inkey,
			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'),
			prefix = new RegExp('^' + prefix.toLowerCase());
		for (var key in data)
			if (prefix.test(key)){
				inkey = key.replace(replace, function(_,a){ return a.toLowerCase(); });
				out[inkey] = data[key];
			}
		return out;
	}

	function opts_from_locale(lang){
		// Derive options from locale plugins
		var out = {};
		// Check if "de-DE" style date is available, if not language should
		// fallback to 2 letter code eg "de"
		if (!dates[lang]) {
			lang = lang.split('-')[0];
			if (!dates[lang])
				return;
		}
		var d = dates[lang];
		$.each(locale_opts, function(i,k){
			if (k in d)
				out[k] = d[k];
		});
		return out;
	}

	var old = $.fn.datepicker;
	$.fn.datepicker = function ( option ) {
		var args = Array.apply(null, arguments);
		args.shift();
		var internal_return;
		this.each(function () {
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option == 'object' && option;
			if (!data) {
				var elopts = opts_from_el(this, 'date'),
					// Preliminary otions
					xopts = $.extend({}, defaults, elopts, options),
					locopts = opts_from_locale(xopts.language),
					// Options priority: js args, data-attrs, locales, defaults
					opts = $.extend({}, defaults, locopts, elopts, options);
				if ($this.is('.input-daterange') || opts.inputs){
					var ropts = {
						inputs: opts.inputs || $this.find('input').toArray()
					};
					$this.data('datepicker', (data = new DateRangePicker(this, $.extend(opts, ropts))));
				}
				else{
					$this.data('datepicker', (data = new Datepicker(this, opts)));
				}
			}
			if (typeof option == 'string' && typeof data[option] == 'function') {
				internal_return = data[option].apply(data, args);
				if (internal_return !== undefined)
					return false;
			}
		});
		if (internal_return !== undefined)
			return internal_return;
		else
			return this;
	};

	var defaults = $.fn.datepicker.defaults = {
		autoclose: false,
		beforeShowDay: $.noop,
		calendarWeeks: false,
		clearBtn: false,
		daysOfWeekDisabled: [],
		endDate: Infinity,
		forceParse: true,
		format: 'mm/dd/yyyy',
		keyboardNavigation: true,
		language: 'en',
		minViewMode: 0,
		multidate: false,
		multidateSeparator: ',',
		orientation: "auto",
		rtl: false,
		startDate: -Infinity,
		startView: 0,
		todayBtn: false,
		todayHighlight: false,
		weekStart: 0
	};
	var locale_opts = $.fn.datepicker.locale_opts = [
		'format',
		'rtl',
		'weekStart'
	];
	$.fn.datepicker.Constructor = Datepicker;
	var dates = $.fn.datepicker.dates = {
		en: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			today: "Today",
			clear: "Clear"
		}
	};

	var DPGlobal = {
		modes: [
			{
				clsName: 'days',
				navFnc: 'Month',
				navStep: 1
			},
			{
				clsName: 'months',
				navFnc: 'FullYear',
				navStep: 1
			},
			{
				clsName: 'years',
				navFnc: 'FullYear',
				navStep: 10
		}],
		isLeapYear: function (year) {
			return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
		},
		getDaysInMonth: function (year, month) {
			return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
		},
		validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
		nonpunctuation: /[^ -\/:-@\[\u3400-\u9fff-`{-~\t\n\r]+/g,
		parseFormat: function(format){
			// IE treats \0 as a string end in inputs (truncating the value),
			// so it's a bad format delimiter, anyway
			var separators = format.replace(this.validParts, '\0').split('\0'),
				parts = format.match(this.validParts);
			if (!separators || !separators.length || !parts || parts.length === 0){
				throw new Error("Invalid date format.");
			}
			return {separators: separators, parts: parts};
		},
		parseDate: function(date, format, language) {
			if (!date)
				return undefined;
			if (date instanceof Date) return date;
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)) {
				var part_re = /([\-+]\d+)([dmwy])/,
					parts = date.match(/([\-+]\d+)([dmwy])/g),
					part, dir;
				date = new Date();
				for (var i=0; i<parts.length; i++) {
					part = part_re.exec(parts[i]);
					dir = parseInt(part[1]);
					switch(part[2]){
						case 'd':
							date.setUTCDate(date.getUTCDate() + dir);
							break;
						case 'm':
							date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);
							break;
						case 'w':
							date.setUTCDate(date.getUTCDate() + dir * 7);
							break;
						case 'y':
							date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);
							break;
					}
				}
				return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
			}
			var parts = date && date.match(this.nonpunctuation) || [],
				date = new Date(),
				parsed = {},
				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
				setters_map = {
					yyyy: function(d,v){ return d.setUTCFullYear(v); },
					yy: function(d,v){ return d.setUTCFullYear(2000+v); },
					m: function(d,v){
						if (isNaN(d))
							return d;
						v -= 1;
						while (v<0) v += 12;
						v %= 12;
						d.setUTCMonth(v);
						while (d.getUTCMonth() != v)
							d.setUTCDate(d.getUTCDate()-1);
						return d;
					},
					d: function(d,v){ return d.setUTCDate(v); }
				},
				val, filtered, part;
			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
			setters_map['dd'] = setters_map['d'];
			date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
			var fparts = format.parts.slice();
			// Remove noop parts
			if (parts.length != fparts.length) {
				fparts = $(fparts).filter(function(i,p){
					return $.inArray(p, setters_order) !== -1;
				}).toArray();
			}
			// Process remainder
			if (parts.length == fparts.length) {
				for (var i=0, cnt = fparts.length; i < cnt; i++) {
					val = parseInt(parts[i], 10);
					part = fparts[i];
					if (isNaN(val)) {
						switch(part) {
							case 'MM':
								filtered = $(dates[language].months).filter(function(){
									var m = this.slice(0, parts[i].length),
										p = parts[i].slice(0, m.length);
									return m == p;
								});
								val = $.inArray(filtered[0], dates[language].months) + 1;
								break;
							case 'M':
								filtered = $(dates[language].monthsShort).filter(function(){
									var m = this.slice(0, parts[i].length),
										p = parts[i].slice(0, m.length);
									return m == p;
								});
								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
								break;
						}
					}
					parsed[part] = val;
				}
				for (var i=0, _date, s; i<setters_order.length; i++){
					s = setters_order[i];
					if (s in parsed && !isNaN(parsed[s])){
						_date = new Date(date);
						setters_map[s](_date, parsed[s]);
						if (!isNaN(_date))
							date = _date;
					}
				}
			}
			return date;
		},
		formatDate: function(date, format, language){
			if (!date)
				return '';
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			var val = {
				d: date.getUTCDate(),
				D: dates[language].daysShort[date.getUTCDay()],
				DD: dates[language].days[date.getUTCDay()],
				m: date.getUTCMonth() + 1,
				M: dates[language].monthsShort[date.getUTCMonth()],
				MM: dates[language].months[date.getUTCMonth()],
				yy: date.getUTCFullYear().toString().substring(2),
				yyyy: date.getUTCFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			var date = [],
				seps = $.extend([], format.separators);
			for (var i=0, cnt = format.parts.length; i <= cnt; i++) {
				if (seps.length)
					date.push(seps.shift());
				date.push(val[format.parts[i]]);
			}
			return date.join('');
		},
		headTemplate: '<thead>'+
							'<tr>'+
								'<th class="prev">&laquo;</th>'+
								'<th colspan="5" class="datepicker-switch"></th>'+
								'<th class="next">&raquo;</th>'+
							'</tr>'+
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
		footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'
	};
	DPGlobal.template = '<div class="datepicker">'+
							'<div class="datepicker-days">'+
								'<table class=" table-condensed">'+
									DPGlobal.headTemplate+
									'<tbody></tbody>'+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-months">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-years">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
						'</div>';

	$.fn.datepicker.DPGlobal = DPGlobal;


	/* DATEPICKER NO CONFLICT
	* =================== */

	$.fn.datepicker.noConflict = function(){
		$.fn.datepicker = old;
		return this;
	};


	/* DATEPICKER DATA-API
	* ================== */

	$(document).on(
		'focus.datepicker.data-api click.datepicker.data-api',
		'[data-provide="datepicker"]',
		function(e){
			var $this = $(this);
			if ($this.data('datepicker')) return;
			e.preventDefault();
			// component click requires us to explicitly show it
			$this.datepicker('show');
		}
	);
	$(function(){
		$('[data-provide="datepicker-inline"]').datepicker();
	});

}( window.jQuery ));

define("enketo-widget/date/bootstrap3-datepicker/js/bootstrap-datepicker", function(){});

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/date/datepicker-extended',[ 'enketo-js/Widget', 'Modernizr', 'jquery', 'enketo-widget/date/bootstrap3-datepicker/js/bootstrap-datepicker' ],
    function( Widget, Modernizr, $ ) {
        

        //It is very helpful to make this the same as widget class, except for converting the first character to lowercase.
        var pluginName = 'datepickerExtended';

        /**
         * Extends eternicode's bootstrap-datepicker without changing the original.
         * https://github.com/eternicode/bootstrap-datepicker
         *
         * @constructor
         * @param {Element}                       element   Element to apply widget to.
         * @param {(boolean|{touch: boolean})}    options   options
         * @param {*=}                            event     event
         */

        function DatepickerExtended( element, options, event ) {
            this.namespace = pluginName;
            //call the Super constructor
            Widget.call( this, element, options );
            this._init();
        }

        //copy the prototype functions from the Widget super class
        DatepickerExtended.prototype = Object.create( Widget.prototype );

        //ensure the constructor is the new one
        DatepickerExtended.prototype.constructor = DatepickerExtended;

        /**
         * Initialize timepicker widget
         */
        DatepickerExtended.prototype._init = function() {
            var that = this,
                $p = $( this.element ).parent( 'label' ),
                settings = ( $p.hasClass( 'or-appearance-year' ) ) ? {
                    format: 'yyyy',
                    startView: 'decade',
                    minViewMode: 'years'
                } : ( $p.hasClass( 'or-appearance-month-year' ) ) ? {
                    format: 'yyyy-mm',
                    startView: 'year',
                    minViewMode: 'months'
                } : {
                    format: 'yyyy-mm-dd',
                    startView: 'month',
                    minViewMode: 'day'
                },
                $fakeDateI = this._createFakeDateInput( settings.format );

            this._setManualHandler( $fakeDateI );
            this._setFocusHandler( $fakeDateI );
            this._setResetHandler( $fakeDateI );

            console.log( 'setting picker with settings:', settings );

            $fakeDateI.datepicker( {
                format: settings.format,
                autoclose: true,
                todayHighlight: true,
                startView: settings.startView,
                minViewMode: settings.minViewMode,
                orientation: 'top'
            } ).on( 'changeDate', function( e ) {
                // copy changes made by datepicker to original input field
                var value = $( this ).val();
                console.log( 'unchanged value', value );
                if ( settings.startView === 'decade' && value.length === 4 ) {
                    value += '-01-01';
                } else if ( settings.startView === 'year' && value.length < 8 ) {
                    value += '-01';
                }
                console.log( 'datepicker date changed to', value );
                $( that.element ).val( value ).trigger( 'change' ).blur();
            } );
        };

        /**
         * Creates fake date input elements
         * @param  {string} format the date format
         * @return {jQuery}        the jQuery-wrapped fake date input element
         */
        DatepickerExtended.prototype._createFakeDateInput = function( format ) {
            var $dateI = $( this.element ),
                $fakeDate = $(
                    '<div class="widget date"><input class="ignore input-small" readonly="readonly" type="text" value="' +
                    $dateI.val() + '" placeholder="' + format + '" />' +
                    '<button class="btn-reset"><i class="glyphicon glyphicon-refresh"> </i></button></div>' ),
                //$fakeDateReset = $fakeDate.find( '.btn-reset' ),
                $fakeDateI = $fakeDate.find( 'input' );

            //$dateI.next( '.widget.date' ).remove( );
            $dateI.hide().after( $fakeDate );

            return $fakeDateI;
        };

        /**
         * copy manual changes to original date input field
         *
         * @param { jQuery } $fakeDateI Fake date input element
         */
        DatepickerExtended.prototype._setManualHandler = function( $fakeDateI ) {
            //$fakeDateI.on( 'change', function( ) {
            //  var date,
            //    value = $dateI.val( );
            //  if ( value.length > 0 ) {
            //    value = ( format === 'yyyy-mm' ) ? value + '-01' : ( format === 'yyyy' ) ? value + '-01-01' : value;
            //    value = data.node( ).convert( value, 'date' );
            //  }
            //  if ( $dateI.val( ) !== value ) {
            //    $dateI.val( value ).trigger( 'change' ).blur( );
            //  }
            //  return false;
            //} );
        };

        /**
         * Reset button handler
         *
         * @param { jQuery } $fakeDateI Fake date input element
         */
        DatepickerExtended.prototype._setResetHandler = function( $fakeDateI ) {
            $fakeDateI.next( '.btn-reset' ).on( 'click', function( event ) {
                $fakeDateI.val( '' ).trigger( 'changeDate' ).datepicker( 'update' );
            } );
        };

        /**
         * Handler for focus and blur events.
         * These events on the original input are used to check whether to display the 'required' message
         *
         * @param { jQuery } $fakeDateI Fake date input element
         */
        DatepickerExtended.prototype._setFocusHandler = function( $fakeDateI ) {
            var that = this;
            $fakeDateI.on( 'focus blur', function( event ) {
                $( that.element ).trigger( 'fake' + event.type );
            } );
        };

        $.fn[ pluginName ] = function( options, event ) {

            options = options || {};

            return this.each( function() {
                var $this = $( this ),
                    data = $this.data( pluginName ),
                    badSamsung = /GT-P31[0-9]{2}.+AppleWebKit\/534\.30/;

                /*
                 * Samsung mobile browser (called "Internet") has a weird bug that appears sometimes (?) when an input field
                 * already has a value and is edited. The new value YYYY-MM-DD prepends old or replaces the year of the old value and first hyphen. E.g.
                 * existing: 2010-01-01, new value entered: 2012-12-12 => input field shows: 2012-12-1201-01.
                 * This doesn't seem to effect the actual value of the input, just the way it is displayed. But if the incorrectly displayed date is then
                 * attempted to be edited again, it does get the incorrect value and it's impossible to clear this and create a valid date.
                 *
                 * browser: "Mozilla/5.0 (Linux; U; Android 4.1.1; en-us; GT-P3113 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30";
                 * webview: "Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; GT-P3100 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30"
                 */

                if ( !data && typeof options === 'object' && ( !options.touch || !Modernizr.inputtypes.date || badSamsung.test( navigator.userAgent ) ) ) {
                    $this.data( pluginName, ( data = new DatepickerExtended( this, options, event ) ) );
                }
                //only call method if widget was instantiated before
                else if ( data && typeof options == 'string' ) {
                    //pass the element as a parameter as this is used in fix()
                    data[ options ]( this );
                }
            } );
        };

    } );

/*!
 * Timepicker Component for Twitter Bootstrap
 *
 * Copyright 2013 Joris de Wit
 *
 * Contributors https://github.com/jdewit/bootstrap-timepicker/graphs/contributors
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
(function($, window, document, undefined) {
  

  // TIMEPICKER PUBLIC CLASS DEFINITION
  var Timepicker = function(element, options) {
    this.widget = '';
    this.$element = $(element);
    this.defaultTime = options.defaultTime;
    this.disableFocus = options.disableFocus;
    this.disableMousewheel = options.disableMousewheel;
    this.isOpen = options.isOpen;
    this.minuteStep = options.minuteStep;
    this.modalBackdrop = options.modalBackdrop;
    this.orientation = options.orientation;
    this.secondStep = options.secondStep;
    this.showInputs = options.showInputs;
    this.showMeridian = options.showMeridian;
    this.showSeconds = options.showSeconds;
    this.template = options.template;
    this.appendWidgetTo = options.appendWidgetTo;
    this.showWidgetOnAddonClick = options.showWidgetOnAddonClick;

    this._init();
  };

  Timepicker.prototype = {

    constructor: Timepicker,
    _init: function() {
      var self = this;

      if (this.showWidgetOnAddonClick && (this.$element.parent().hasClass('input-append') || this.$element.parent().hasClass('input-prepend'))) {
        this.$element.parent('.input-append, .input-prepend').find('.add-on').on({
          'click.timepicker': $.proxy(this.showWidget, this)
        });
        this.$element.on({
          'focus.timepicker': $.proxy(this.highlightUnit, this),
          'click.timepicker': $.proxy(this.highlightUnit, this),
          'keydown.timepicker': $.proxy(this.elementKeydown, this),
          'blur.timepicker': $.proxy(this.blurElement, this),
          'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
        });
      } else {
        if (this.template) {
          this.$element.on({
            'focus.timepicker': $.proxy(this.showWidget, this),
            'click.timepicker': $.proxy(this.showWidget, this),
            'blur.timepicker': $.proxy(this.blurElement, this),
            'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
          });
        } else {
          this.$element.on({
            'focus.timepicker': $.proxy(this.highlightUnit, this),
            'click.timepicker': $.proxy(this.highlightUnit, this),
            'keydown.timepicker': $.proxy(this.elementKeydown, this),
            'blur.timepicker': $.proxy(this.blurElement, this),
            'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
          });
        }
      }

      if (this.template !== false) {
        this.$widget = $(this.getTemplate()).on('click', $.proxy(this.widgetClick, this));
      } else {
        this.$widget = false;
      }

      if (this.showInputs && this.$widget !== false) {
        this.$widget.find('input').each(function() {
          $(this).on({
            'click.timepicker': function() { $(this).select(); },
            'keydown.timepicker': $.proxy(self.widgetKeydown, self),
            'keyup.timepicker': $.proxy(self.widgetKeyup, self)
          });
        });
      }

      this.setDefaultTime(this.defaultTime);
    },

    blurElement: function() {
      this.highlightedUnit = null;
      this.updateFromElementVal();
    },

    clear: function() {
      this.hour = '';
      this.minute = '';
      this.second = '';
      this.meridian = '';

      this.$element.val('');
    },

    decrementHour: function() {
      if (this.showMeridian) {
        if (this.hour === 1) {
          this.hour = 12;
        } else if (this.hour === 12) {
          this.hour--;

          return this.toggleMeridian();
        } else if (this.hour === 0) {
          this.hour = 11;

          return this.toggleMeridian();
        } else {
          this.hour--;
        }
      } else {
        if (this.hour <= 0) {
          this.hour = 23;
        } else {
          this.hour--;
        }
      }
    },

    decrementMinute: function(step) {
      var newVal;

      if (step) {
        newVal = this.minute - step;
      } else {
        newVal = this.minute - this.minuteStep;
      }

      if (newVal < 0) {
        this.decrementHour();
        this.minute = newVal + 60;
      } else {
        this.minute = newVal;
      }
    },

    decrementSecond: function() {
      var newVal = this.second - this.secondStep;

      if (newVal < 0) {
        this.decrementMinute(true);
        this.second = newVal + 60;
      } else {
        this.second = newVal;
      }
    },

    elementKeydown: function(e) {
      switch (e.keyCode) {
      case 9: //tab
      case 27: // escape
        this.updateFromElementVal();
        break;
      case 37: // left arrow
        e.preventDefault();
        this.highlightPrevUnit();
        break;
      case 38: // up arrow
        e.preventDefault();
        switch (this.highlightedUnit) {
        case 'hour':
          this.incrementHour();
          this.highlightHour();
          break;
        case 'minute':
          this.incrementMinute();
          this.highlightMinute();
          break;
        case 'second':
          this.incrementSecond();
          this.highlightSecond();
          break;
        case 'meridian':
          this.toggleMeridian();
          this.highlightMeridian();
          break;
        }
        this.update();
        break;
      case 39: // right arrow
        e.preventDefault();
        this.highlightNextUnit();
        break;
      case 40: // down arrow
        e.preventDefault();
        switch (this.highlightedUnit) {
        case 'hour':
          this.decrementHour();
          this.highlightHour();
          break;
        case 'minute':
          this.decrementMinute();
          this.highlightMinute();
          break;
        case 'second':
          this.decrementSecond();
          this.highlightSecond();
          break;
        case 'meridian':
          this.toggleMeridian();
          this.highlightMeridian();
          break;
        }

        this.update();
        break;
      }
    },

    getCursorPosition: function() {
      var input = this.$element.get(0);

      if ('selectionStart' in input) {// Standard-compliant browsers

        return input.selectionStart;
      } else if (document.selection) {// IE fix
        input.focus();
        var sel = document.selection.createRange(),
          selLen = document.selection.createRange().text.length;

        sel.moveStart('character', - input.value.length);

        return sel.text.length - selLen;
      }
    },

    getTemplate: function() {
      var template,
        hourTemplate,
        minuteTemplate,
        secondTemplate,
        meridianTemplate,
        templateContent;

      if (this.showInputs) {
        hourTemplate = '<input type="text" class="bootstrap-timepicker-hour form-control" maxlength="2"/>';
        minuteTemplate = '<input type="text" class="bootstrap-timepicker-minute form-control" maxlength="2"/>';
        secondTemplate = '<input type="text" class="bootstrap-timepicker-second form-control" maxlength="2"/>';
        meridianTemplate = '<input type="text" class="bootstrap-timepicker-meridian form-control" maxlength="2"/>';
      } else {
        hourTemplate = '<span class="bootstrap-timepicker-hour"></span>';
        minuteTemplate = '<span class="bootstrap-timepicker-minute"></span>';
        secondTemplate = '<span class="bootstrap-timepicker-second"></span>';
        meridianTemplate = '<span class="bootstrap-timepicker-meridian"></span>';
      }

      templateContent = '<table>'+
         '<tr>'+
           '<td><a href="#" data-action="incrementHour"><i class="glyphicon glyphicon-chevron-up"></i></a></td>'+
           '<td class="separator">&nbsp;</td>'+
           '<td><a href="#" data-action="incrementMinute"><i class="glyphicon glyphicon-chevron-up"></i></a></td>'+
           (this.showSeconds ?
             '<td class="separator">&nbsp;</td>'+
             '<td><a href="#" data-action="incrementSecond"><i class="glyphicon glyphicon-chevron-up"></i></a></td>'
           : '') +
           (this.showMeridian ?
             '<td class="separator">&nbsp;</td>'+
             '<td class="meridian-column"><a href="#" data-action="toggleMeridian"><i class="glyphicon glyphicon-chevron-up"></i></a></td>'
           : '') +
         '</tr>'+
         '<tr>'+
           '<td>'+ hourTemplate +'</td> '+
           '<td class="separator">:</td>'+
           '<td>'+ minuteTemplate +'</td> '+
           (this.showSeconds ?
            '<td class="separator">:</td>'+
            '<td>'+ secondTemplate +'</td>'
           : '') +
           (this.showMeridian ?
            '<td class="separator">&nbsp;</td>'+
            '<td>'+ meridianTemplate +'</td>'
           : '') +
         '</tr>'+
         '<tr>'+
           '<td><a href="#" data-action="decrementHour"><i class="glyphicon glyphicon-chevron-down"></i></a></td>'+
           '<td class="separator"></td>'+
           '<td><a href="#" data-action="decrementMinute"><i class="glyphicon glyphicon-chevron-down"></i></a></td>'+
           (this.showSeconds ?
            '<td class="separator">&nbsp;</td>'+
            '<td><a href="#" data-action="decrementSecond"><i class="glyphicon glyphicon-chevron-down"></i></a></td>'
           : '') +
           (this.showMeridian ?
            '<td class="separator">&nbsp;</td>'+
            '<td><a href="#" data-action="toggleMeridian"><i class="glyphicon glyphicon-chevron-down"></i></a></td>'
           : '') +
         '</tr>'+
       '</table>';

      switch(this.template) {
      case 'modal':
        template = '<div class="bootstrap-timepicker-widget modal hide fade in" data-backdrop="'+ (this.modalBackdrop ? 'true' : 'false') +'">'+
          '<div class="modal-header">'+
            '<a href="#" class="close" data-dismiss="modal">×</a>'+
            '<h3>Pick a Time</h3>'+
          '</div>'+
          '<div class="modal-content">'+
            templateContent +
          '</div>'+
          '<div class="modal-footer">'+
            '<a href="#" class="btn btn-primary" data-dismiss="modal">OK</a>'+
          '</div>'+
        '</div>';
        break;
      case 'dropdown':
        template = '<div class="bootstrap-timepicker-widget dropdown-menu">'+ templateContent +'</div>';
        break;
      }

      return template;
    },

    getTime: function() {
      if (this.hour === '') {
        return '';
      }

      return this.hour + ':' + (this.minute.toString().length === 1 ? '0' + this.minute : this.minute) + (this.showSeconds ? ':' + (this.second.toString().length === 1 ? '0' + this.second : this.second) : '') + (this.showMeridian ? ' ' + this.meridian : '');
    },

    hideWidget: function() {
      if (this.isOpen === false) {
        return;
      }

      this.$element.trigger({
        'type': 'hide.timepicker',
        'time': {
          'value': this.getTime(),
          'hours': this.hour,
          'minutes': this.minute,
          'seconds': this.second,
          'meridian': this.meridian
        }
      });

      if (this.template === 'modal' && this.$widget.modal) {
        this.$widget.modal('hide');
      } else {
        this.$widget.removeClass('open');
      }

      $(document).off('mousedown.timepicker, touchend.timepicker');

      this.isOpen = false;
      // show/hide approach taken by datepicker
      this.$widget.detach();
    },

    highlightUnit: function() {
      this.position = this.getCursorPosition();
      if (this.position >= 0 && this.position <= 2) {
        this.highlightHour();
      } else if (this.position >= 3 && this.position <= 5) {
        this.highlightMinute();
      } else if (this.position >= 6 && this.position <= 8) {
        if (this.showSeconds) {
          this.highlightSecond();
        } else {
          this.highlightMeridian();
        }
      } else if (this.position >= 9 && this.position <= 11) {
        this.highlightMeridian();
      }
    },

    highlightNextUnit: function() {
      switch (this.highlightedUnit) {
      case 'hour':
        this.highlightMinute();
        break;
      case 'minute':
        if (this.showSeconds) {
          this.highlightSecond();
        } else if (this.showMeridian){
          this.highlightMeridian();
        } else {
          this.highlightHour();
        }
        break;
      case 'second':
        if (this.showMeridian) {
          this.highlightMeridian();
        } else {
          this.highlightHour();
        }
        break;
      case 'meridian':
        this.highlightHour();
        break;
      }
    },

    highlightPrevUnit: function() {
      switch (this.highlightedUnit) {
      case 'hour':
        if(this.showMeridian){
          this.highlightMeridian();
        } else if (this.showSeconds) {
          this.highlightSecond();
        } else {
          this.highlightMinute();
        }
        break;
      case 'minute':
        this.highlightHour();
        break;
      case 'second':
        this.highlightMinute();
        break;
      case 'meridian':
        if (this.showSeconds) {
          this.highlightSecond();
        } else {
          this.highlightMinute();
        }
        break;
      }
    },

    highlightHour: function() {
      var $element = this.$element.get(0),
          self = this;

      this.highlightedUnit = 'hour';

			if ($element.setSelectionRange) {
				setTimeout(function() {
          if (self.hour < 10) {
            $element.setSelectionRange(0,1);
          } else {
            $element.setSelectionRange(0,2);
          }
				}, 0);
			}
    },

    highlightMinute: function() {
      var $element = this.$element.get(0),
          self = this;

      this.highlightedUnit = 'minute';

			if ($element.setSelectionRange) {
				setTimeout(function() {
          if (self.hour < 10) {
            $element.setSelectionRange(2,4);
          } else {
            $element.setSelectionRange(3,5);
          }
				}, 0);
			}
    },

    highlightSecond: function() {
      var $element = this.$element.get(0),
          self = this;

      this.highlightedUnit = 'second';

			if ($element.setSelectionRange) {
				setTimeout(function() {
          if (self.hour < 10) {
            $element.setSelectionRange(5,7);
          } else {
            $element.setSelectionRange(6,8);
          }
				}, 0);
			}
    },

    highlightMeridian: function() {
      var $element = this.$element.get(0),
          self = this;

      this.highlightedUnit = 'meridian';

			if ($element.setSelectionRange) {
				if (this.showSeconds) {
					setTimeout(function() {
            if (self.hour < 10) {
              $element.setSelectionRange(8,10);
            } else {
              $element.setSelectionRange(9,11);
            }
					}, 0);
				} else {
					setTimeout(function() {
            if (self.hour < 10) {
              $element.setSelectionRange(5,7);
            } else {
              $element.setSelectionRange(6,8);
            }
					}, 0);
				}
			}
    },

    incrementHour: function() {
      if (this.showMeridian) {
        if (this.hour === 11) {
          this.hour++;
          return this.toggleMeridian();
        } else if (this.hour === 12) {
          this.hour = 0;
        }
      }
      if (this.hour === 23) {
        this.hour = 0;

        return;
      }
      this.hour++;
    },

    incrementMinute: function(step) {
      var newVal;

      if (step) {
        newVal = this.minute + step;
      } else {
        newVal = this.minute + this.minuteStep - (this.minute % this.minuteStep);
      }

      if (newVal > 59) {
        this.incrementHour();
        this.minute = newVal - 60;
      } else {
        this.minute = newVal;
      }
    },

    incrementSecond: function() {
      var newVal = this.second + this.secondStep - (this.second % this.secondStep);

      if (newVal > 59) {
        this.incrementMinute(true);
        this.second = newVal - 60;
      } else {
        this.second = newVal;
      }
    },

    mousewheel: function(e) {
      if (this.disableMousewheel) {
        return;
      }

      e.preventDefault();
      e.stopPropagation();

      var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail,
          scrollTo = null;

      if (e.type === 'mousewheel') {
        scrollTo = (e.originalEvent.wheelDelta * -1);
      }
      else if (e.type === 'DOMMouseScroll') {
        scrollTo = 40 * e.originalEvent.detail;
      }

      if (scrollTo) {
        e.preventDefault();
        $(this).scrollTop(scrollTo + $(this).scrollTop());
      }

      switch (this.highlightedUnit) {
      case 'minute':
        if (delta > 0) {
          this.incrementMinute();
        } else {
          this.decrementMinute();
        }
        this.highlightMinute();
        break;
      case 'second':
        if (delta > 0) {
          this.incrementSecond();
        } else {
          this.decrementSecond();
        }
        this.highlightSecond();
        break;
      case 'meridian':
        this.toggleMeridian();
        this.highlightMeridian();
        break;
      default:
        if (delta > 0) {
          this.incrementHour();
        } else {
          this.decrementHour();
        }
        this.highlightHour();
        break;
      }

      return false;
    },

    // This method was adapted from bootstrap-datepicker.
    place : function() {
      if (this.isInline) {
        return;
      }
      var widgetWidth = this.$widget.outerWidth(), widgetHeight = this.$widget.outerHeight(), visualPadding = 10, windowWidth =
        $(window).width(), windowHeight = $(window).height(), scrollTop = $(window).scrollTop();

      var zIndex = parseInt(this.$element.parents().filter(function() {}).first().css('z-index'), 10) + 10;
      var offset = this.component ? this.component.parent().offset() : this.$element.offset();
      var height = this.component ? this.component.outerHeight(true) : this.$element.outerHeight(false);
      var width = this.component ? this.component.outerWidth(true) : this.$element.outerWidth(false);
      var left = offset.left, top = offset.top;

      this.$widget.removeClass('timepicker-orient-top timepicker-orient-bottom timepicker-orient-right timepicker-orient-left');

      if (this.orientation.x !== 'auto') {
        this.picker.addClass('datepicker-orient-' + this.orientation.x);
        if (this.orientation.x === 'right') {
          left -= widgetWidth - width;
        }
      } else{
        // auto x orientation is best-placement: if it crosses a window edge, fudge it sideways
        // Default to left
        this.$widget.addClass('timepicker-orient-left');
        if (offset.left < 0) {
          left -= offset.left - visualPadding;
        } else if (offset.left + widgetWidth > windowWidth) {
          left = windowWidth - widgetWidth - visualPadding;
        }
      }
      // auto y orientation is best-situation: top or bottom, no fudging, decision based on which shows more of the widget
      var yorient = this.orientation.y, topOverflow, bottomOverflow;
      if (yorient === 'auto') {
        topOverflow = -scrollTop + offset.top - widgetHeight;
        bottomOverflow = scrollTop + windowHeight - (offset.top + height + widgetHeight);
        if (Math.max(topOverflow, bottomOverflow) === bottomOverflow) {
          yorient = 'top';
        } else {
          yorient = 'bottom';
        }
      }
      this.$widget.addClass('timepicker-orient-' + yorient);
      if (yorient === 'top'){
        top += height;
      } else{
        top -= widgetHeight + parseInt(this.$widget.css('padding-top'), 10);
      }

      this.$widget.css({
        top : top,
        left : left,
        zIndex : zIndex
      });
    },

    remove: function() {
      $('document').off('.timepicker');
      if (this.$widget) {
        this.$widget.remove();
      }
      delete this.$element.data().timepicker;
    },

    setDefaultTime: function(defaultTime) {
      if (!this.$element.val()) {
        if (defaultTime === 'current') {
          var dTime = new Date(),
            hours = dTime.getHours(),
            minutes = dTime.getMinutes(),
            seconds = dTime.getSeconds(),
            meridian = 'AM';

          if (seconds !== 0) {
            seconds = Math.ceil(dTime.getSeconds() / this.secondStep) * this.secondStep;
            if (seconds === 60) {
              minutes += 1;
              seconds = 0;
            }
          }

          if (minutes !== 0) {
            minutes = Math.ceil(dTime.getMinutes() / this.minuteStep) * this.minuteStep;
            if (minutes === 60) {
              hours += 1;
              minutes = 0;
            }
          }

          if (this.showMeridian) {
            if (hours === 0) {
              hours = 12;
            } else if (hours >= 12) {
              if (hours > 12) {
                hours = hours - 12;
              }
              meridian = 'PM';
            } else {
              meridian = 'AM';
            }
          }

          this.hour = hours;
          this.minute = minutes;
          this.second = seconds;
          this.meridian = meridian;

          this.update();

        } else if (defaultTime === false) {
          this.hour = 0;
          this.minute = 0;
          this.second = 0;
          this.meridian = 'AM';
        } else {
          this.setTime(defaultTime);
        }
      } else {
        this.updateFromElementVal();
      }
    },

    setTime: function(time, ignoreWidget) {
      if (!time) {
        this.clear();
        return;
      }

      var timeArray,
          hour,
          minute,
          second,
          meridian;

      if (typeof time === 'object' && time.getMonth){
        // this is a date object
        hour    = time.getHours();
        minute  = time.getMinutes();
        second  = time.getSeconds();

        if (this.showMeridian){
          meridian = 'AM';
          if (hour > 12){
            meridian = 'PM';
            hour = hour % 12;
          }

          if (hour === 12){
            meridian = 'PM';
          }
        }
      } else {
        if (time.match(/p/i) !== null) {
          meridian = 'PM';
        } else {
          meridian = 'AM';
        }

        time = time.replace(/[^0-9\:]/g, '');

        timeArray = time.split(':');

        hour = timeArray[0] ? timeArray[0].toString() : timeArray.toString();
        minute = timeArray[1] ? timeArray[1].toString() : '';
        second = timeArray[2] ? timeArray[2].toString() : '';

        // idiot proofing
        if (hour.length > 4) {
          second = hour.substr(4, 2);
        }
        if (hour.length > 2) {
          minute = hour.substr(2, 2);
          hour = hour.substr(0, 2);
        }
        if (minute.length > 2) {
          second = minute.substr(2, 2);
          minute = minute.substr(0, 2);
        }
        if (second.length > 2) {
          second = second.substr(2, 2);
        }

        hour = parseInt(hour, 10);
        minute = parseInt(minute, 10);
        second = parseInt(second, 10);

        if (isNaN(hour)) {
          hour = 0;
        }
        if (isNaN(minute)) {
          minute = 0;
        }
        if (isNaN(second)) {
          second = 0;
        }

        if (this.showMeridian) {
          if (hour < 1) {
            hour = 1;
          } else if (hour > 12) {
            hour = 12;
          }
        } else {
          if (hour >= 24) {
            hour = 23;
          } else if (hour < 0) {
            hour = 0;
          }
          if (hour < 13 && meridian === 'PM') {
            hour = hour + 12;
          }
        }

        if (minute < 0) {
          minute = 0;
        } else if (minute >= 60) {
          minute = 59;
        }

        if (this.showSeconds) {
          if (isNaN(second)) {
            second = 0;
          } else if (second < 0) {
            second = 0;
          } else if (second >= 60) {
            second = 59;
          }
        }
      }

      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.meridian = meridian;

      this.update(ignoreWidget);
    },

    showWidget: function() {
      if (this.isOpen) {
        return;
      }

      if (this.$element.is(':disabled')) {
        return;
      }

      // show/hide approach taken by datepicker
      this.$widget.appendTo(this.appendWidgetTo);
      var self = this;
      $(document).on('mousedown.timepicker, touchend.timepicker', function (e) {
        // This condition was inspired by bootstrap-datepicker.
        // The element the timepicker is invoked on is the input but it has a sibling for addon/button.
        if (!(self.$element.parent().find(e.target).length ||
            self.$widget.is(e.target) ||
            self.$widget.find(e.target).length)) {
          self.hideWidget();
        }
      });

      this.$element.trigger({
        'type': 'show.timepicker',
        'time': {
          'value': this.getTime(),
          'hours': this.hour,
          'minutes': this.minute,
          'seconds': this.second,
          'meridian': this.meridian
        }
      });

      this.place();
      if (this.disableFocus) {
        this.$element.blur();
      }

      // widget shouldn't be empty on open
      if (this.hour === '') {
        if (this.defaultTime) {
          this.setDefaultTime(this.defaultTime);
        } else {
          this.setTime('0:0:0');
        }
      }

      if (this.template === 'modal' && this.$widget.modal) {
        this.$widget.modal('show').on('hidden', $.proxy(this.hideWidget, this));
      } else {
        if (this.isOpen === false) {
          this.$widget.addClass('open');
        }
      }

      this.isOpen = true;
    },

    toggleMeridian: function() {
      this.meridian = this.meridian === 'AM' ? 'PM' : 'AM';
    },

    update: function(ignoreWidget) {
      this.updateElement();
      if (!ignoreWidget) {
        this.updateWidget();
      }

      this.$element.trigger({
        'type': 'changeTime.timepicker',
        'time': {
          'value': this.getTime(),
          'hours': this.hour,
          'minutes': this.minute,
          'seconds': this.second,
          'meridian': this.meridian
        }
      });
    },

    updateElement: function() {
      this.$element.val(this.getTime()).change();
    },

    updateFromElementVal: function() {
      this.setTime(this.$element.val());
    },

    updateWidget: function() {
      if (this.$widget === false) {
        return;
      }

      var hour = this.hour,
          minute = this.minute.toString().length === 1 ? '0' + this.minute : this.minute,
          second = this.second.toString().length === 1 ? '0' + this.second : this.second;

      if (this.showInputs) {
        this.$widget.find('input.bootstrap-timepicker-hour').val(hour);
        this.$widget.find('input.bootstrap-timepicker-minute').val(minute);

        if (this.showSeconds) {
          this.$widget.find('input.bootstrap-timepicker-second').val(second);
        }
        if (this.showMeridian) {
          this.$widget.find('input.bootstrap-timepicker-meridian').val(this.meridian);
        }
      } else {
        this.$widget.find('span.bootstrap-timepicker-hour').text(hour);
        this.$widget.find('span.bootstrap-timepicker-minute').text(minute);

        if (this.showSeconds) {
          this.$widget.find('span.bootstrap-timepicker-second').text(second);
        }
        if (this.showMeridian) {
          this.$widget.find('span.bootstrap-timepicker-meridian').text(this.meridian);
        }
      }
    },

    updateFromWidgetInputs: function() {
      if (this.$widget === false) {
        return;
      }

      var t = this.$widget.find('input.bootstrap-timepicker-hour').val() + ':' +
              this.$widget.find('input.bootstrap-timepicker-minute').val() +
              (this.showSeconds ? ':' + this.$widget.find('input.bootstrap-timepicker-second').val() : '') +
              (this.showMeridian ? this.$widget.find('input.bootstrap-timepicker-meridian').val() : '')
      ;

      this.setTime(t, true);
    },

    widgetClick: function(e) {
      e.stopPropagation();
      e.preventDefault();

      var $input = $(e.target),
          action = $input.closest('a').data('action');

      if (action) {
        this[action]();
      }
      this.update();

      if ($input.is('input')) {
        $input.get(0).setSelectionRange(0,2);
      }
    },

    widgetKeydown: function(e) {
      var $input = $(e.target),
          name = $input.attr('class').replace('bootstrap-timepicker-', '');

      switch (e.keyCode) {
      case 9: //tab
        if ((this.showMeridian && name === 'meridian') || (this.showSeconds && name === 'second') || (!this.showMeridian && !this.showSeconds && name === 'minute')) {
          return this.hideWidget();
        }
        break;
      case 27: // escape
        this.hideWidget();
        break;
      case 38: // up arrow
        e.preventDefault();
        switch (name) {
        case 'hour':
          this.incrementHour();
          break;
        case 'minute':
          this.incrementMinute();
          break;
        case 'second':
          this.incrementSecond();
          break;
        case 'meridian':
          this.toggleMeridian();
          break;
        }
        this.setTime(this.getTime());
        $input.get(0).setSelectionRange(0,2);
        break;
      case 40: // down arrow
        e.preventDefault();
        switch (name) {
        case 'hour':
          this.decrementHour();
          break;
        case 'minute':
          this.decrementMinute();
          break;
        case 'second':
          this.decrementSecond();
          break;
        case 'meridian':
          this.toggleMeridian();
          break;
        }
        this.setTime(this.getTime());
        $input.get(0).setSelectionRange(0,2);
        break;
      }
    },

    widgetKeyup: function(e) {
      if ((e.keyCode === 65) || (e.keyCode === 77) || (e.keyCode === 80) || (e.keyCode === 46) || (e.keyCode === 8) || (e.keyCode >= 46 && e.keyCode <= 57)) {
        this.updateFromWidgetInputs();
      }
    }
  };

  //TIMEPICKER PLUGIN DEFINITION
  $.fn.timepicker = function(option) {
    var args = Array.apply(null, arguments);
    args.shift();
    return this.each(function() {
      var $this = $(this),
        data = $this.data('timepicker'),
        options = typeof option === 'object' && option;

      if (!data) {
        $this.data('timepicker', (data = new Timepicker(this, $.extend({}, $.fn.timepicker.defaults, options, $(this).data()))));
      }

      if (typeof option === 'string') {
        data[option].apply(data, args);
      }
    });
  };

  $.fn.timepicker.defaults = {
    defaultTime: 'current',
    disableFocus: false,
    disableMousewheel: false,
    isOpen: false,
    minuteStep: 15,
    modalBackdrop: false,
    orientation: { x: 'auto', y: 'auto'},
    secondStep: 15,
    showSeconds: false,
    showInputs: true,
    showMeridian: true,
    template: 'dropdown',
    appendWidgetTo: 'body',
    showWidgetOnAddonClick: true
  };

  $.fn.timepicker.Constructor = Timepicker;

})(jQuery, window, document);

define("enketo-widget/time/bootstrap3-timepicker/js/bootstrap-timepicker", function(){});

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/time/timepicker-extended',[ 'enketo-js/Widget', 'Modernizr', 'jquery', 'enketo-widget/time/bootstrap3-timepicker/js/bootstrap-timepicker' ],
    function( Widget, Modernizr, $ ) {
        

        var pluginName = 'timepickerExtended';

        /**
         * Extends jdewit's bootstrap-timepicker without changing the original
         * https://github.com/jdewit/bootstrap-timepicker
         * TODO: I'd like to find a replacement for jdewit's widget during the move to bootstrap 3.
         *
         * @constructor
         * @param {Element}                       element   Element to apply widget to.
         * @param {(boolean|{touch: boolean})}    options   options
         * @param {*=}                            event     event
         */

        function TimepickerExtended( element, options, event ) {
            this.namespace = pluginName;
            //call the Super constructor
            Widget.call( this, element, options );
            this._init();
        }

        //copy the prototype functions from the Widget super class
        TimepickerExtended.prototype = Object.create( Widget.prototype );

        //ensure the constructor is the new one
        TimepickerExtended.prototype.constructor = TimepickerExtended;

        /**
         * Initialize timepicker widget
         */
        TimepickerExtended.prototype._init = function() {
            var $timeI = $( this.element ),
                $p = $( this ).parent( 'label' ),
                timeVal = $( this.element ).val(),
                $fakeTime = $( '<div class="widget bootstrap-timepicker">' +
                    '<input class="ignore timepicker-default input-small" readonly="readonly" type="text" value="' + timeVal + '" placeholder="hh:mm" />' +
                    '<button class="btn-reset"><i class="glyphicon glyphicon-refresh"> </i></button></div>' ),
                $fakeTimeReset = $fakeTime.find( '.btn-reset' ),
                $fakeTimeI = $fakeTime.find( 'input' );

            $timeI.next( '.widget.bootstrap-timepicker-component' ).remove();
            $timeI.hide().after( $fakeTime );

            $fakeTimeI.timepicker( {
                defaultTime: ( timeVal.length > 0 ) ? timeVal : 'current',
                showMeridian: false
            } ).val( timeVal )
            //the time picker itself has input elements
            .closest( '.widget' ).find( 'input' ).addClass( 'ignore' );

            $fakeTimeI.on( 'change', function() {
                var $this = $( this ),
                    // the following line can be removed if https://github.com/jdewit/bootstrap-timepicker/issues/202 gets approved
                    val = ( /^[0-9]:/.test( $this.val() ) ) ? '0' + $this.val() : $this.val();
                // add 00 minutes if they are missing (probably a bug in bootstrap timepicker)
                val = ( /^[0-9]{2}:$/.test( val ) ) ? val + '00' : val;
                console.debug( 'time val to be entered: ', val );
                $timeI.val( val ).trigger( 'change' ).blur();
                return false;
            } );

            //reset button
            $fakeTimeReset.on( 'click', function( event ) {
                $fakeTimeI.val( '' ).trigger( 'change' );
            } );

            $fakeTimeI.on( 'focus blur', function( event ) {
                $timeI.trigger( 'fake' + event.type );
            } );
        };

        $.fn[ pluginName ] = function( options, event ) {

            options = options || {};

            return this.each( function() {
                var $this = $( this ),
                    data = $this.data( pluginName );

                if ( !data && typeof options === 'object' && ( !options.touch || !Modernizr.inputtypes.time ) ) {
                    $this.data( pluginName, ( data = new TimepickerExtended( this, options, event ) ) );
                }
                //only call method if widget was instantiated before
                else if ( data && typeof options == 'string' ) {
                    //pass the element as a parameter as this is used in fix()
                    data[ options ]( this );
                }
            } );
        };

    } );

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/datetime/datetimepicker-extended',[ 'enketo-js/Widget', 'Modernizr', 'jquery', 'enketo-js/extend',
        'enketo-widget/date/bootstrap3-datepicker/js/bootstrap-datepicker',
        'enketo-widget/time/bootstrap3-timepicker/js/bootstrap-timepicker'
    ],
    function( Widget, Modernizr, $ ) {
        

        var pluginName = 'datetimepickerExtended';

        /**
         * This thing is hacked together with little love, because nobody used datetime inputs. Needs to be rewritten.
         *
         * Extends eternicode's bootstrap-datepicker without changing the original.
         * https://github.com/eternicode/bootstrap-datepicker
         *
         * Extends jdewit's bootstrap-timepicker without changing the original
         * https://github.com/jdewit/bootstrap-timepicker
         *
         * @constructor
         * @param {Element}                       element   Element to apply widget to.
         * @param {(boolean|{touch: boolean})}    options   options
         * @param {*=}                            event     event
         */

        function DatetimepickerExtended( element, options, event ) {
            this.namespace = pluginName;
            //call the Super constructor
            Widget.call( this, element, options );
            this._init();
        }

        //copy the prototype functions from the Widget super class
        DatetimepickerExtended.prototype = Object.create( Widget.prototype );

        //ensure the constructor is the new one
        DatetimepickerExtended.prototype.constructor = DatetimepickerExtended;

        /**
         * Initialize timepicker widget
         */
        DatetimepickerExtended.prototype._init = function() {
            var $dateTimeI = $( this.element ),
                /*
          Loaded or default datetime values remain untouched until they are edited. This is done to preserve 
          the timezone information (especially for instances-to-edit) if the values are not edited (the
          original entry may have been done in a different time zone than the edit). However, 
          values shown in the widget should reflect the local time representation of that value.
         */
                val = ( $dateTimeI.val().length > 0 ) ? new Date( $dateTimeI.val() ).toISOLocalString() : '',
                vals = val.split( 'T' ),
                dateVal = vals[ 0 ],
                timeVal = ( vals[ 1 ] && vals[ 1 ].length > 4 ) ? vals[ 1 ].substring( 0, 5 ) : '',
                $fakeDateI = this._createFakeDateInput( dateVal ),
                $fakeTimeI = this._createFakeTimeInput( timeVal );

            $dateTimeI.hide().after( '<div class="datetimepicker widget" />' );
            $dateTimeI.siblings( '.datetimepicker' ).append( $fakeDateI.closest( '.date' ) ).append( $fakeTimeI.closest( '.bootstrap-timepicker' ) );

            $fakeDateI.datepicker( {
                format: 'yyyy-mm-dd',
                autoclose: true,
                todayHighlight: true
            } );

            $fakeTimeI
                .timepicker( {
                    defaultTime: ( timeVal.length > 0 ) ? 'value' : 'current',
                    showMeridian: false
                } )
                .val( timeVal )
            //the time picker itself has input elements
            .closest( '.widget' ).find( 'input' ).addClass( 'ignore' );

            this._setManualHandler( $fakeDateI );
            this._setFocusHandler( $fakeDateI.add( $fakeTimeI ) );

            $fakeDateI.on( 'change changeDate', function() {
                changeVal();
                return false;
            } );

            $fakeTimeI.on( 'change', function() {
                changeVal();
                return false;
            } );

            //reset button
            $fakeTimeI.next( '.btn-reset' ).on( 'click', function( event ) {
                $fakeDateI.val( '' ).trigger( 'change' ).datepicker( 'update' );
                $fakeTimeI.val( '' ).trigger( 'change' );
            } );

            function changeVal() {
                if ( $fakeDateI.val().length > 0 && $fakeTimeI.val().length > 0 ) {
                    var d = $fakeDateI.val().split( '-' ),
                        t = $fakeTimeI.val().split( ':' );
                    $dateTimeI.val( new Date( d[ 0 ], d[ 1 ] - 1, d[ 2 ], t[ 0 ], t[ 1 ] ).toISOLocalString() ).trigger( 'change' ).blur();
                } else {
                    $dateTimeI.val( '' ).trigger( 'change' ).blur();
                }
            }
        };

        /**
         * Creates fake date input elements
         * @param  {string} format the date format
         * @return {jQuery}        the jQuery-wrapped fake date input element
         */
        DatetimepickerExtended.prototype._createFakeDateInput = function( dateVal ) {
            var $datetimeI = $( this.element ),
                $fakeDate = $(
                    '<div class="date">' +
                    '<input class="ignore input-small" type="text" readonly="readonly" value="' + dateVal + '" placeholder="yyyy-mm-dd"/>' +
                    '</div>' ),
                $fakeDateI = $fakeDate.find( 'input' );

            return $fakeDateI;
        };

        /**
         * Creates fake time input elements
         * @param  {string} format the date format
         * @return {jQuery}        the jQuery-wrapped fake date input element
         */
        DatetimepickerExtended.prototype._createFakeTimeInput = function( timeVal ) {
            var $datetimeI = $( this.element ),
                $fakeTime = $(
                    '<div class="bootstrap-timepicker">' +
                    '<input class="ignore timepicker-default input-small" readonly="readonly" type="text" value="' +
                    timeVal + '" placeholder="hh:mm"/>' +
                    '<button class="btn-reset"><i class="glyphicon glyphicon-refresh"> </i></button>' +
                    '</div>' ),
                $fakeTimeI = $fakeTime.find( 'input' );

            return $fakeTimeI;
        };

        /**
         * copy manual changes to original date input field
         *
         * @param { jQuery } $fakeDateI Fake date input element
         */
        DatetimepickerExtended.prototype._setManualHandler = function( $fakeDateI ) {};

        /**
         * Handler for focus and blur events.
         * These events on the original input are used to check whether to display the 'required' message
         *
         * @param { jQuery } $fakeDateI Fake date input element
         */
        DatetimepickerExtended.prototype._setFocusHandler = function( $els ) {
            var that = this;
            $els.on( 'focus blur', function( event ) {
                $( that.element ).trigger( 'fake' + event.type );
            } );
        };

        $.fn[ pluginName ] = function( options, event ) {

            options = options || {};

            return this.each( function() {
                var $this = $( this ),
                    data = $this.data( pluginName ),
                    badSamsung = /GT-P31[0-9]{2}.+AppleWebKit\/534\.30/;

                /*
                Samsung mobile browser (called "Internet") has a weird bug that appears sometimes (?) when an input field
                already has a value and is edited. The new value YYYY-MM-DD prepends old or replaces the year of the old value and first hyphen. E.g.
                existing: 2010-01-01, new value entered: 2012-12-12 => input field shows: 2012-12-1201-01.
                This doesn't seem to effect the actual value of the input, just the way it is displayed. But if the incorrectly displayed date is then 
                attempted to be edited again, it does get the incorrect value and it's impossible to clear this and create a valid date.
              
                browser: "Mozilla/5.0 (Linux; U; Android 4.1.1; en-us; GT-P3113 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30";
                webview: "Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; GT-P3100 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30" 
                */
                if ( !data && typeof options === 'object' && ( !options.touch || !Modernizr.inputtypes.datetime || badSamsung.test( navigator.userAgent ) ) ) {
                    $this.data( pluginName, ( data = new DatetimepickerExtended( this, options, event ) ) );
                }
                //only call method if widget was instantiated before
                else if ( data && typeof options == 'string' ) {
                    //pass the element as a parameter as this is used in fix()
                    data[ options ]( this );
                }
            } );
        };

    } );

;

define("enketo-widget/mediagrid/mediagridpicker", function(){});

/**
 * This library copies liberally from http://www.html5rocks.com/en/tutorials/file/filesystem/#toc-filesystemurls
 * by Eric Bidelman. Thanks a lot, Eric!
 *
 * Copyright 2013 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * FileManager Class for PERSISTENT file storage, used to storage file inputs for later submission
 * Could be expanded, if ever needed, to use TEMPORARY file storage as well
 *
 * @constructor
 */

define( 'file-manager',[ 'jquery' ], function( $ ) {
    

    var getCurrentQuota, getCurrentQuotaUsed, supported, isSupported, fs, init, setDir, requestQuota,
        requestFileSystem, errorHandler, setCurrentQuotaUsed, _traverseAll, saveFile, retrieveFile,
        retrieveFileUrl, retrieveFileEntry, retrieveFileFromFileEntry, deleteFile, createDir, deleteDir, currentDir,
        deleteAll, _getDirPrefix, listAll, getFilesystem, filesystemReady,
        deferred = $.Deferred(),
        currentQuota = null,
        currentQuotaUsed = null,
        DEFAULTBYTESREQUESTED = 100 * 1024 * 1024;

    console.log( 'in file manager' );

    getCurrentQuota = function() {
        return currentQuota;
    };

    getCurrentQuotaUsed = function() {
        return currentQuotaUsed;
    };

    /**
     * Initializes the File Manager
     * @return {boolean} returns true/false if File API is supported by browser
     */
    init = function() {
        //check if filesystem API is supported by browser
        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        window.resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL;
        supported = ( typeof window.requestFileSystem !== 'undefined' && typeof window.resolveLocalFileSystemURL !== 'undefined' && typeof navigator.webkitPersistentStorage !== 'undefined' );
        console.log( 'supported: ', supported );
        if ( supported ) {
            setCurrentQuotaUsed();
            filesystemReady = getFilesystem();
            return true;
        } else {
            console.log( 'filesystem API not supported in this browser' );
            return false;
        }
    };

    /**
     * Returns jquery promise object that will be resolved when the user has approved the use of the filesystem
     * @return {*} jquery promise object
     */
    getFilesystem = function() {
        //var deferred = $.Deferred();

        if ( !fs ) {
            requestQuota(
                DEFAULTBYTESREQUESTED, {
                    success: function( grantedBytes ) {
                        requestFileSystem(
                            grantedBytes, {
                                success: function( fsys ) {
                                    fs = fsys;
                                    deferred.resolve();
                                },
                                error: function( e ) {
                                    errorHandler( e );
                                }
                            }
                        );
                    },
                    error: errorHandler
                }
            );
        } else {
            deferred.resolve();
        }
        return deferred.promise();
    };

    /**
     * @param  {string}                             dirName name of directory to store files in
     * @param  {{success:Function, error:Function}} callbacks callback functions (error, and success)
     */
    setDir = function( dirName, callbacks ) {
        var currentSuccessCb = callbacks.success;

        if ( dirName && dirName.length > 0 ) {

            callbacks.success = function( dirEntry ) {
                currentDir = dirName;
                currentSuccessCb();
            };

            filesystemReady.done( function() {
                createDir( dirName, callbacks );
            } );

        } else {
            console.error( 'directory name empty or missing' );
            return false;
        }
    };

    /**
     * Checks if File API is supported by browser
     * @return {boolean}
     */
    isSupported = function() {
        return supported;
    };

    /**
     * returns dir prefix to be use to build a filesystem path
     * @param  {string=} dirName the dirName to use if provided, otherwise the current directory name is used
     * @return {string} returns the path prefix or '/' (root)
     */
    _getDirPrefix = function( dirName ) {
        return ( dirName ) ? '/' + dirName + '/' : ( currentDir ) ? '/' + currentDir + '/' : '/';
    };

    /**
     * Requests PERSISTENT file storage (may prompt user) asynchronously
     * @param  {number}                     bytesRequested the storage size in bytes that is requested
     * @param  {Object.<string, Function>}  callbacks      callback functions (error, and success)
     */
    requestQuota = function( bytesRequested, callbacks ) {
        console.log( 'requesting persistent filesystem quota' );
        $( document ).trigger( 'quotarequest', bytesRequested ); //just to facilitate testing
        navigator.webkitPersistentStorage.requestQuota(
            bytesRequested,
            //successhandler is called immediately if asking for increase in quota
            callbacks.success,
            callbacks.error
        );
    };

    /**
     * requests filesystem
     * @param  {number} bytes       when called by requestQuota for PERSISTENt storage this is the number of bytes granted
     * @param  {Object.<string, Function>} callbacks   callback functions (error, and success)
     */
    requestFileSystem = function( bytes, callbacks ) {
        console.log( 'quota for persistent storage granted in MegaBytes: ' + bytes / ( 1024 * 1024 ) );
        if ( bytes > 0 ) {
            currentQuota = bytes;
            window.requestFileSystem(
                window.PERSISTENT,
                bytes,
                callbacks.success,
                callbacks.error
            );
        } else {
            //actually not correct to treat this as an error
            console.error( 'User did not approve storage of local data using the File API' );
            callbacks.error();
        }
    };

    /**
     * generic error handler
     * @param  {(Error|FileError|string)=} e [description]
     */
    errorHandler = function( e ) {
        var msg = '';

        if ( typeof e !== 'undefined' ) {
            switch ( e.code ) {
                case window.FileError.QUOTA_EXCEEDED_ERR:
                    msg = 'QUOTA_EXCEEDED_ERR';
                    break;
                case window.FileError.NOT_FOUND_ERR:
                    msg = 'NOT_FOUND_ERR';
                    break;
                case window.FileError.SECURITY_ERR:
                    msg = 'SECURITY_ERR';
                    break;
                case window.FileError.INVALID_MODIFICATION_ERR:
                    msg = 'INVALID_MODIFICATION_ERR';
                    break;
                case window.FileError.INVALID_STATE_ERR:
                    msg = 'INVALID_STATE_ERR';
                    break;
                default:
                    msg = 'Unknown Error';
                    break;
            }
        }
        console.log( 'Error occurred: ' + msg );
        if ( typeof console.trace !== 'undefined' ) console.trace();
    };

    /**
     * Requests the amount of storage used (asynchronously) and sets variable (EXPERIMENTAL/UNSTABLE API)
     */
    setCurrentQuotaUsed = function() {
        if ( typeof navigator.webkitPersistentStorage.queryUsageAndQuota !== 'undefined' ) {
            navigator.webkitPersistentStorage.queryUsageAndQuota(
                function( quotaUsed ) {
                    currentQuotaUsed = quotaUsed;
                },
                errorHandler
            );
        } else {
            console.error( 'browser does not support queryUsageAndQuota' );
        }
    };

    /**
     * Saves a file (asynchronously) in the directory provided upon initialization
     * @param  {Blob}                       file      File object from input field
     * @param  {Object.<string, Function>}  callbacks callback functions (error, and success)
     */
    saveFile = function( file, callbacks ) {

        filesystemReady.done( function() {
            console.log( 'saving file with url: ', _getDirPrefix() + file.name );
            fs.root.getFile(
                _getDirPrefix() + file.name, {
                    create: true,
                    exclusive: false
                },
                function( fileEntry ) {
                    fileEntry.createWriter( function( fileWriter ) {
                        fileWriter.write( file );
                        fileWriter.onwriteend = function( e ) {
                            //if a file write does not complete because the file is larger than the granted quota
                            //the onwriteend event still fires. (This may be a browser bug.)
                            //so we're checking if the complete file was saved and if not, do nothing and assume
                            //that the onerror event will fire
                            if ( e.total === e.loaded ) {
                                //console.log('write completed', e);
                                setCurrentQuotaUsed();
                                console.log( 'complete file stored, with persistent url:' + fileEntry.toURL() );
                                callbacks.success( fileEntry.toURL() );
                            }
                        };
                        fileWriter.onerror = function( e ) {
                            var newBytesRequest,
                                targetError = e.target.error;
                            if ( targetError instanceof FileError && targetError.code === window.FileError.QUOTA_EXCEEDED_ERR ) {
                                newBytesRequest = ( ( e.total * 5 ) < DEFAULTBYTESREQUESTED ) ? currentQuota + DEFAULTBYTESREQUESTED : currentQuota + ( 5 * e.total );
                                console.log( 'Required storage exceeding quota, going to request more, in bytes: ' + newBytesRequest );
                                requestQuota(
                                    newBytesRequest, {
                                        success: function( bytes ) {
                                            console.log( 'request for additional quota approved! (quota: ' + bytes + ' bytes)' );
                                            currentQuota = bytes;
                                            saveFile( file, callbacks );
                                        },
                                        error: callbacks.error
                                    }
                                );
                            } else {
                                callbacks.error( e );
                            }
                        };
                    }, callbacks.error );
                },
                callbacks.error
            );
        } );
    };

    /**
     * Obtains specified files from a specified directory (asynchronously)
     * @param {string}                              directoryName   directory to look in for files
     * @param {{newName: string, fileName: string}} fileO           object of file properties
     * @param {{success:Function, error:Function}}  callbacks       callback functions (error, and success)
     */
    retrieveFile = function( directoryName, fileO, callbacks ) {
        var retrievedFile = {},
            pathPrefix = _getDirPrefix( directoryName ),
            callbacksForFileEntry = {
                success: function( fileEntry ) {
                    retrieveFileFromFileEntry( fileEntry, {
                        success: function( file ) {
                            console.debug( 'retrieved file! ', file );
                            fileO.file = file;
                            callbacks.success( fileO );
                        },
                        error: callbacks.error
                    } );
                },
                error: callbacks.error
            };

        retrieveFileEntry( pathPrefix + fileO.fileName, {
            success: callbacksForFileEntry.success,
            error: callbacksForFileEntry.error
        } );
    };

    // retrieve a local filesystem URL if the file exists
    retrieveFileUrl = function( directoryName, fileName, callbacks ) {
        var pathPrefix = _getDirPrefix( directoryName );

        retrieveFileEntry( pathPrefix + fileName, {
            success: function( fileEntry ) {
                callbacks.success( fileEntry.toURL() );
            },
            error: callbacks.error
        } );
    };

    /**
     * Obtains a fileEntry (asynchronously)
     * @param  {string}                             fullPath    full filesystem path to the file
     * @param {{success:Function, error:Function}}  callbacks   callback functions (error, and success)
     */
    retrieveFileEntry = function( fullPath, callbacks ) {
        console.debug( 'retrieving fileEntry for: ' + fullPath );

        filesystemReady.done( function() {
            fs.root.getFile( fullPath, {},
                function( fileEntry ) {
                    console.log( 'fileEntry retrieved: ', fileEntry, 'persistent URL: ', fileEntry.toURL() );
                    callbacks.success( fileEntry );
                },
                function( e ) {
                    console.error( 'file with path: ' + fullPath + ' not found', e );
                    callbacks.error( e );
                }
            );
        } );
    };

    /**
     * Retrieves a file from a fileEntry (asynchronously)
     * @param  {FileEntry} fileEntry [description]
     * @param  {{success:function(File), error: ?function(FileError)}} callbacks [description]
     */
    retrieveFileFromFileEntry = function( fileEntry, callbacks ) {
        fileEntry.file( callbacks.success, callbacks.error );
    };

    /**
     * Deletes a file from the file system (asynchronously) from the directory set upon initialization
     * @param {string}                              fileName        file name
     * @param {{success:Function, error:Function}}  callbacks       callback functions (error, and success)
     */
    deleteFile = function( fileName, callbacks ) {
        //check if filesystem is ready?
        //console.log('amount of storage used: '+this.getStorageUsed());
        console.log( 'deleting file: ' + fileName );
        callbacks = callbacks || {
            success: function() {},
            error: function() {}
        };
        //console.log('amount of storage used: '+this.getStorageUsed());
        filesystemReady.done( function() {
            fs.root.getFile( _getDirPrefix() + fileName, {
                    create: false
                },
                function( fileEntry ) {
                    fileEntry.remove( function() {
                        setCurrentQuotaUsed();
                        console.log( fileName + ' removed from file system' );
                        callbacks.success();
                    } );
                },
                function( e ) {
                    errorHandler( e );
                    callbacks.error();
                }
            );
        } );
    };

    /**
     * Creates a directory
     * @param  {string}                                 name      name of directory
     * @param  {{success: Function, error: Function}}   callbacks callback functions (error, and success)
     */
    createDir = function( name, callbacks ) {

        callbacks = callbacks || {
            success: function() {},
            error: function() {}
        };

        filesystemReady.done( function() {
            fs.root.getDirectory( name, {
                    create: true
                },
                function( dirEntry ) {
                    setCurrentQuotaUsed();
                    console.log( 'Directory: ' + name + ' created (or found)', dirEntry );
                    callbacks.success();
                },
                function( e ) {
                    console.log( 'error during creation of directory', e );
                    var newBytesRequest; //,
                    if ( e instanceof FileError && e.code === window.FileError.QUOTA_EXCEEDED_ERR ) {
                        console.log( 'Required storage exceeding quota, going to request more.' );
                        newBytesRequest = ( ( e.total * 5 ) < DEFAULTBYTESREQUESTED ) ? currentQuota + DEFAULTBYTESREQUESTED : currentQuota + ( 5 * e.total );
                        requestQuota(
                            newBytesRequest, {
                                success: function( bytes ) {
                                    currentQuota = bytes;
                                    createDir( name, callbacks );
                                },
                                error: callbacks.error
                            }
                        );
                    } else {
                        callbacks.error( e );
                    }
                }
                //TODO: ADD similar request for additional storage if FileError.QUOTA_EXCEEEDED_ERR is thrown as done in saveFile()
            );
        } );
    };

    /**
     * Deletes a complete directory with all its contents
     * @param {string}                                  name        name of directory
     * @param {{success: Function, error: Function}}    callbacks   callback functions (error, and success)
     */
    deleteDir = function( name, callbacks ) {

        callbacks = callbacks || {
            success: function() {},
            error: function() {}
        };

        console.log( 'going to delete filesystem directory: ' + name );

        filesystemReady.done( function() {
            console.log( 'fs is ready, going for it!' );
            fs.root.getDirectory( name, {},
                function( dirEntry ) {
                    dirEntry.removeRecursively(
                        function() {
                            setCurrentQuotaUsed();
                            callbacks.success();
                        },
                        function( e ) {
                            errorHandler( e );
                            callbacks.error();
                        }
                    );
                },
                errorHandler
            );
        } );
    };

    /**
     * Deletes all files stored (for a subsubdomain)
     * @param {Function=} callbackComplete  function to call when complete
     */
    deleteAll = function( callbackComplete ) {
        callbackComplete = callbackComplete || function() {};

        var process = {
            entryFound: function( entry ) {
                if ( entry.isDirectory ) {
                    entry.removeRecursively(
                        function() {
                            setCurrentQuotaUsed();
                            console.log( 'Directory: ' + entry.name + ' deleted' );
                        },
                        errorHandler
                    );
                } else {
                    entry.remove( function() {
                            setCurrentQuotaUsed();
                            console.log( 'File: ' + entry.name + ' deleted' );
                        },
                        errorHandler
                    );
                }
            },
            complete: callbackComplete
        };

        filesystemReady.done( function() {
            _traverseAll( process );
        } );
    };

    /**
     * Lists all files/folders in root (function may not be required)
     * @param {Function=} callbackComplete  function to call when complete
     */
    listAll = function( callbackComplete ) {
        //check if filesystem is ready?
        callbackComplete = callbackComplete || function() {};
        var entries = [],
            process = {
                entryFound: function( entry ) {
                    if ( entry.isDirectory ) {
                        entries.push( 'folder: ' + entry.name );
                    } else {
                        entries.push( 'file: ' + entry.name );
                    }
                },
                complete: function() {
                    console.log( 'entries: ', entries );
                    callbackComplete();
                }
            };
        _traverseAll( process );
    };

    /**
     * traverses all folders and files in root
     * @param  {{entryFound: Function, complete}} process [description]
     */
    _traverseAll = function( process ) {
        var entry, type,
            dirReader = fs.root.createReader();

        // Call the reader.readEntries() until no more results are returned.
        var readEntries = function() {
            dirReader.readEntries( function( results ) {
                if ( !results.length ) {
                    process.complete();
                } else {
                    for ( var i = 0; i < results.length; i++ ) {
                        entry = results[ i ];
                        process.entryFound( entry );
                    }
                    readEntries();
                }
            }, errorHandler );
        };
        readEntries();
    };

    init();

    return {
        init: init,
        isSupported: isSupported,
        setDir: setDir,
        getCurrentQuota: getCurrentQuota,
        getCurrentQuotaUsed: getCurrentQuotaUsed,
        saveFile: saveFile,
        retrieveFile: retrieveFile,
        retrieveFileUrl: retrieveFileUrl,
        deleteFile: deleteFile,
        createDir: createDir,
        deleteDir: deleteDir,
        deleteAll: deleteAll,
        listAll: listAll
    };

} );

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/file-offline/offline-filepicker',[ 'jquery', 'enketo-js/Widget', 'file-manager' ], function( $, Widget, fileManager ) {
    

    var pluginName = 'offlineFilepicker';

    /**
     * File picker meant for offline-enabled form views
     *
     * Good references:
     * http://www.html5rocks.com/en/tutorials/file/filesystem/#toc-filesystemurls
     * http://updates.html5rocks.com/2012/08/Integrating-input-type-file-with-the-Filesystem-API
     * http://html5-demos.appspot.com/static/filesystem/generatingResourceURIs.html
     *
     * @constructor
     * @param {Element} element [description]
     * @param {(boolean|{touch: boolean, maxlength:number})} options options
     * @param {*=} e     event
     */

    function OfflineFilepicker( element, options, e ) {
        if ( e ) {
            e.stopPropagation();
            e.preventDefault();
        }
        this.namespace = pluginName;
        Widget.call( this, element, options );
        this._init();
    }

    //copy the prototype functions from the Widget super class
    OfflineFilepicker.prototype = Object.create( Widget.prototype );

    //ensure the constructor is the new one
    OfflineFilepicker.prototype.constructor = OfflineFilepicker;

    /**
     * initialize
     *
     */
    OfflineFilepicker.prototype._init = function() {
        var existingFileName,
            $input = $( this.element ),
            feedbackMsg = "Awaiting user permission to store local data (files)",
            feedbackClass = "info",
            allClear = false,
            that = this;

        //TODO: add online file widget in case fileManager is undefined or use file manager with temporary storage?
        if ( typeof fileManager == "undefined" || !fileManager ) {
            feedbackClass = "warning";
            feedbackMsg = "File uploads not supported."; //" in previews and iframed views.";
        } else if ( !fileManager.isSupported() ) {
            feedbackClass = "warning";
            feedbackMsg = "File uploads not supported by your browser";
        } else {
            allClear = true;
        }

        $input
            .prop( 'disabled', true )
            .addClass( 'ignore force-disabled' )
            .after( '<div class="file-feedback text-' + feedbackClass + '">' + feedbackMsg + '</div>' );

        if ( !allClear ) {
            $( this.element ).hide();
            return;
        }

        this._changeListener();
        this._createDirectory();

        //this attribute is added by the Form instance when loading data to edit
        existingFileName = $input.attr( 'data-loaded-file-name' );

        if ( existingFileName ) {
            fileManager.retrieveFileUrl( this._getInstanceID(), existingFileName, {
                success: function( fsUrl ) {
                    var $prev = that._createPreview( fsUrl, 'image/*' );
                    $input.attr( 'data-previous-file-name', existingFileName )
                        .removeAttr( 'data-loaded-file-name' )
                        .siblings( '.file-loaded' ).remove();
                    $input.after( $prev );
                },
                error: function() {
                    $input.after( '<div class="file-loaded text-warning">This form was loaded with "' +
                        existingFileName + '". To preserve this file, do not change this input.</div>' );
                }
            } );
        }
        $input.parent().addClass( 'with-media clearfix' );

    };

    OfflineFilepicker.prototype._getMaxSubmissionSize = function() {
        var maxSize = $( document ).data( 'maxSubmissionSize' );
        return maxSize || 5 * 1024 * 1024;
    };

    OfflineFilepicker.prototype._changeListener = function() {
        /*
         * This delegated eventhander should actually be added asynchronously( or not at all
         * if no FS support / permission ).However, it
         * needs to start * before * the regular input change event handler
         * for 2 reasons:
         * 1.If saving the file in the browser 's file system fails, the instance should not be updated
         * 2. The regular eventhandler has event.stopImmediatePropagation which would mean this handler is never called.
         * The easiest way to achieve this is to always add it but only let it do something if permission is granted to use FS.
         */
        var that = this,
            $input = $( this.element );
        $input.on( 'change.passthrough.' + this.namespace, function( event ) {
            if ( fileManager.getCurrentQuota() ) {
                var prevFileName, file, mediaType, $preview,
                    maxSubmissionSize = that._getMaxSubmissionSize();
                //console.debug( 'namespace: ' + event.namespace );
                if ( event.namespace === 'passthrough' ) {
                    //console.debug('returning true');
                    $input.trigger( 'change.file' );
                    return false;
                }
                prevFileName = $input.attr( 'data-previous-file-name' );
                file = $input[ 0 ].files[ 0 ];
                mediaType = $input.attr( 'accept' );

                // removed cleanup as it will cause a problem in the following scenario:
                // 1. record is loaded from local storage with file input
                // 2. user changes file input 
                // 3. but user changes mind and decides not to save updated record
                // 4. the file in the stored record no longer exists
                // It is better to let the controller deal with clearing filesystem storage (which it does)
                // if ( prevFileName && ( !file || prevFileName !== file.name ) ) {
                //    fileManager.deleteFile( prevFileName );
                // }
                $input.siblings( '.file-feedback, .file-preview, .file-loaded' ).remove();
                console.debug( 'file: ', file );
                if ( file && file.size > 0 && file.size <= maxSubmissionSize ) {
                    //save it in filesystem
                    fileManager.saveFile(
                        file, {
                            success: function( fsURL ) {
                                $preview = that._createPreview( fsURL, mediaType );
                                //$preview.attr( 'src', fsURL );
                                $input.attr( 'data-previous-file-name', file.name )
                                    .removeAttr( 'data-loaded-file-name' )
                                    .siblings( '.file-loaded' ).remove();
                                $input.trigger( 'change.passthrough' ).after( $preview );
                            },
                            error: function( e ) {
                                console.error( 'error: ', e );
                                $input.val( '' )
                                    .removeAttr( 'data-loaded-file-name' )
                                    .siblings( '.file-loaded' ).remove();
                                $input.after( '<div class="file-feedback text-error">' +
                                    'Failed to save file</span>' );
                            }
                        }
                    );
                    return false;
                } else {
                    //clear instance value by letting it bubble up to normal change handler
                    if ( file.size > maxSubmissionSize ) {
                        $input.after( '<div class="file-feedback text-error">' +
                            'File too large (max ' +
                            ( Math.round( ( maxSubmissionSize * 100 ) / ( 1024 * 1024 ) ) / 100 ) +
                            ' Mb)</div>' );
                    }
                    return true;
                }
            }
        } );
    };

    OfflineFilepicker.prototype._createPreview = function( fsURL, mediaType ) {
        var $preview;

        $preview = ( mediaType && mediaType === 'image/*' ) ? $( '<img />' ) : ( mediaType === 'audio/*' ) ? $( '<audio controls="controls"/>' ) : ( mediaType === 'video/*' ) ? $( '<video controls="controls"/>' ) : $( '<span>No preview for this mediatype</span>' );

        return $preview.addClass( 'file-preview' ).attr( 'src', fsURL );
    };

    OfflineFilepicker.prototype._getInstanceID = function() {
        var id = $( 'form.or' ).data( 'instanceID' );
        if ( !id ) {
            console.error( 'Filepicker widget could not find instanceID. Files will not be saved correctly!' );
        }
        return id;
    };

    OfflineFilepicker.prototype._createDirectory = function() {
        var $input = $( this.element ),
            callbacks = {
                success: function() {
                    console.log( 'Whoheee, we have permission to use the file system' );
                    $input.removeClass( 'ignore force-disabled' )
                        .prop( 'disabled', false )
                        .siblings( '.file-feedback' ).remove()
                        .end()
                        .after( '<div class="file-feedback text-info">' +
                            'File inputs are experimental. Use only for testing.' );
                },
                error: function() {
                    $input.siblings( '.file-feedback' ).remove();
                    $input.after( '<div class="file-feedback text-warning">' +
                        'No permission given to store local data (or an error occurred).</div>' );
                }
            };

        fileManager.setDir( this._getInstanceID(), callbacks );
    };

    OfflineFilepicker.prototype.destroy = function( element ) {
        $( element )
        //data is not used elsewhere by enketo
        .removeData( this.namespace )
        //remove all the event handlers that used this.namespace as the namespace
        .off( '.' + this.namespace )
        //show the original element
        .show()
        //remove elements immediately after the target that have the widget class
        .next( '.widget' ).remove().end()
        //console.debug( this.namespace, 'destroy' );
        .siblings( '.file-feedback, .file-preview, .file-loaded' ).remove();
    };

    /**
     *
     */
    $.fn[ pluginName ] = function( options, event ) {

        options = options || {};

        return this.each( function() {
            var $this = $( this ),
                data = $this.data( pluginName );

            //only instantiate if options is an object (i.e. not a string) and if it doesn't exist already
            if ( !data && typeof options === 'object' ) {
                $this.data( pluginName, ( data = new OfflineFilepicker( this, options, event ) ) );
            }
            //only call method if widget was instantiated before
            else if ( data && typeof options == 'string' ) {
                //pass the element as a parameter as this is used in fix()
                data[ options ]( this );
            }
        } );
    };

} );

;

define("enketo-widget/select-likert/likertitem", function(){});

/** Customized for Enketo:
 *  - wrapped anonymous function inside an AMD wrapper and removed the (window.jQuery) all the way at the bottom
 *  - removed tooltip html
 *  - keep original input element intact instead of moving it inside the slider div
 */


/* =========================================================
 * bootstrap-slider.js v3.0.0
 * =========================================================
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

( function( factory ) {
    if ( typeof define === 'function' && define.amd && define.amd.jQuery ) {
        // AMD. Register as anonymous module.
        define( 'bootstrap-slider',[ 'jquery' ], factory );
    } else {
        // Browser globals.
        factory( jQuery );
    }
}( function( $ ) {

    var ErrorMsgs = {
        formatInvalidInputErrorMsg: function( input ) {
            return "Invalid input value '" + input + "' passed in";
        },
        callingContextNotSliderInstance: "Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"
    };

    var Slider = function( element, options ) {
        var el = this.element = $( element ).hide();
        var origWidth = $( element )[ 0 ].style.width;

        var updateSlider = false;
        var widget = this.element.next( '.widget' );

        if ( widget.hasClass( 'slider' ) === true ) {
            updateSlider = true;
            this.picker = widget;
        } else {
            this.picker = $( '<div class="slider widget">' +
                '<div class="slider-track">' +
                '<div class="slider-selection"></div>' +
                '<div class="slider-handle"></div>' +
                '<div class="slider-handle"></div>' +
                '</div>' +
                //'<div id="tooltip" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
                //<div id="tooltip_min" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
                //'<div id="tooltip_max" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
                '</div>' )
                .insertAfter( this.element );
            //.append( this.element );
        }

        this.id = this.element.data( 'slider-id' ) || options.id;
        if ( this.id ) {
            this.picker[ 0 ].id = this.id;
        }

        if ( ( 'ontouchstart' in window ) || window.DocumentTouch && document instanceof window.DocumentTouch ) {
            this.touchCapable = true;
        }

        //var tooltip = this.element.data( 'slider-tooltip' ) || options.tooltip;

        //this.tooltip = this.picker.find( '#tooltip' );
        //this.tooltipInner = this.tooltip.find( 'div.tooltip-inner' );

        //this.tooltip_min = this.picker.find( '#tooltip_min' );
        //this.tooltipInner_min = this.tooltip_min.find( 'div.tooltip-inner' );

        //this.tooltip_max = this.picker.find( '#tooltip_max' );
        //this.tooltipInner_max = this.tooltip_max.find( 'div.tooltip-inner' );

        if ( updateSlider === true ) {
            // Reset classes
            this.picker.removeClass( 'slider-horizontal' );
            this.picker.removeClass( 'slider-vertical' );
            //this.tooltip.removeClass( 'hide' );
            //this.tooltip_min.removeClass( 'hide' );
            //this.tooltip_max.removeClass( 'hide' );

        }

        this.orientation = this.element.data( 'slider-orientation' ) || options.orientation;
        switch ( this.orientation ) {
            case 'vertical':
                this.picker.addClass( 'slider-vertical' );
                this.stylePos = 'top';
                this.mousePos = 'pageY';
                this.sizePos = 'offsetHeight';
                //this.tooltip.addClass( 'right' )[ 0 ].style.left = '100%';
                //this.tooltip_min.addClass( 'right' )[ 0 ].style.left = '100%';
                //this.tooltip_max.addClass( 'right' )[ 0 ].style.left = '100%';
                break;
            default:
                this.picker
                    .addClass( 'slider-horizontal' )
                    .css( 'width', origWidth );
                this.orientation = 'horizontal';
                this.stylePos = 'left';
                this.mousePos = 'pageX';
                this.sizePos = 'offsetWidth';
                //this.tooltip.addClass( 'top' )[ 0 ].style.top = -this.tooltip.outerHeight() - 14 + 'px';
                //this.tooltip_min.addClass( 'top' )[ 0 ].style.top = -this.tooltip_min.outerHeight() - 14 + 'px';
                //this.tooltip_max.addClass( 'top' )[ 0 ].style.top = -this.tooltip_max.outerHeight() - 14 + 'px';
                break;
        }

        var self = this;
        $.each( [ 'min',
            'max',
            'step',
            'precision',
            'value',
            'reversed',
            'handle'
        ], function( i, attr ) {
            if ( typeof el.data( 'slider-' + attr ) !== 'undefined' ) {
                self[ attr ] = el.data( 'slider-' + attr );
            } else if ( typeof options[ attr ] !== 'undefined' ) {
                self[ attr ] = options[ attr ];
            } else if ( typeof el.prop( attr ) !== 'undefined' ) {
                self[ attr ] = el.prop( attr );
            } else {
                self[ attr ] = 0; // to prevent empty string issues in calculations in IE
            }
        } );

        if ( this.value instanceof Array ) {
            if ( updateSlider && !this.range ) {
                this.value = this.value[ 0 ];
            } else {
                this.range = true;
            }
        } else if ( this.range ) {
            // User wants a range, but value is not an array
            this.value = [ this.value, this.max ];
        }

        this.selection = this.element.data( 'slider-selection' ) || options.selection;
        this.selectionEl = this.picker.find( '.slider-selection' );
        if ( this.selection === 'none' ) {
            this.selectionEl.addClass( 'hide' );
        }

        this.selectionElStyle = this.selectionEl[ 0 ].style;

        this.handle1 = this.picker.find( '.slider-handle:first' );
        this.handle1Stype = this.handle1[ 0 ].style;

        this.handle2 = this.picker.find( '.slider-handle:last' );
        this.handle2Stype = this.handle2[ 0 ].style;

        if ( updateSlider === true ) {
            // Reset classes
            this.handle1.removeClass( 'round triangle' );
            this.handle2.removeClass( 'round triangle hide' );
        }

        switch ( this.handle ) {
            case 'round':
                this.handle1.addClass( 'round' );
                this.handle2.addClass( 'round' );
                break;
            case 'triangle':
                this.handle1.addClass( 'triangle' );
                this.handle2.addClass( 'triangle' );
                break;
        }

        this.offset = this.picker.offset();
        this.size = this.picker[ 0 ][ this.sizePos ];
        this.formater = options.formater;

        //this.tooltip_separator = options.tooltip_separator;
        //this.tooltip_split = options.tooltip_split;

        this.setValue( this.value );

        this.handle1.on( {
            keydown: $.proxy( this.keydown, this, 0 )
        } );
        this.handle2.on( {
            keydown: $.proxy( this.keydown, this, 1 )
        } );

        if ( this.touchCapable ) {
            // Touch: Bind touch events:
            this.picker.on( {
                touchstart: $.proxy( this.mousedown, this )
            } );
        }
        // Bind mouse events:
        this.picker.on( {
            mousedown: $.proxy( this.mousedown, this )
        } );

        /*
        if ( tooltip === 'hide' ) {
            this.tooltip.addClass( 'hide' );
            this.tooltip_min.addClass( 'hide' );
            this.tooltip_max.addClass( 'hide' );
        } else if ( tooltip === 'always' ) {
            this.showTooltip();
            this.alwaysShowTooltip = true;
        } else {
            this.picker.on( {
                mouseenter: $.proxy( this.showTooltip, this ),
                mouseleave: $.proxy( this.hideTooltip, this )
            } );
            this.handle1.on( {
                focus: $.proxy( this.showTooltip, this ),
                blur: $.proxy( this.hideTooltip, this )
            } );
            this.handle2.on( {
                focus: $.proxy( this.showTooltip, this ),
                blur: $.proxy( this.hideTooltip, this )
            } );
        }*/

        this.enabled = options.enabled &&
            ( this.element.data( 'slider-enabled' ) === undefined || this.element.data( 'slider-enabled' ) === true );
        if ( this.enabled ) {
            this.enable();
        } else {
            this.disable();
        }
        this.natural_arrow_keys = this.element.data( 'slider-natural_arrow_keys' ) || options.natural_arrow_keys;
    };

    Slider.prototype = {
        constructor: Slider,

        over: false,
        inDrag: false,

        /*showTooltip: function() {
            if ( this.tooltip_split === false ) {
                this.tooltip.addClass( 'in' );
            } else {
                this.tooltip_min.addClass( 'in' );
                this.tooltip_max.addClass( 'in' );
            }

            this.over = true;
        },

        hideTooltip: function() {
            if ( this.inDrag === false && this.alwaysShowTooltip !== true ) {
                this.tooltip.removeClass( 'in' );
                this.tooltip_min.removeClass( 'in' );
                this.tooltip_max.removeClass( 'in' );
            }
            this.over = false;
        },*/

        layout: function() {
            var positionPercentages;

            if ( this.reversed ) {
                positionPercentages = [ 100 - this.percentage[ 0 ], this.percentage[ 1 ] ];
            } else {
                positionPercentages = [ this.percentage[ 0 ], this.percentage[ 1 ] ];
            }

            this.handle1Stype[ this.stylePos ] = positionPercentages[ 0 ] + '%';
            this.handle2Stype[ this.stylePos ] = positionPercentages[ 1 ] + '%';

            if ( this.orientation === 'vertical' ) {
                this.selectionElStyle.top = Math.min( positionPercentages[ 0 ], positionPercentages[ 1 ] ) + '%';
                this.selectionElStyle.height = Math.abs( positionPercentages[ 0 ] - positionPercentages[ 1 ] ) + '%';
            } else {
                this.selectionElStyle.left = Math.min( positionPercentages[ 0 ], positionPercentages[ 1 ] ) + '%';
                this.selectionElStyle.width = Math.abs( positionPercentages[ 0 ] - positionPercentages[ 1 ] ) + '%';

                //var offset_min = this.tooltip_min[ 0 ].getBoundingClientRect();
                //var offset_max = this.tooltip_max[ 0 ].getBoundingClientRect();
                /*
                if ( offset_min.right > offset_max.left ) {
                    this.tooltip_max.removeClass( 'top' );
                    this.tooltip_max.addClass( 'bottom' )[ 0 ].style.top = 18 + 'px';
                } else {
                    this.tooltip_max.removeClass( 'bottom' );
                    this.tooltip_max.addClass( 'top' )[ 0 ].style.top = -30 + 'px';
                }*/
            }

            /*
            if ( this.range ) {
                this.tooltipInner.text(
                    this.formater( this.value[ 0 ] ) + this.tooltip_separator + this.formater( this.value[ 1 ] )
                );
                this.tooltip[ 0 ].style[ this.stylePos ] = this.size * ( positionPercentages[ 0 ] + ( positionPercentages[ 1 ] - positionPercentages[ 0 ] ) / 2 ) / 100 - ( this.orientation === 'vertical' ? this.tooltip.outerHeight() / 2 : this.tooltip.outerWidth() / 2 ) + 'px';

                this.tooltipInner_min.text(
                    this.formater( this.value[ 0 ] )
                );
                this.tooltipInner_max.text(
                    this.formater( this.value[ 1 ] )
                );

                this.tooltip_min[ 0 ].style[ this.stylePos ] = this.size * ( ( positionPercentages[ 0 ] ) / 100 ) - ( this.orientation === 'vertical' ? this.tooltip_min.outerHeight() / 2 : this.tooltip_min.outerWidth() / 2 ) + 'px';
                this.tooltip_max[ 0 ].style[ this.stylePos ] = this.size * ( ( positionPercentages[ 1 ] ) / 100 ) - ( this.orientation === 'vertical' ? this.tooltip_max.outerHeight() / 2 : this.tooltip_max.outerWidth() / 2 ) + 'px';

            } else {
                this.tooltipInner.text(
                    this.formater( this.value[ 0 ] )
                );
                this.tooltip[ 0 ].style[ this.stylePos ] = this.size * positionPercentages[ 0 ] / 100 - ( this.orientation === 'vertical' ? this.tooltip.outerHeight() / 2 : this.tooltip.outerWidth() / 2 ) + 'px';
            }*/
        },

        mousedown: function( ev ) {
            if ( !this.isEnabled() ) {
                return false;
            }
            // Touch: Get the original event:
            if ( this.touchCapable && ev.type === 'touchstart' ) {
                ev = ev.originalEvent;
            }

            this.triggerFocusOnHandle();

            this.offset = this.picker.offset();
            this.size = this.picker[ 0 ][ this.sizePos ];

            var percentage = this.getPercentage( ev );

            if ( this.range ) {
                var diff1 = Math.abs( this.percentage[ 0 ] - percentage );
                var diff2 = Math.abs( this.percentage[ 1 ] - percentage );
                this.dragged = ( diff1 < diff2 ) ? 0 : 1;
            } else {
                this.dragged = 0;
            }

            this.percentage[ this.dragged ] = this.reversed ? 100 - percentage : percentage;
            this.layout();

            if ( this.touchCapable ) {
                // Touch: Bind touch events:
                $( document ).on( {
                    touchmove: $.proxy( this.mousemove, this ),
                    touchend: $.proxy( this.mouseup, this )
                } );
            }
            // Bind mouse events:
            $( document ).on( {
                mousemove: $.proxy( this.mousemove, this ),
                mouseup: $.proxy( this.mouseup, this )
            } );

            this.inDrag = true;
            var val = this.calculateValue();
            this.element.trigger( {
                type: 'slideStart',
                value: val
            } )
                .data( 'value', val )
                .prop( 'value', val );
            this.setValue( val );
            return true;
        },

        triggerFocusOnHandle: function( handleIdx ) {
            if ( handleIdx === 0 ) {
                this.handle1.focus();
            }
            if ( handleIdx === 1 ) {
                this.handle2.focus();
            }
        },

        keydown: function( handleIdx, ev ) {
            if ( !this.isEnabled() ) {
                return false;
            }

            var dir;
            switch ( ev.which ) {
                case 37: // left
                case 40: // down
                    dir = -1;
                    break;
                case 39: // right
                case 38: // up
                    dir = 1;
                    break;
            }
            if ( !dir ) {
                return;
            }

            // use natural arrow keys instead of from min to max
            if ( this.natural_arrow_keys ) {
                if ( ( this.orientation === 'vertical' && !this.reversed ) || ( this.orientation === 'horizontal' && this.reversed ) ) {
                    dir = dir * -1;
                }
            }

            var oneStepValuePercentageChange = dir * this.percentage[ 2 ];
            var percentage = this.percentage[ handleIdx ] + oneStepValuePercentageChange;

            if ( percentage > 100 ) {
                percentage = 100;
            } else if ( percentage < 0 ) {
                percentage = 0;
            }

            this.dragged = handleIdx;
            this.adjustPercentageForRangeSliders( percentage );
            this.percentage[ this.dragged ] = percentage;
            this.layout();

            var val = this.calculateValue();

            this.element.trigger( {
                type: 'slideStart',
                value: val
            } )
                .data( 'value', val )
                .prop( 'value', val );

            this.setValue( val, true );

            this.element
                .trigger( {
                    type: 'slideStop',
                    value: val
                } )
                .data( 'value', val )
                .prop( 'value', val );
            return false;
        },

        mousemove: function( ev ) {
            if ( !this.isEnabled() ) {
                return false;
            }
            // Touch: Get the original event:
            if ( this.touchCapable && ev.type === 'touchmove' ) {
                ev = ev.originalEvent;
            }

            var percentage = this.getPercentage( ev );
            this.adjustPercentageForRangeSliders( percentage );
            this.percentage[ this.dragged ] = this.reversed ? 100 - percentage : percentage;
            this.layout();

            var val = this.calculateValue();
            this.setValue( val, true );

            return false;
        },
        adjustPercentageForRangeSliders: function( percentage ) {
            if ( this.range ) {
                if ( this.dragged === 0 && this.percentage[ 1 ] < percentage ) {
                    this.percentage[ 0 ] = this.percentage[ 1 ];
                    this.dragged = 1;
                } else if ( this.dragged === 1 && this.percentage[ 0 ] > percentage ) {
                    this.percentage[ 1 ] = this.percentage[ 0 ];
                    this.dragged = 0;
                }
            }
        },

        mouseup: function() {
            if ( !this.isEnabled() ) {
                return false;
            }
            if ( this.touchCapable ) {
                // Touch: Unbind touch event handlers:
                $( document ).off( {
                    touchmove: this.mousemove,
                    touchend: this.mouseup
                } );
            }
            // Unbind mouse event handlers:
            $( document ).off( {
                mousemove: this.mousemove,
                mouseup: this.mouseup
            } );

            this.inDrag = false;
            /*if ( this.over === false ) {
                this.hideTooltip();
            }*/
            var val = this.calculateValue();
            this.layout();
            this.element
                .data( 'value', val )
                .prop( 'value', val )
                .trigger( {
                    type: 'slideStop',
                    value: val
                } );
            return false;
        },

        calculateValue: function() {
            var val;
            if ( this.range ) {
                val = [ this.min, this.max ];
                if ( this.percentage[ 0 ] !== 0 ) {
                    val[ 0 ] = ( Math.max( this.min, this.min + Math.round( ( this.diff * this.percentage[ 0 ] / 100 ) / this.step ) * this.step ) );
                    val[ 0 ] = this.applyPrecision( val[ 0 ] );
                }
                if ( this.percentage[ 1 ] !== 100 ) {
                    val[ 1 ] = ( Math.min( this.max, this.min + Math.round( ( this.diff * this.percentage[ 1 ] / 100 ) / this.step ) * this.step ) );
                    val[ 1 ] = this.applyPrecision( val[ 1 ] );
                }
                this.value = val;
            } else {
                val = ( this.min + Math.round( ( this.diff * this.percentage[ 0 ] / 100 ) / this.step ) * this.step );
                if ( val < this.min ) {
                    val = this.min;
                } else if ( val > this.max ) {
                    val = this.max;
                }
                val = parseFloat( val );
                val = this.applyPrecision( val );
                this.value = [ val, this.value[ 1 ] ];
            }
            return val;
        },
        applyPrecision: function( val ) {
            var precision = this.precision || this.getNumDigitsAfterDecimalPlace( this.step );
            return this.applyToFixedAndParseFloat( val, precision );
        },
        /*
            Credits to Mike Samuel for the following method!
            Source: http://stackoverflow.com/questions/10454518/javascript-how-to-retrieve-the-number-of-decimals-of-a-string-number
        */
        getNumDigitsAfterDecimalPlace: function( num ) {
            var match = ( '' + num ).match( /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/ );
            if ( !match ) {
                return 0;
            }
            return Math.max( 0, ( match[ 1 ] ? match[ 1 ].length : 0 ) - ( match[ 2 ] ? +match[ 2 ] : 0 ) );
        },

        applyToFixedAndParseFloat: function( num, toFixedInput ) {
            var truncatedNum = num.toFixed( toFixedInput );
            return parseFloat( truncatedNum );
        },

        getPercentage: function( ev ) {
            if ( this.touchCapable && ( ev.type === 'touchstart' || ev.type === 'touchmove' ) ) {
                ev = ev.touches[ 0 ];
            }
            var percentage = ( ev[ this.mousePos ] - this.offset[ this.stylePos ] ) * 100 / this.size;
            percentage = Math.round( percentage / this.percentage[ 2 ] ) * this.percentage[ 2 ];
            return Math.max( 0, Math.min( 100, percentage ) );
        },

        getValue: function() {
            if ( this.range ) {
                return this.value;
            }
            return this.value[ 0 ];
        },

        setValue: function( val, triggerSlideEvent ) {
            if ( !val ) {
                val = 0;
            }
            this.value = this.validateInputValue( val );

            if ( this.range ) {
                this.value[ 0 ] = this.applyPrecision( this.value[ 0 ] );
                this.value[ 1 ] = this.applyPrecision( this.value[ 1 ] );

                this.value[ 0 ] = Math.max( this.min, Math.min( this.max, this.value[ 0 ] ) );
                this.value[ 1 ] = Math.max( this.min, Math.min( this.max, this.value[ 1 ] ) );
            } else {
                this.value = this.applyPrecision( this.value );
                this.value = [ Math.max( this.min, Math.min( this.max, this.value ) ) ];
                this.handle2.addClass( 'hide' );
                if ( this.selection === 'after' ) {
                    this.value[ 1 ] = this.max;
                } else {
                    this.value[ 1 ] = this.min;
                }
            }

            this.diff = this.max - this.min;
            if ( this.diff > 0 ) {
                this.percentage = [
                    ( this.value[ 0 ] - this.min ) * 100 / this.diff, ( this.value[ 1 ] - this.min ) * 100 / this.diff,
                    this.step * 100 / this.diff
                ];
            } else {
                this.percentage = [ 0, 0, 100 ];
            }

            this.layout();


            if ( triggerSlideEvent === true ) {
                var slideEventValue = this.range ? this.value : this.value[ 0 ];
                this.element
                    .trigger( {
                        'type': 'slide',
                        'value': slideEventValue
                    } )
                    .data( 'value', slideEventValue )
                    .prop( 'value', slideEventValue );
            }
        },

        validateInputValue: function( val ) {
            if ( typeof val === 'number' ) {
                return val;
            } else if ( val instanceof Array ) {
                $.each( val, function( i, input ) {
                    if ( typeof input !== 'number' ) {
                        throw new Error( ErrorMsgs.formatInvalidInputErrorMsg( input ) );
                    }
                } );
                return val;
            } else {
                throw new Error( ErrorMsgs.formatInvalidInputErrorMsg( val ) );
            }
        },

        destroy: function() {
            this.handle1.off();
            this.handle2.off();
            this.element.off().show(); //.insertBefore( this.picker );
            this.picker.off().remove();
            $( this.element ).removeData( 'slider' );
        },

        disable: function() {
            this.enabled = false;
            this.handle1.removeAttr( "tabindex" );
            this.handle2.removeAttr( "tabindex" );
            this.picker.addClass( 'slider-disabled' );
            this.element.trigger( 'slideDisabled' );
        },

        enable: function() {
            this.enabled = true;
            this.handle1.attr( "tabindex", 0 );
            this.handle2.attr( "tabindex", 0 );
            this.picker.removeClass( 'slider-disabled' );
            this.element.trigger( 'slideEnabled' );
        },

        toggle: function() {
            if ( this.enabled ) {
                this.disable();
            } else {
                this.enable();
            }
        },

        isEnabled: function() {
            return this.enabled;
        },

        setAttribute: function( attribute, value ) {
            this[ attribute ] = value;
        },

        getAttribute: function( attribute ) {
            return this[ attribute ];
        }

    };

    var publicMethods = {
        getValue: Slider.prototype.getValue,
        setValue: Slider.prototype.setValue,
        setAttribute: Slider.prototype.setAttribute,
        getAttribute: Slider.prototype.getAttribute,
        destroy: Slider.prototype.destroy,
        disable: Slider.prototype.disable,
        enable: Slider.prototype.enable,
        toggle: Slider.prototype.toggle,
        isEnabled: Slider.prototype.isEnabled
    };

    $.fn.slider = function( option ) {
        if ( typeof option === 'string' && option !== 'refresh' ) {
            var args = Array.prototype.slice.call( arguments, 1 );
            return invokePublicMethod.call( this, option, args );
        } else {
            return createNewSliderInstance.call( this, option );
        }
    };

    function invokePublicMethod( methodName, args ) {
        if ( publicMethods[ methodName ] ) {
            var sliderObject = retrieveSliderObjectFromElement( this );
            var result = publicMethods[ methodName ].apply( sliderObject, args );

            if ( typeof result === "undefined" ) {
                return $( this );
            } else {
                return result;
            }
        } else {
            throw new Error( "method '" + methodName + "()' does not exist for slider." );
        }
    }

    function retrieveSliderObjectFromElement( element ) {
        var sliderObject = $( element ).data( 'slider' );
        if ( sliderObject && sliderObject instanceof Slider ) {
            return sliderObject;
        } else {
            throw new Error( ErrorMsgs.callingContextNotSliderInstance );
        }
    }

    function createNewSliderInstance( opts ) {
        var $this = $( this );
        $this.each( function() {
            var $this = $( this ),
                slider = $this.data( 'slider' ),
                options = typeof opts === 'object' && opts;

            // If slider already exists, use its attributes
            // as options so slider refreshes properly
            if ( slider && !options ) {
                options = {};

                $.each( $.fn.slider.defaults, function( key ) {
                    options[ key ] = slider[ key ];
                } );
            }

            $this.data( 'slider', ( new Slider( this, $.extend( {}, $.fn.slider.defaults, options ) ) ) );
        } );
        return $this;
    }

    $.fn.slider.defaults = {
        min: 0,
        max: 10,
        step: 1,
        precision: 0,
        orientation: 'horizontal',
        value: 5,
        range: false,
        selection: 'before',
        //tooltip: 'show',
        //tooltip_separator: ':',
        //tooltip_split: false,
        natural_arrow_keys: false,
        handle: 'round',
        reversed: false,
        enabled: true,
        formater: function( value ) {
            return value;
        }
    };

    $.fn.slider.Constructor = Slider;

} ) );

/**
 * @preserve Copyright 2012 Martijn van de Rijdt & Modi Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

define( 'enketo-widget/distress/distresspicker',[ 'enketo-js/Widget', 'jquery', 'bootstrap-slider' ], function( Widget, $ ) {
    

    var $lastFocused = null,
        pluginName = 'distresspicker';

    /**
     * Enhances radio buttons
     *
     * @constructor
     * @param {Element} element Element to apply widget to.
     * @param {(boolean|{touch: boolean})} options options
     * @param {*=} event     event
     */

    function Distresspicker( element, options, event ) {
        this.namespace = pluginName;
        Widget.call( this, element, options );
        this._init();
    }

    //copy the prototype functions from the Widget super class
    Distresspicker.prototype = Object.create( Widget.prototype );

    //ensure the constructor is the new one
    Distresspicker.prototype.constructor = Distresspicker;

    /**
     * Initialize
     */
    Distresspicker.prototype._init = function() {
        var step = ( $( this.element ).attr( 'data-type-xml' ) === 'decimal' ) ? 0.1 : 1,
            value = Number( this.element.value ) || -1;

        $( this.element ).slider( {
            reversed: true,
            min: -1,
            max: 10,
            orientation: 'vertical',
            step: step,
            value: value
        } );
        this.$widget = $( this.element ).next( '.slider' );
        this._addBulb();
        this._addScale();
        this._setChangeHandler();
    };

    Distresspicker.prototype._addBulb = function() {
        this.$widget.append(
            '<div class="bulb"><div class="inner"></div></div>'
        );
    };

    Distresspicker.prototype._addScale = function() {
        var $scale = $( '<div class="scale"></div>' );
        for ( var i = 10; i >= -1; i-- ) {
            $scale.append( '<div class="number"><div class="value">' + i + '</div></div>' );
        }
        this.$widget.prepend( $scale );
    };

    /**
     * Set delegated event handlers
     */
    Distresspicker.prototype._setChangeHandler = function() {
        $( this.element ).on( 'slideStop.' + this.namespace, function( slideEvt ) {
            // set to empty if value = -1
            if ( this.value == -1 ) {
                this.value = '';
            }
            $( this ).trigger( 'change' );
        } );
    };

    Distresspicker.prototype.disable = function() {
        console.log( 'disableing', this.element );
        $( this.element )
            .slider( 'disable' )
            .slider( 'setValue', this.element.value );
    };

    Distresspicker.prototype.enable = function() {
        $( this.element )
            .slider( 'enable' );
    };

    $.fn[ pluginName ] = function( options, event ) {
        return this.each( function() {
            var $this = $( this ),
                data = $( this ).data( pluginName );

            options = options || {};

            if ( !data && typeof options === 'object' ) {
                $this.data( pluginName, ( data = new Distresspicker( this, options, event ) ) );
            } else if ( data && typeof options == 'string' ) {
                //pass the context, used for destroy() as this method is called on a cloned widget
                data[ options ]( this );
            }
        } );
    };

} );


define('text!enketo-widget/note/config.json',[],function () { return '{\n    "name": "notewidget",\n    "stylesheet": "note.scss",\n    "selector": ".note, .trigger",\n    "options": {}\n}\n';});


define('text!enketo-widget/select-desktop/config.json',[],function () { return '{\n\t"name": "desktopSelectpicker",\n\t"stylesheet": "selectpicker.scss",\n\t"selector": "select:not(#form-languages)",\n\t"options": {}\n}';});


define('text!enketo-widget/select-mobile/config.json',[],function () { return '{\n\t"name": "mobileSelectpicker",\n\t"stylesheet": "selectpicker.scss",\n\t"selector": "select[multiple]",\n\t"options": {}\n}';});


define('text!enketo-widget/geo/config.json',[],function () { return '{\n    "name": "geopicker",\n    "stylesheet": "geopicker.scss",\n    "selector": "input[data-type-xml=\\"geopoint\\"], input[data-type-xml=\\"geotrace\\"], input[data-type-xml=\\"geoshape\\"]",\n    "options": {}\n}\n';});


define('text!enketo-widget/table/config.json',[],function () { return '{\n\t"name": "tablewidget",\n\t"stylesheet": "tablewidget.scss",\n\t"selector": "*:first",\n\t"options": {}\n}';});


define('text!enketo-widget/radio/config.json',[],function () { return '{\n\t"name": "radiopicker",\n\t"stylesheet": "radiopicker.scss",\n\t"selector": null,\n\t"options": {}\n}';});


define('text!enketo-widget/date/config.json',[],function () { return '{\n    "name": "datepickerExtended",\n    "stylesheet": "datepicker-extended.scss",\n    "selector": "input[type=\\"date\\"]:not([readonly])",\n    "options": {}\n}\n';});


define('text!enketo-widget/time/config.json',[],function () { return '{\n    "name": "timepickerExtended",\n    "stylesheet": "timepicker-extended.scss",\n    "selector": "input[type=\\"time\\"]:not([readonly])",\n    "options": {}\n}\n';});


define('text!enketo-widget/datetime/config.json',[],function () { return '{\n    "name": "datetimepickerExtended",\n    "stylesheet": "datetimepicker-extended.scss",\n    "selector": "input[type=\\"datetime\\"]:not([readonly])",\n    "options": {}\n}\n';});


define('text!enketo-widget/mediagrid/config.json',[],function () { return '{\n    "name": null,\n    "stylesheet": "mediagridpicker.scss",\n    "selector": null,\n    "options": {}\n}\n';});


define('text!enketo-widget/file-offline/config.json',[],function () { return '{\n\t"name": "offlineFilepicker",\n\t"stylesheet": "offline-filepicker.scss",\n\t"selector": "input[type=\\"file\\"]",\n\t"options": {}\n}';});


define('text!enketo-widget/select-likert/config.json',[],function () { return '{\n    "name": null,\n    "stylesheet": "likertitem.scss",\n    "selector": null,\n    "options": {}\n}\n';});


define('text!enketo-widget/distress/config.json',[],function () { return '{\n    "name": "distresspicker",\n    "stylesheet": "distresspicker.scss",\n    "selector": ".or-appearance-distress input[type=\'number\']",\n    "options": {}\n}\n';});

